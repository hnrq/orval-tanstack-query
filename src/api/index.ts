/**
 * Generated by orval v7.5.0 üç∫
 * Do not edit manually.
 * Pok√©API
 * All the Pok√©mon data you'll ever need in one place, easily accessible through a modern free open-source RESTful API.

## What is this?

This is a full RESTful API linked to an extensive database detailing everything about the Pok√©mon main game series.

We've covered everything from Pok√©mon to Berry Flavors.

## Where do I start?

We have awesome [documentation](https://pokeapi.co/docs/v2) on how to use this API. It takes minutes to get started.

This API will always be publicly available and will never require any extensive setup process to consume.

Created by [**Paul Hallett**](https://github.com/phalt) and other [**Pok√©API contributors***](https://github.com/PokeAPI/pokeapi#contributing) around the world. Pok√©mon and Pok√©mon character names are trademarks of Nintendo.
    
 * OpenAPI spec version: 2.7.0
 */
import { useInfiniteQuery, useQuery } from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";
import * as axios from "axios";
import type { AxiosError, AxiosRequestConfig, AxiosResponse } from "axios";
import type {
  AbilityDetail,
  AbilityListParams,
  BerryDetail,
  BerryFirmnessDetail,
  BerryFirmnessListParams,
  BerryFlavorDetail,
  BerryFlavorListParams,
  BerryListParams,
  CharacteristicDetail,
  CharacteristicListParams,
  ContestEffectDetail,
  ContestEffectListParams,
  ContestTypeDetail,
  ContestTypeListParams,
  EggGroupDetail,
  EggGroupListParams,
  EncounterConditionDetail,
  EncounterConditionListParams,
  EncounterConditionValueDetail,
  EncounterConditionValueListParams,
  EncounterMethodDetail,
  EncounterMethodListParams,
  EvolutionChainDetail,
  EvolutionChainListParams,
  EvolutionTriggerDetail,
  EvolutionTriggerListParams,
  GenderDetail,
  GenderListParams,
  GenerationDetail,
  GenerationListParams,
  GrowthRateDetail,
  GrowthRateListParams,
  ItemAttributeDetail,
  ItemAttributeListParams,
  ItemCategoryDetail,
  ItemCategoryListParams,
  ItemDetail,
  ItemFlingEffectDetail,
  ItemFlingEffectListParams,
  ItemListParams,
  ItemPocketDetail,
  ItemPocketListParams,
  LanguageDetail,
  LanguageListParams,
  LocationAreaDetail,
  LocationAreaListParams,
  LocationDetail,
  LocationListParams,
  MachineDetail,
  MachineListParams,
  MoveAilmentListParams,
  MoveBattleStyleDetail,
  MoveBattleStyleListParams,
  MoveCategoryListParams,
  MoveDamageClassDetail,
  MoveDamageClassListParams,
  MoveDetail,
  MoveLearnMethodDetail,
  MoveLearnMethodListParams,
  MoveListParams,
  MoveMetaAilmentDetail,
  MoveMetaCategoryDetail,
  MoveTargetDetail,
  MoveTargetListParams,
  NatureDetail,
  NatureListParams,
  PaginatedAbilitySummaryList,
  PaginatedBerryFirmnessSummaryList,
  PaginatedBerryFlavorSummaryList,
  PaginatedBerrySummaryList,
  PaginatedCharacteristicSummaryList,
  PaginatedContestEffectSummaryList,
  PaginatedContestTypeSummaryList,
  PaginatedEggGroupSummaryList,
  PaginatedEncounterConditionSummaryList,
  PaginatedEncounterConditionValueSummaryList,
  PaginatedEncounterMethodSummaryList,
  PaginatedEvolutionChainSummaryList,
  PaginatedEvolutionTriggerSummaryList,
  PaginatedGenderSummaryList,
  PaginatedGenerationSummaryList,
  PaginatedGrowthRateSummaryList,
  PaginatedItemAttributeSummaryList,
  PaginatedItemCategorySummaryList,
  PaginatedItemFlingEffectSummaryList,
  PaginatedItemPocketSummaryList,
  PaginatedItemSummaryList,
  PaginatedLanguageSummaryList,
  PaginatedLocationAreaSummaryList,
  PaginatedLocationSummaryList,
  PaginatedMachineSummaryList,
  PaginatedMoveBattleStyleSummaryList,
  PaginatedMoveDamageClassSummaryList,
  PaginatedMoveLearnMethodSummaryList,
  PaginatedMoveMetaAilmentSummaryList,
  PaginatedMoveMetaCategorySummaryList,
  PaginatedMoveSummaryList,
  PaginatedMoveTargetSummaryList,
  PaginatedNatureSummaryList,
  PaginatedPalParkAreaSummaryList,
  PaginatedPokeathlonStatSummaryList,
  PaginatedPokedexSummaryList,
  PaginatedPokemonColorSummaryList,
  PaginatedPokemonFormSummaryList,
  PaginatedPokemonHabitatSummaryList,
  PaginatedPokemonShapeSummaryList,
  PaginatedPokemonSpeciesSummaryList,
  PaginatedPokemonSummaryList,
  PaginatedRegionSummaryList,
  PaginatedStatSummaryList,
  PaginatedSuperContestEffectSummaryList,
  PaginatedTypeSummaryList,
  PaginatedVersionGroupSummaryList,
  PaginatedVersionSummaryList,
  PalParkAreaDetail,
  PalParkAreaListParams,
  PokeathlonStatDetail,
  PokeathlonStatListParams,
  PokedexDetail,
  PokedexListParams,
  PokemonColorDetail,
  PokemonColorListParams,
  PokemonDetail,
  PokemonEncountersRetrieve200Item,
  PokemonFormDetail,
  PokemonFormListParams,
  PokemonHabitatDetail,
  PokemonHabitatListParams,
  PokemonListParams,
  PokemonShapeDetail,
  PokemonShapeListParams,
  PokemonSpeciesDetail,
  PokemonSpeciesListParams,
  RegionDetail,
  RegionListParams,
  StatDetail,
  StatListParams,
  SuperContestEffectDetail,
  SuperContestEffectListParams,
  TypeDetail,
  TypeListParams,
  VersionDetail,
  VersionGroupDetail,
  VersionGroupListParams,
  VersionListParams,
} from "./model";

/**
 * Abilities provide passive effects for Pok√©mon in battle or in the overworld. Pok√©mon have multiple possible abilities but can have only one ability at a time. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Ability) for greater detail.
 */
export const abilityList = (
  params?: AbilityListParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedAbilitySummaryList>> => {
  return axios.default.get(`https://pokeapi.co/api/v2/ability`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getAbilityListQueryKey = (params?: AbilityListParams) => {
  return [
    `https://pokeapi.co/api/v2/ability`,
    ...(params ? [params] : []),
  ] as const;
};

export const getAbilityListInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof abilityList>>,
    AbilityListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: AbilityListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof abilityList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof abilityList>>,
        QueryKey,
        AbilityListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAbilityListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof abilityList>>,
    QueryKey,
    AbilityListParams["offset"]
  > = ({ signal, pageParam }) =>
    abilityList(
      { ...params, offset: pageParam || params?.["offset"] },
      { signal, ...axiosOptions },
    );

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof abilityList>>,
    TError,
    TData,
    Awaited<ReturnType<typeof abilityList>>,
    QueryKey,
    AbilityListParams["offset"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AbilityListInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof abilityList>>
>;
export type AbilityListInfiniteQueryError = AxiosError<unknown>;

export function useAbilityListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof abilityList>>,
    AbilityListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params: undefined | AbilityListParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof abilityList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof abilityList>>,
        QueryKey,
        AbilityListParams["offset"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof abilityList>>,
          TError,
          Awaited<ReturnType<typeof abilityList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAbilityListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof abilityList>>,
    AbilityListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: AbilityListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof abilityList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof abilityList>>,
        QueryKey,
        AbilityListParams["offset"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof abilityList>>,
          TError,
          Awaited<ReturnType<typeof abilityList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAbilityListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof abilityList>>,
    AbilityListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: AbilityListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof abilityList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof abilityList>>,
        QueryKey,
        AbilityListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useAbilityListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof abilityList>>,
    AbilityListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: AbilityListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof abilityList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof abilityList>>,
        QueryKey,
        AbilityListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAbilityListInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getAbilityListQueryOptions = <
  TData = Awaited<ReturnType<typeof abilityList>>,
  TError = AxiosError<unknown>,
>(
  params?: AbilityListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof abilityList>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAbilityListQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof abilityList>>> = ({
    signal,
  }) => abilityList(params, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof abilityList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AbilityListQueryResult = NonNullable<
  Awaited<ReturnType<typeof abilityList>>
>;
export type AbilityListQueryError = AxiosError<unknown>;

export function useAbilityList<
  TData = Awaited<ReturnType<typeof abilityList>>,
  TError = AxiosError<unknown>,
>(
  params: undefined | AbilityListParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof abilityList>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof abilityList>>,
          TError,
          Awaited<ReturnType<typeof abilityList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAbilityList<
  TData = Awaited<ReturnType<typeof abilityList>>,
  TError = AxiosError<unknown>,
>(
  params?: AbilityListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof abilityList>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof abilityList>>,
          TError,
          Awaited<ReturnType<typeof abilityList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAbilityList<
  TData = Awaited<ReturnType<typeof abilityList>>,
  TError = AxiosError<unknown>,
>(
  params?: AbilityListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof abilityList>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useAbilityList<
  TData = Awaited<ReturnType<typeof abilityList>>,
  TError = AxiosError<unknown>,
>(
  params?: AbilityListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof abilityList>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAbilityListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Abilities provide passive effects for Pok√©mon in battle or in the overworld. Pok√©mon have multiple possible abilities but can have only one ability at a time. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Ability) for greater detail.
 */
export const abilityRetrieve = (
  id: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<AbilityDetail>> => {
  return axios.default.get(`https://pokeapi.co/api/v2/ability/${id}`, options);
};

export const getAbilityRetrieveQueryKey = (id: string) => {
  return [`https://pokeapi.co/api/v2/ability/${id}`] as const;
};

export const getAbilityRetrieveInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof abilityRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof abilityRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAbilityRetrieveQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof abilityRetrieve>>> = ({
    signal,
  }) => abilityRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof abilityRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AbilityRetrieveInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof abilityRetrieve>>
>;
export type AbilityRetrieveInfiniteQueryError = AxiosError<unknown>;

export function useAbilityRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof abilityRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof abilityRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof abilityRetrieve>>,
          TError,
          Awaited<ReturnType<typeof abilityRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAbilityRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof abilityRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof abilityRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof abilityRetrieve>>,
          TError,
          Awaited<ReturnType<typeof abilityRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAbilityRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof abilityRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof abilityRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useAbilityRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof abilityRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof abilityRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAbilityRetrieveInfiniteQueryOptions(id, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getAbilityRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof abilityRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof abilityRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAbilityRetrieveQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof abilityRetrieve>>> = ({
    signal,
  }) => abilityRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof abilityRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AbilityRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof abilityRetrieve>>
>;
export type AbilityRetrieveQueryError = AxiosError<unknown>;

export function useAbilityRetrieve<
  TData = Awaited<ReturnType<typeof abilityRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof abilityRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof abilityRetrieve>>,
          TError,
          Awaited<ReturnType<typeof abilityRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAbilityRetrieve<
  TData = Awaited<ReturnType<typeof abilityRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof abilityRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof abilityRetrieve>>,
          TError,
          Awaited<ReturnType<typeof abilityRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAbilityRetrieve<
  TData = Awaited<ReturnType<typeof abilityRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof abilityRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useAbilityRetrieve<
  TData = Awaited<ReturnType<typeof abilityRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof abilityRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAbilityRetrieveQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Berries are small fruits that can provide HP and status condition restoration, stat enhancement, and even damage negation when eaten by Pok√©mon. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Berry) for greater detail.
 * @summary List berries
 */
export const berryList = (
  params?: BerryListParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedBerrySummaryList>> => {
  return axios.default.get(`https://pokeapi.co/api/v2/berry`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getBerryListQueryKey = (params?: BerryListParams) => {
  return [
    `https://pokeapi.co/api/v2/berry`,
    ...(params ? [params] : []),
  ] as const;
};

export const getBerryListInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof berryList>>,
    BerryListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: BerryListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof berryList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof berryList>>,
        QueryKey,
        BerryListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getBerryListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof berryList>>,
    QueryKey,
    BerryListParams["offset"]
  > = ({ signal, pageParam }) =>
    berryList(
      { ...params, offset: pageParam || params?.["offset"] },
      { signal, ...axiosOptions },
    );

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof berryList>>,
    TError,
    TData,
    Awaited<ReturnType<typeof berryList>>,
    QueryKey,
    BerryListParams["offset"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type BerryListInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof berryList>>
>;
export type BerryListInfiniteQueryError = AxiosError<unknown>;

export function useBerryListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof berryList>>,
    BerryListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params: undefined | BerryListParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof berryList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof berryList>>,
        QueryKey,
        BerryListParams["offset"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof berryList>>,
          TError,
          Awaited<ReturnType<typeof berryList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useBerryListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof berryList>>,
    BerryListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: BerryListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof berryList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof berryList>>,
        QueryKey,
        BerryListParams["offset"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof berryList>>,
          TError,
          Awaited<ReturnType<typeof berryList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useBerryListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof berryList>>,
    BerryListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: BerryListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof berryList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof berryList>>,
        QueryKey,
        BerryListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List berries
 */

export function useBerryListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof berryList>>,
    BerryListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: BerryListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof berryList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof berryList>>,
        QueryKey,
        BerryListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getBerryListInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getBerryListQueryOptions = <
  TData = Awaited<ReturnType<typeof berryList>>,
  TError = AxiosError<unknown>,
>(
  params?: BerryListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof berryList>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getBerryListQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof berryList>>> = ({
    signal,
  }) => berryList(params, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof berryList>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type BerryListQueryResult = NonNullable<
  Awaited<ReturnType<typeof berryList>>
>;
export type BerryListQueryError = AxiosError<unknown>;

export function useBerryList<
  TData = Awaited<ReturnType<typeof berryList>>,
  TError = AxiosError<unknown>,
>(
  params: undefined | BerryListParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof berryList>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof berryList>>,
          TError,
          Awaited<ReturnType<typeof berryList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useBerryList<
  TData = Awaited<ReturnType<typeof berryList>>,
  TError = AxiosError<unknown>,
>(
  params?: BerryListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof berryList>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof berryList>>,
          TError,
          Awaited<ReturnType<typeof berryList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useBerryList<
  TData = Awaited<ReturnType<typeof berryList>>,
  TError = AxiosError<unknown>,
>(
  params?: BerryListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof berryList>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List berries
 */

export function useBerryList<
  TData = Awaited<ReturnType<typeof berryList>>,
  TError = AxiosError<unknown>,
>(
  params?: BerryListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof berryList>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getBerryListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Berries are small fruits that can provide HP and status condition restoration, stat enhancement, and even damage negation when eaten by Pok√©mon. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Berry) for greater detail.
 * @summary Get a berry
 */
export const berryRetrieve = (
  id: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<BerryDetail>> => {
  return axios.default.get(`https://pokeapi.co/api/v2/berry/${id}`, options);
};

export const getBerryRetrieveQueryKey = (id: string) => {
  return [`https://pokeapi.co/api/v2/berry/${id}`] as const;
};

export const getBerryRetrieveInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof berryRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof berryRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getBerryRetrieveQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof berryRetrieve>>> = ({
    signal,
  }) => berryRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof berryRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type BerryRetrieveInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof berryRetrieve>>
>;
export type BerryRetrieveInfiniteQueryError = AxiosError<unknown>;

export function useBerryRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof berryRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof berryRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof berryRetrieve>>,
          TError,
          Awaited<ReturnType<typeof berryRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useBerryRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof berryRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof berryRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof berryRetrieve>>,
          TError,
          Awaited<ReturnType<typeof berryRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useBerryRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof berryRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof berryRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a berry
 */

export function useBerryRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof berryRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof berryRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getBerryRetrieveInfiniteQueryOptions(id, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getBerryRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof berryRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof berryRetrieve>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getBerryRetrieveQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof berryRetrieve>>> = ({
    signal,
  }) => berryRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof berryRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type BerryRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof berryRetrieve>>
>;
export type BerryRetrieveQueryError = AxiosError<unknown>;

export function useBerryRetrieve<
  TData = Awaited<ReturnType<typeof berryRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof berryRetrieve>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof berryRetrieve>>,
          TError,
          Awaited<ReturnType<typeof berryRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useBerryRetrieve<
  TData = Awaited<ReturnType<typeof berryRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof berryRetrieve>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof berryRetrieve>>,
          TError,
          Awaited<ReturnType<typeof berryRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useBerryRetrieve<
  TData = Awaited<ReturnType<typeof berryRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof berryRetrieve>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a berry
 */

export function useBerryRetrieve<
  TData = Awaited<ReturnType<typeof berryRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof berryRetrieve>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getBerryRetrieveQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Berries can be soft or hard. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Category:Berries_by_firmness) for greater detail.
 * @summary List berry firmness
 */
export const berryFirmnessList = (
  params?: BerryFirmnessListParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedBerryFirmnessSummaryList>> => {
  return axios.default.get(`https://pokeapi.co/api/v2/berry-firmness`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getBerryFirmnessListQueryKey = (
  params?: BerryFirmnessListParams,
) => {
  return [
    `https://pokeapi.co/api/v2/berry-firmness`,
    ...(params ? [params] : []),
  ] as const;
};

export const getBerryFirmnessListInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof berryFirmnessList>>,
    BerryFirmnessListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: BerryFirmnessListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof berryFirmnessList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof berryFirmnessList>>,
        QueryKey,
        BerryFirmnessListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getBerryFirmnessListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof berryFirmnessList>>,
    QueryKey,
    BerryFirmnessListParams["offset"]
  > = ({ signal, pageParam }) =>
    berryFirmnessList(
      { ...params, offset: pageParam || params?.["offset"] },
      { signal, ...axiosOptions },
    );

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof berryFirmnessList>>,
    TError,
    TData,
    Awaited<ReturnType<typeof berryFirmnessList>>,
    QueryKey,
    BerryFirmnessListParams["offset"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type BerryFirmnessListInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof berryFirmnessList>>
>;
export type BerryFirmnessListInfiniteQueryError = AxiosError<unknown>;

export function useBerryFirmnessListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof berryFirmnessList>>,
    BerryFirmnessListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params: undefined | BerryFirmnessListParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof berryFirmnessList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof berryFirmnessList>>,
        QueryKey,
        BerryFirmnessListParams["offset"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof berryFirmnessList>>,
          TError,
          Awaited<ReturnType<typeof berryFirmnessList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useBerryFirmnessListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof berryFirmnessList>>,
    BerryFirmnessListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: BerryFirmnessListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof berryFirmnessList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof berryFirmnessList>>,
        QueryKey,
        BerryFirmnessListParams["offset"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof berryFirmnessList>>,
          TError,
          Awaited<ReturnType<typeof berryFirmnessList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useBerryFirmnessListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof berryFirmnessList>>,
    BerryFirmnessListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: BerryFirmnessListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof berryFirmnessList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof berryFirmnessList>>,
        QueryKey,
        BerryFirmnessListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List berry firmness
 */

export function useBerryFirmnessListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof berryFirmnessList>>,
    BerryFirmnessListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: BerryFirmnessListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof berryFirmnessList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof berryFirmnessList>>,
        QueryKey,
        BerryFirmnessListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getBerryFirmnessListInfiniteQueryOptions(
    params,
    options,
  );

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getBerryFirmnessListQueryOptions = <
  TData = Awaited<ReturnType<typeof berryFirmnessList>>,
  TError = AxiosError<unknown>,
>(
  params?: BerryFirmnessListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof berryFirmnessList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getBerryFirmnessListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof berryFirmnessList>>
  > = ({ signal }) => berryFirmnessList(params, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof berryFirmnessList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type BerryFirmnessListQueryResult = NonNullable<
  Awaited<ReturnType<typeof berryFirmnessList>>
>;
export type BerryFirmnessListQueryError = AxiosError<unknown>;

export function useBerryFirmnessList<
  TData = Awaited<ReturnType<typeof berryFirmnessList>>,
  TError = AxiosError<unknown>,
>(
  params: undefined | BerryFirmnessListParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof berryFirmnessList>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof berryFirmnessList>>,
          TError,
          Awaited<ReturnType<typeof berryFirmnessList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useBerryFirmnessList<
  TData = Awaited<ReturnType<typeof berryFirmnessList>>,
  TError = AxiosError<unknown>,
>(
  params?: BerryFirmnessListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof berryFirmnessList>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof berryFirmnessList>>,
          TError,
          Awaited<ReturnType<typeof berryFirmnessList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useBerryFirmnessList<
  TData = Awaited<ReturnType<typeof berryFirmnessList>>,
  TError = AxiosError<unknown>,
>(
  params?: BerryFirmnessListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof berryFirmnessList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List berry firmness
 */

export function useBerryFirmnessList<
  TData = Awaited<ReturnType<typeof berryFirmnessList>>,
  TError = AxiosError<unknown>,
>(
  params?: BerryFirmnessListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof berryFirmnessList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getBerryFirmnessListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Berries can be soft or hard. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Category:Berries_by_firmness) for greater detail.
 * @summary Get berry by firmness
 */
export const berryFirmnessRetrieve = (
  id: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<BerryFirmnessDetail>> => {
  return axios.default.get(
    `https://pokeapi.co/api/v2/berry-firmness/${id}`,
    options,
  );
};

export const getBerryFirmnessRetrieveQueryKey = (id: string) => {
  return [`https://pokeapi.co/api/v2/berry-firmness/${id}`] as const;
};

export const getBerryFirmnessRetrieveInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof berryFirmnessRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof berryFirmnessRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getBerryFirmnessRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof berryFirmnessRetrieve>>
  > = ({ signal }) => berryFirmnessRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof berryFirmnessRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type BerryFirmnessRetrieveInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof berryFirmnessRetrieve>>
>;
export type BerryFirmnessRetrieveInfiniteQueryError = AxiosError<unknown>;

export function useBerryFirmnessRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof berryFirmnessRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof berryFirmnessRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof berryFirmnessRetrieve>>,
          TError,
          Awaited<ReturnType<typeof berryFirmnessRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useBerryFirmnessRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof berryFirmnessRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof berryFirmnessRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof berryFirmnessRetrieve>>,
          TError,
          Awaited<ReturnType<typeof berryFirmnessRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useBerryFirmnessRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof berryFirmnessRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof berryFirmnessRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get berry by firmness
 */

export function useBerryFirmnessRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof berryFirmnessRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof berryFirmnessRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getBerryFirmnessRetrieveInfiniteQueryOptions(
    id,
    options,
  );

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getBerryFirmnessRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof berryFirmnessRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof berryFirmnessRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getBerryFirmnessRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof berryFirmnessRetrieve>>
  > = ({ signal }) => berryFirmnessRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof berryFirmnessRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type BerryFirmnessRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof berryFirmnessRetrieve>>
>;
export type BerryFirmnessRetrieveQueryError = AxiosError<unknown>;

export function useBerryFirmnessRetrieve<
  TData = Awaited<ReturnType<typeof berryFirmnessRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof berryFirmnessRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof berryFirmnessRetrieve>>,
          TError,
          Awaited<ReturnType<typeof berryFirmnessRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useBerryFirmnessRetrieve<
  TData = Awaited<ReturnType<typeof berryFirmnessRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof berryFirmnessRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof berryFirmnessRetrieve>>,
          TError,
          Awaited<ReturnType<typeof berryFirmnessRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useBerryFirmnessRetrieve<
  TData = Awaited<ReturnType<typeof berryFirmnessRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof berryFirmnessRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get berry by firmness
 */

export function useBerryFirmnessRetrieve<
  TData = Awaited<ReturnType<typeof berryFirmnessRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof berryFirmnessRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getBerryFirmnessRetrieveQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Flavors determine whether a Pok√©mon will benefit or suffer from eating a berry based on their **nature**. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Flavor) for greater detail.
 * @summary List berry flavors
 */
export const berryFlavorList = (
  params?: BerryFlavorListParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedBerryFlavorSummaryList>> => {
  return axios.default.get(`https://pokeapi.co/api/v2/berry-flavor`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getBerryFlavorListQueryKey = (params?: BerryFlavorListParams) => {
  return [
    `https://pokeapi.co/api/v2/berry-flavor`,
    ...(params ? [params] : []),
  ] as const;
};

export const getBerryFlavorListInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof berryFlavorList>>,
    BerryFlavorListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: BerryFlavorListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof berryFlavorList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof berryFlavorList>>,
        QueryKey,
        BerryFlavorListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getBerryFlavorListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof berryFlavorList>>,
    QueryKey,
    BerryFlavorListParams["offset"]
  > = ({ signal, pageParam }) =>
    berryFlavorList(
      { ...params, offset: pageParam || params?.["offset"] },
      { signal, ...axiosOptions },
    );

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof berryFlavorList>>,
    TError,
    TData,
    Awaited<ReturnType<typeof berryFlavorList>>,
    QueryKey,
    BerryFlavorListParams["offset"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type BerryFlavorListInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof berryFlavorList>>
>;
export type BerryFlavorListInfiniteQueryError = AxiosError<unknown>;

export function useBerryFlavorListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof berryFlavorList>>,
    BerryFlavorListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params: undefined | BerryFlavorListParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof berryFlavorList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof berryFlavorList>>,
        QueryKey,
        BerryFlavorListParams["offset"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof berryFlavorList>>,
          TError,
          Awaited<ReturnType<typeof berryFlavorList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useBerryFlavorListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof berryFlavorList>>,
    BerryFlavorListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: BerryFlavorListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof berryFlavorList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof berryFlavorList>>,
        QueryKey,
        BerryFlavorListParams["offset"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof berryFlavorList>>,
          TError,
          Awaited<ReturnType<typeof berryFlavorList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useBerryFlavorListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof berryFlavorList>>,
    BerryFlavorListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: BerryFlavorListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof berryFlavorList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof berryFlavorList>>,
        QueryKey,
        BerryFlavorListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List berry flavors
 */

export function useBerryFlavorListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof berryFlavorList>>,
    BerryFlavorListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: BerryFlavorListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof berryFlavorList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof berryFlavorList>>,
        QueryKey,
        BerryFlavorListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getBerryFlavorListInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getBerryFlavorListQueryOptions = <
  TData = Awaited<ReturnType<typeof berryFlavorList>>,
  TError = AxiosError<unknown>,
>(
  params?: BerryFlavorListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof berryFlavorList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getBerryFlavorListQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof berryFlavorList>>> = ({
    signal,
  }) => berryFlavorList(params, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof berryFlavorList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type BerryFlavorListQueryResult = NonNullable<
  Awaited<ReturnType<typeof berryFlavorList>>
>;
export type BerryFlavorListQueryError = AxiosError<unknown>;

export function useBerryFlavorList<
  TData = Awaited<ReturnType<typeof berryFlavorList>>,
  TError = AxiosError<unknown>,
>(
  params: undefined | BerryFlavorListParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof berryFlavorList>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof berryFlavorList>>,
          TError,
          Awaited<ReturnType<typeof berryFlavorList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useBerryFlavorList<
  TData = Awaited<ReturnType<typeof berryFlavorList>>,
  TError = AxiosError<unknown>,
>(
  params?: BerryFlavorListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof berryFlavorList>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof berryFlavorList>>,
          TError,
          Awaited<ReturnType<typeof berryFlavorList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useBerryFlavorList<
  TData = Awaited<ReturnType<typeof berryFlavorList>>,
  TError = AxiosError<unknown>,
>(
  params?: BerryFlavorListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof berryFlavorList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List berry flavors
 */

export function useBerryFlavorList<
  TData = Awaited<ReturnType<typeof berryFlavorList>>,
  TError = AxiosError<unknown>,
>(
  params?: BerryFlavorListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof berryFlavorList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getBerryFlavorListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Flavors determine whether a Pok√©mon will benefit or suffer from eating a berry based on their **nature**. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Flavor) for greater detail.
 * @summary Get berries by flavor
 */
export const berryFlavorRetrieve = (
  id: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<BerryFlavorDetail>> => {
  return axios.default.get(
    `https://pokeapi.co/api/v2/berry-flavor/${id}`,
    options,
  );
};

export const getBerryFlavorRetrieveQueryKey = (id: string) => {
  return [`https://pokeapi.co/api/v2/berry-flavor/${id}`] as const;
};

export const getBerryFlavorRetrieveInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof berryFlavorRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof berryFlavorRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getBerryFlavorRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof berryFlavorRetrieve>>
  > = ({ signal }) => berryFlavorRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof berryFlavorRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type BerryFlavorRetrieveInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof berryFlavorRetrieve>>
>;
export type BerryFlavorRetrieveInfiniteQueryError = AxiosError<unknown>;

export function useBerryFlavorRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof berryFlavorRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof berryFlavorRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof berryFlavorRetrieve>>,
          TError,
          Awaited<ReturnType<typeof berryFlavorRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useBerryFlavorRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof berryFlavorRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof berryFlavorRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof berryFlavorRetrieve>>,
          TError,
          Awaited<ReturnType<typeof berryFlavorRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useBerryFlavorRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof berryFlavorRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof berryFlavorRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get berries by flavor
 */

export function useBerryFlavorRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof berryFlavorRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof berryFlavorRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getBerryFlavorRetrieveInfiniteQueryOptions(id, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getBerryFlavorRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof berryFlavorRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof berryFlavorRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getBerryFlavorRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof berryFlavorRetrieve>>
  > = ({ signal }) => berryFlavorRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof berryFlavorRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type BerryFlavorRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof berryFlavorRetrieve>>
>;
export type BerryFlavorRetrieveQueryError = AxiosError<unknown>;

export function useBerryFlavorRetrieve<
  TData = Awaited<ReturnType<typeof berryFlavorRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof berryFlavorRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof berryFlavorRetrieve>>,
          TError,
          Awaited<ReturnType<typeof berryFlavorRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useBerryFlavorRetrieve<
  TData = Awaited<ReturnType<typeof berryFlavorRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof berryFlavorRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof berryFlavorRetrieve>>,
          TError,
          Awaited<ReturnType<typeof berryFlavorRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useBerryFlavorRetrieve<
  TData = Awaited<ReturnType<typeof berryFlavorRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof berryFlavorRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get berries by flavor
 */

export function useBerryFlavorRetrieve<
  TData = Awaited<ReturnType<typeof berryFlavorRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof berryFlavorRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getBerryFlavorRetrieveQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Characteristics indicate which stat contains a Pok√©mon's highest IV. A Pok√©mon's Characteristic is determined by the remainder of its highest IV divided by 5 (gene_modulo). Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Characteristic) for greater detail.
 * @summary List charecterictics
 */
export const characteristicList = (
  params?: CharacteristicListParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedCharacteristicSummaryList>> => {
  return axios.default.get(`https://pokeapi.co/api/v2/characteristic`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getCharacteristicListQueryKey = (
  params?: CharacteristicListParams,
) => {
  return [
    `https://pokeapi.co/api/v2/characteristic`,
    ...(params ? [params] : []),
  ] as const;
};

export const getCharacteristicListInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof characteristicList>>,
    CharacteristicListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: CharacteristicListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof characteristicList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof characteristicList>>,
        QueryKey,
        CharacteristicListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getCharacteristicListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof characteristicList>>,
    QueryKey,
    CharacteristicListParams["offset"]
  > = ({ signal, pageParam }) =>
    characteristicList(
      { ...params, offset: pageParam || params?.["offset"] },
      { signal, ...axiosOptions },
    );

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof characteristicList>>,
    TError,
    TData,
    Awaited<ReturnType<typeof characteristicList>>,
    QueryKey,
    CharacteristicListParams["offset"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type CharacteristicListInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof characteristicList>>
>;
export type CharacteristicListInfiniteQueryError = AxiosError<unknown>;

export function useCharacteristicListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof characteristicList>>,
    CharacteristicListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params: undefined | CharacteristicListParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof characteristicList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof characteristicList>>,
        QueryKey,
        CharacteristicListParams["offset"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof characteristicList>>,
          TError,
          Awaited<ReturnType<typeof characteristicList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useCharacteristicListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof characteristicList>>,
    CharacteristicListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: CharacteristicListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof characteristicList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof characteristicList>>,
        QueryKey,
        CharacteristicListParams["offset"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof characteristicList>>,
          TError,
          Awaited<ReturnType<typeof characteristicList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useCharacteristicListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof characteristicList>>,
    CharacteristicListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: CharacteristicListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof characteristicList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof characteristicList>>,
        QueryKey,
        CharacteristicListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List charecterictics
 */

export function useCharacteristicListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof characteristicList>>,
    CharacteristicListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: CharacteristicListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof characteristicList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof characteristicList>>,
        QueryKey,
        CharacteristicListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getCharacteristicListInfiniteQueryOptions(
    params,
    options,
  );

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getCharacteristicListQueryOptions = <
  TData = Awaited<ReturnType<typeof characteristicList>>,
  TError = AxiosError<unknown>,
>(
  params?: CharacteristicListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof characteristicList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getCharacteristicListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof characteristicList>>
  > = ({ signal }) => characteristicList(params, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof characteristicList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type CharacteristicListQueryResult = NonNullable<
  Awaited<ReturnType<typeof characteristicList>>
>;
export type CharacteristicListQueryError = AxiosError<unknown>;

export function useCharacteristicList<
  TData = Awaited<ReturnType<typeof characteristicList>>,
  TError = AxiosError<unknown>,
>(
  params: undefined | CharacteristicListParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof characteristicList>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof characteristicList>>,
          TError,
          Awaited<ReturnType<typeof characteristicList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useCharacteristicList<
  TData = Awaited<ReturnType<typeof characteristicList>>,
  TError = AxiosError<unknown>,
>(
  params?: CharacteristicListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof characteristicList>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof characteristicList>>,
          TError,
          Awaited<ReturnType<typeof characteristicList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useCharacteristicList<
  TData = Awaited<ReturnType<typeof characteristicList>>,
  TError = AxiosError<unknown>,
>(
  params?: CharacteristicListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof characteristicList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List charecterictics
 */

export function useCharacteristicList<
  TData = Awaited<ReturnType<typeof characteristicList>>,
  TError = AxiosError<unknown>,
>(
  params?: CharacteristicListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof characteristicList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getCharacteristicListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Characteristics indicate which stat contains a Pok√©mon's highest IV. A Pok√©mon's Characteristic is determined by the remainder of its highest IV divided by 5 (gene_modulo). Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Characteristic) for greater detail.
 * @summary Get characteristic
 */
export const characteristicRetrieve = (
  id: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<CharacteristicDetail>> => {
  return axios.default.get(
    `https://pokeapi.co/api/v2/characteristic/${id}`,
    options,
  );
};

export const getCharacteristicRetrieveQueryKey = (id: string) => {
  return [`https://pokeapi.co/api/v2/characteristic/${id}`] as const;
};

export const getCharacteristicRetrieveInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof characteristicRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof characteristicRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getCharacteristicRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof characteristicRetrieve>>
  > = ({ signal }) => characteristicRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof characteristicRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type CharacteristicRetrieveInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof characteristicRetrieve>>
>;
export type CharacteristicRetrieveInfiniteQueryError = AxiosError<unknown>;

export function useCharacteristicRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof characteristicRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof characteristicRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof characteristicRetrieve>>,
          TError,
          Awaited<ReturnType<typeof characteristicRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useCharacteristicRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof characteristicRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof characteristicRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof characteristicRetrieve>>,
          TError,
          Awaited<ReturnType<typeof characteristicRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useCharacteristicRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof characteristicRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof characteristicRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get characteristic
 */

export function useCharacteristicRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof characteristicRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof characteristicRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getCharacteristicRetrieveInfiniteQueryOptions(
    id,
    options,
  );

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getCharacteristicRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof characteristicRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof characteristicRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getCharacteristicRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof characteristicRetrieve>>
  > = ({ signal }) => characteristicRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof characteristicRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type CharacteristicRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof characteristicRetrieve>>
>;
export type CharacteristicRetrieveQueryError = AxiosError<unknown>;

export function useCharacteristicRetrieve<
  TData = Awaited<ReturnType<typeof characteristicRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof characteristicRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof characteristicRetrieve>>,
          TError,
          Awaited<ReturnType<typeof characteristicRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useCharacteristicRetrieve<
  TData = Awaited<ReturnType<typeof characteristicRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof characteristicRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof characteristicRetrieve>>,
          TError,
          Awaited<ReturnType<typeof characteristicRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useCharacteristicRetrieve<
  TData = Awaited<ReturnType<typeof characteristicRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof characteristicRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get characteristic
 */

export function useCharacteristicRetrieve<
  TData = Awaited<ReturnType<typeof characteristicRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof characteristicRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getCharacteristicRetrieveQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Contest types are categories judges used to weigh a Pok√©mon's condition in Pok√©mon contests. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Contest_condition) for greater detail.
 * @summary List contest types
 */
export const contestTypeList = (
  params?: ContestTypeListParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedContestTypeSummaryList>> => {
  return axios.default.get(`https://pokeapi.co/api/v2/contest-type`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getContestTypeListQueryKey = (params?: ContestTypeListParams) => {
  return [
    `https://pokeapi.co/api/v2/contest-type`,
    ...(params ? [params] : []),
  ] as const;
};

export const getContestTypeListInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof contestTypeList>>,
    ContestTypeListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: ContestTypeListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof contestTypeList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof contestTypeList>>,
        QueryKey,
        ContestTypeListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getContestTypeListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof contestTypeList>>,
    QueryKey,
    ContestTypeListParams["offset"]
  > = ({ signal, pageParam }) =>
    contestTypeList(
      { ...params, offset: pageParam || params?.["offset"] },
      { signal, ...axiosOptions },
    );

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof contestTypeList>>,
    TError,
    TData,
    Awaited<ReturnType<typeof contestTypeList>>,
    QueryKey,
    ContestTypeListParams["offset"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ContestTypeListInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof contestTypeList>>
>;
export type ContestTypeListInfiniteQueryError = AxiosError<unknown>;

export function useContestTypeListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof contestTypeList>>,
    ContestTypeListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params: undefined | ContestTypeListParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof contestTypeList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof contestTypeList>>,
        QueryKey,
        ContestTypeListParams["offset"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof contestTypeList>>,
          TError,
          Awaited<ReturnType<typeof contestTypeList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useContestTypeListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof contestTypeList>>,
    ContestTypeListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: ContestTypeListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof contestTypeList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof contestTypeList>>,
        QueryKey,
        ContestTypeListParams["offset"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof contestTypeList>>,
          TError,
          Awaited<ReturnType<typeof contestTypeList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useContestTypeListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof contestTypeList>>,
    ContestTypeListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: ContestTypeListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof contestTypeList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof contestTypeList>>,
        QueryKey,
        ContestTypeListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List contest types
 */

export function useContestTypeListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof contestTypeList>>,
    ContestTypeListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: ContestTypeListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof contestTypeList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof contestTypeList>>,
        QueryKey,
        ContestTypeListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getContestTypeListInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getContestTypeListQueryOptions = <
  TData = Awaited<ReturnType<typeof contestTypeList>>,
  TError = AxiosError<unknown>,
>(
  params?: ContestTypeListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof contestTypeList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getContestTypeListQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof contestTypeList>>> = ({
    signal,
  }) => contestTypeList(params, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof contestTypeList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ContestTypeListQueryResult = NonNullable<
  Awaited<ReturnType<typeof contestTypeList>>
>;
export type ContestTypeListQueryError = AxiosError<unknown>;

export function useContestTypeList<
  TData = Awaited<ReturnType<typeof contestTypeList>>,
  TError = AxiosError<unknown>,
>(
  params: undefined | ContestTypeListParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof contestTypeList>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof contestTypeList>>,
          TError,
          Awaited<ReturnType<typeof contestTypeList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useContestTypeList<
  TData = Awaited<ReturnType<typeof contestTypeList>>,
  TError = AxiosError<unknown>,
>(
  params?: ContestTypeListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof contestTypeList>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof contestTypeList>>,
          TError,
          Awaited<ReturnType<typeof contestTypeList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useContestTypeList<
  TData = Awaited<ReturnType<typeof contestTypeList>>,
  TError = AxiosError<unknown>,
>(
  params?: ContestTypeListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof contestTypeList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List contest types
 */

export function useContestTypeList<
  TData = Awaited<ReturnType<typeof contestTypeList>>,
  TError = AxiosError<unknown>,
>(
  params?: ContestTypeListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof contestTypeList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getContestTypeListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Contest types are categories judges used to weigh a Pok√©mon's condition in Pok√©mon contests. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Contest_condition) for greater detail.
 * @summary Get contest type
 */
export const contestTypeRetrieve = (
  id: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<ContestTypeDetail>> => {
  return axios.default.get(
    `https://pokeapi.co/api/v2/contest-type/${id}`,
    options,
  );
};

export const getContestTypeRetrieveQueryKey = (id: string) => {
  return [`https://pokeapi.co/api/v2/contest-type/${id}`] as const;
};

export const getContestTypeRetrieveInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof contestTypeRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof contestTypeRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getContestTypeRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof contestTypeRetrieve>>
  > = ({ signal }) => contestTypeRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof contestTypeRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ContestTypeRetrieveInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof contestTypeRetrieve>>
>;
export type ContestTypeRetrieveInfiniteQueryError = AxiosError<unknown>;

export function useContestTypeRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof contestTypeRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof contestTypeRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof contestTypeRetrieve>>,
          TError,
          Awaited<ReturnType<typeof contestTypeRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useContestTypeRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof contestTypeRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof contestTypeRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof contestTypeRetrieve>>,
          TError,
          Awaited<ReturnType<typeof contestTypeRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useContestTypeRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof contestTypeRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof contestTypeRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get contest type
 */

export function useContestTypeRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof contestTypeRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof contestTypeRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getContestTypeRetrieveInfiniteQueryOptions(id, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getContestTypeRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof contestTypeRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof contestTypeRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getContestTypeRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof contestTypeRetrieve>>
  > = ({ signal }) => contestTypeRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof contestTypeRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ContestTypeRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof contestTypeRetrieve>>
>;
export type ContestTypeRetrieveQueryError = AxiosError<unknown>;

export function useContestTypeRetrieve<
  TData = Awaited<ReturnType<typeof contestTypeRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof contestTypeRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof contestTypeRetrieve>>,
          TError,
          Awaited<ReturnType<typeof contestTypeRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useContestTypeRetrieve<
  TData = Awaited<ReturnType<typeof contestTypeRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof contestTypeRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof contestTypeRetrieve>>,
          TError,
          Awaited<ReturnType<typeof contestTypeRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useContestTypeRetrieve<
  TData = Awaited<ReturnType<typeof contestTypeRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof contestTypeRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get contest type
 */

export function useContestTypeRetrieve<
  TData = Awaited<ReturnType<typeof contestTypeRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof contestTypeRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getContestTypeRetrieveQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Contest effects refer to the effects of moves when used in contests.
 * @summary List contest effects
 */
export const contestEffectList = (
  params?: ContestEffectListParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedContestEffectSummaryList>> => {
  return axios.default.get(`https://pokeapi.co/api/v2/contest-effect`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getContestEffectListQueryKey = (
  params?: ContestEffectListParams,
) => {
  return [
    `https://pokeapi.co/api/v2/contest-effect`,
    ...(params ? [params] : []),
  ] as const;
};

export const getContestEffectListInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof contestEffectList>>,
    ContestEffectListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: ContestEffectListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof contestEffectList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof contestEffectList>>,
        QueryKey,
        ContestEffectListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getContestEffectListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof contestEffectList>>,
    QueryKey,
    ContestEffectListParams["offset"]
  > = ({ signal, pageParam }) =>
    contestEffectList(
      { ...params, offset: pageParam || params?.["offset"] },
      { signal, ...axiosOptions },
    );

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof contestEffectList>>,
    TError,
    TData,
    Awaited<ReturnType<typeof contestEffectList>>,
    QueryKey,
    ContestEffectListParams["offset"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ContestEffectListInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof contestEffectList>>
>;
export type ContestEffectListInfiniteQueryError = AxiosError<unknown>;

export function useContestEffectListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof contestEffectList>>,
    ContestEffectListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params: undefined | ContestEffectListParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof contestEffectList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof contestEffectList>>,
        QueryKey,
        ContestEffectListParams["offset"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof contestEffectList>>,
          TError,
          Awaited<ReturnType<typeof contestEffectList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useContestEffectListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof contestEffectList>>,
    ContestEffectListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: ContestEffectListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof contestEffectList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof contestEffectList>>,
        QueryKey,
        ContestEffectListParams["offset"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof contestEffectList>>,
          TError,
          Awaited<ReturnType<typeof contestEffectList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useContestEffectListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof contestEffectList>>,
    ContestEffectListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: ContestEffectListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof contestEffectList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof contestEffectList>>,
        QueryKey,
        ContestEffectListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List contest effects
 */

export function useContestEffectListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof contestEffectList>>,
    ContestEffectListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: ContestEffectListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof contestEffectList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof contestEffectList>>,
        QueryKey,
        ContestEffectListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getContestEffectListInfiniteQueryOptions(
    params,
    options,
  );

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getContestEffectListQueryOptions = <
  TData = Awaited<ReturnType<typeof contestEffectList>>,
  TError = AxiosError<unknown>,
>(
  params?: ContestEffectListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof contestEffectList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getContestEffectListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof contestEffectList>>
  > = ({ signal }) => contestEffectList(params, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof contestEffectList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ContestEffectListQueryResult = NonNullable<
  Awaited<ReturnType<typeof contestEffectList>>
>;
export type ContestEffectListQueryError = AxiosError<unknown>;

export function useContestEffectList<
  TData = Awaited<ReturnType<typeof contestEffectList>>,
  TError = AxiosError<unknown>,
>(
  params: undefined | ContestEffectListParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof contestEffectList>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof contestEffectList>>,
          TError,
          Awaited<ReturnType<typeof contestEffectList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useContestEffectList<
  TData = Awaited<ReturnType<typeof contestEffectList>>,
  TError = AxiosError<unknown>,
>(
  params?: ContestEffectListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof contestEffectList>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof contestEffectList>>,
          TError,
          Awaited<ReturnType<typeof contestEffectList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useContestEffectList<
  TData = Awaited<ReturnType<typeof contestEffectList>>,
  TError = AxiosError<unknown>,
>(
  params?: ContestEffectListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof contestEffectList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List contest effects
 */

export function useContestEffectList<
  TData = Awaited<ReturnType<typeof contestEffectList>>,
  TError = AxiosError<unknown>,
>(
  params?: ContestEffectListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof contestEffectList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getContestEffectListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Contest effects refer to the effects of moves when used in contests.
 * @summary Get contest effect
 */
export const contestEffectRetrieve = (
  id: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<ContestEffectDetail>> => {
  return axios.default.get(
    `https://pokeapi.co/api/v2/contest-effect/${id}`,
    options,
  );
};

export const getContestEffectRetrieveQueryKey = (id: string) => {
  return [`https://pokeapi.co/api/v2/contest-effect/${id}`] as const;
};

export const getContestEffectRetrieveInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof contestEffectRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof contestEffectRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getContestEffectRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof contestEffectRetrieve>>
  > = ({ signal }) => contestEffectRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof contestEffectRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ContestEffectRetrieveInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof contestEffectRetrieve>>
>;
export type ContestEffectRetrieveInfiniteQueryError = AxiosError<unknown>;

export function useContestEffectRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof contestEffectRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof contestEffectRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof contestEffectRetrieve>>,
          TError,
          Awaited<ReturnType<typeof contestEffectRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useContestEffectRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof contestEffectRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof contestEffectRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof contestEffectRetrieve>>,
          TError,
          Awaited<ReturnType<typeof contestEffectRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useContestEffectRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof contestEffectRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof contestEffectRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get contest effect
 */

export function useContestEffectRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof contestEffectRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof contestEffectRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getContestEffectRetrieveInfiniteQueryOptions(
    id,
    options,
  );

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getContestEffectRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof contestEffectRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof contestEffectRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getContestEffectRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof contestEffectRetrieve>>
  > = ({ signal }) => contestEffectRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof contestEffectRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ContestEffectRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof contestEffectRetrieve>>
>;
export type ContestEffectRetrieveQueryError = AxiosError<unknown>;

export function useContestEffectRetrieve<
  TData = Awaited<ReturnType<typeof contestEffectRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof contestEffectRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof contestEffectRetrieve>>,
          TError,
          Awaited<ReturnType<typeof contestEffectRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useContestEffectRetrieve<
  TData = Awaited<ReturnType<typeof contestEffectRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof contestEffectRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof contestEffectRetrieve>>,
          TError,
          Awaited<ReturnType<typeof contestEffectRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useContestEffectRetrieve<
  TData = Awaited<ReturnType<typeof contestEffectRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof contestEffectRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get contest effect
 */

export function useContestEffectRetrieve<
  TData = Awaited<ReturnType<typeof contestEffectRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof contestEffectRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getContestEffectRetrieveQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Egg Groups are categories which determine which Pok√©mon are able to interbreed. Pok√©mon may belong to either one or two Egg Groups. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Egg_Group) for greater detail.
 * @summary List egg groups
 */
export const eggGroupList = (
  params?: EggGroupListParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedEggGroupSummaryList>> => {
  return axios.default.get(`https://pokeapi.co/api/v2/egg-group`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getEggGroupListQueryKey = (params?: EggGroupListParams) => {
  return [
    `https://pokeapi.co/api/v2/egg-group`,
    ...(params ? [params] : []),
  ] as const;
};

export const getEggGroupListInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof eggGroupList>>,
    EggGroupListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: EggGroupListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof eggGroupList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof eggGroupList>>,
        QueryKey,
        EggGroupListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getEggGroupListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof eggGroupList>>,
    QueryKey,
    EggGroupListParams["offset"]
  > = ({ signal, pageParam }) =>
    eggGroupList(
      { ...params, offset: pageParam || params?.["offset"] },
      { signal, ...axiosOptions },
    );

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof eggGroupList>>,
    TError,
    TData,
    Awaited<ReturnType<typeof eggGroupList>>,
    QueryKey,
    EggGroupListParams["offset"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type EggGroupListInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof eggGroupList>>
>;
export type EggGroupListInfiniteQueryError = AxiosError<unknown>;

export function useEggGroupListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof eggGroupList>>,
    EggGroupListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params: undefined | EggGroupListParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof eggGroupList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof eggGroupList>>,
        QueryKey,
        EggGroupListParams["offset"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof eggGroupList>>,
          TError,
          Awaited<ReturnType<typeof eggGroupList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useEggGroupListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof eggGroupList>>,
    EggGroupListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: EggGroupListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof eggGroupList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof eggGroupList>>,
        QueryKey,
        EggGroupListParams["offset"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof eggGroupList>>,
          TError,
          Awaited<ReturnType<typeof eggGroupList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useEggGroupListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof eggGroupList>>,
    EggGroupListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: EggGroupListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof eggGroupList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof eggGroupList>>,
        QueryKey,
        EggGroupListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List egg groups
 */

export function useEggGroupListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof eggGroupList>>,
    EggGroupListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: EggGroupListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof eggGroupList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof eggGroupList>>,
        QueryKey,
        EggGroupListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getEggGroupListInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getEggGroupListQueryOptions = <
  TData = Awaited<ReturnType<typeof eggGroupList>>,
  TError = AxiosError<unknown>,
>(
  params?: EggGroupListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof eggGroupList>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getEggGroupListQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof eggGroupList>>> = ({
    signal,
  }) => eggGroupList(params, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof eggGroupList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type EggGroupListQueryResult = NonNullable<
  Awaited<ReturnType<typeof eggGroupList>>
>;
export type EggGroupListQueryError = AxiosError<unknown>;

export function useEggGroupList<
  TData = Awaited<ReturnType<typeof eggGroupList>>,
  TError = AxiosError<unknown>,
>(
  params: undefined | EggGroupListParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof eggGroupList>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof eggGroupList>>,
          TError,
          Awaited<ReturnType<typeof eggGroupList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useEggGroupList<
  TData = Awaited<ReturnType<typeof eggGroupList>>,
  TError = AxiosError<unknown>,
>(
  params?: EggGroupListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof eggGroupList>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof eggGroupList>>,
          TError,
          Awaited<ReturnType<typeof eggGroupList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useEggGroupList<
  TData = Awaited<ReturnType<typeof eggGroupList>>,
  TError = AxiosError<unknown>,
>(
  params?: EggGroupListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof eggGroupList>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List egg groups
 */

export function useEggGroupList<
  TData = Awaited<ReturnType<typeof eggGroupList>>,
  TError = AxiosError<unknown>,
>(
  params?: EggGroupListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof eggGroupList>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getEggGroupListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Egg Groups are categories which determine which Pok√©mon are able to interbreed. Pok√©mon may belong to either one or two Egg Groups. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Egg_Group) for greater detail.
 * @summary Get egg group
 */
export const eggGroupRetrieve = (
  id: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<EggGroupDetail>> => {
  return axios.default.get(
    `https://pokeapi.co/api/v2/egg-group/${id}`,
    options,
  );
};

export const getEggGroupRetrieveQueryKey = (id: string) => {
  return [`https://pokeapi.co/api/v2/egg-group/${id}`] as const;
};

export const getEggGroupRetrieveInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof eggGroupRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof eggGroupRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getEggGroupRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof eggGroupRetrieve>>
  > = ({ signal }) => eggGroupRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof eggGroupRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type EggGroupRetrieveInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof eggGroupRetrieve>>
>;
export type EggGroupRetrieveInfiniteQueryError = AxiosError<unknown>;

export function useEggGroupRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof eggGroupRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof eggGroupRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof eggGroupRetrieve>>,
          TError,
          Awaited<ReturnType<typeof eggGroupRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useEggGroupRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof eggGroupRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof eggGroupRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof eggGroupRetrieve>>,
          TError,
          Awaited<ReturnType<typeof eggGroupRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useEggGroupRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof eggGroupRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof eggGroupRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get egg group
 */

export function useEggGroupRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof eggGroupRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof eggGroupRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getEggGroupRetrieveInfiniteQueryOptions(id, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getEggGroupRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof eggGroupRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof eggGroupRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getEggGroupRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof eggGroupRetrieve>>
  > = ({ signal }) => eggGroupRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof eggGroupRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type EggGroupRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof eggGroupRetrieve>>
>;
export type EggGroupRetrieveQueryError = AxiosError<unknown>;

export function useEggGroupRetrieve<
  TData = Awaited<ReturnType<typeof eggGroupRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof eggGroupRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof eggGroupRetrieve>>,
          TError,
          Awaited<ReturnType<typeof eggGroupRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useEggGroupRetrieve<
  TData = Awaited<ReturnType<typeof eggGroupRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof eggGroupRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof eggGroupRetrieve>>,
          TError,
          Awaited<ReturnType<typeof eggGroupRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useEggGroupRetrieve<
  TData = Awaited<ReturnType<typeof eggGroupRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof eggGroupRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get egg group
 */

export function useEggGroupRetrieve<
  TData = Awaited<ReturnType<typeof eggGroupRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof eggGroupRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getEggGroupRetrieveQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Methods by which the player might can encounter Pok√©mon in the wild, e.g., walking in tall grass. Check out Bulbapedia for greater detail.
 * @summary List encounter methods
 */
export const encounterMethodList = (
  params?: EncounterMethodListParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedEncounterMethodSummaryList>> => {
  return axios.default.get(`https://pokeapi.co/api/v2/encounter-method`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getEncounterMethodListQueryKey = (
  params?: EncounterMethodListParams,
) => {
  return [
    `https://pokeapi.co/api/v2/encounter-method`,
    ...(params ? [params] : []),
  ] as const;
};

export const getEncounterMethodListInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof encounterMethodList>>,
    EncounterMethodListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: EncounterMethodListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof encounterMethodList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof encounterMethodList>>,
        QueryKey,
        EncounterMethodListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getEncounterMethodListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof encounterMethodList>>,
    QueryKey,
    EncounterMethodListParams["offset"]
  > = ({ signal, pageParam }) =>
    encounterMethodList(
      { ...params, offset: pageParam || params?.["offset"] },
      { signal, ...axiosOptions },
    );

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof encounterMethodList>>,
    TError,
    TData,
    Awaited<ReturnType<typeof encounterMethodList>>,
    QueryKey,
    EncounterMethodListParams["offset"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type EncounterMethodListInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof encounterMethodList>>
>;
export type EncounterMethodListInfiniteQueryError = AxiosError<unknown>;

export function useEncounterMethodListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof encounterMethodList>>,
    EncounterMethodListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params: undefined | EncounterMethodListParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof encounterMethodList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof encounterMethodList>>,
        QueryKey,
        EncounterMethodListParams["offset"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof encounterMethodList>>,
          TError,
          Awaited<ReturnType<typeof encounterMethodList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useEncounterMethodListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof encounterMethodList>>,
    EncounterMethodListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: EncounterMethodListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof encounterMethodList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof encounterMethodList>>,
        QueryKey,
        EncounterMethodListParams["offset"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof encounterMethodList>>,
          TError,
          Awaited<ReturnType<typeof encounterMethodList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useEncounterMethodListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof encounterMethodList>>,
    EncounterMethodListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: EncounterMethodListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof encounterMethodList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof encounterMethodList>>,
        QueryKey,
        EncounterMethodListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List encounter methods
 */

export function useEncounterMethodListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof encounterMethodList>>,
    EncounterMethodListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: EncounterMethodListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof encounterMethodList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof encounterMethodList>>,
        QueryKey,
        EncounterMethodListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getEncounterMethodListInfiniteQueryOptions(
    params,
    options,
  );

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getEncounterMethodListQueryOptions = <
  TData = Awaited<ReturnType<typeof encounterMethodList>>,
  TError = AxiosError<unknown>,
>(
  params?: EncounterMethodListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof encounterMethodList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getEncounterMethodListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof encounterMethodList>>
  > = ({ signal }) => encounterMethodList(params, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof encounterMethodList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type EncounterMethodListQueryResult = NonNullable<
  Awaited<ReturnType<typeof encounterMethodList>>
>;
export type EncounterMethodListQueryError = AxiosError<unknown>;

export function useEncounterMethodList<
  TData = Awaited<ReturnType<typeof encounterMethodList>>,
  TError = AxiosError<unknown>,
>(
  params: undefined | EncounterMethodListParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof encounterMethodList>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof encounterMethodList>>,
          TError,
          Awaited<ReturnType<typeof encounterMethodList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useEncounterMethodList<
  TData = Awaited<ReturnType<typeof encounterMethodList>>,
  TError = AxiosError<unknown>,
>(
  params?: EncounterMethodListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof encounterMethodList>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof encounterMethodList>>,
          TError,
          Awaited<ReturnType<typeof encounterMethodList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useEncounterMethodList<
  TData = Awaited<ReturnType<typeof encounterMethodList>>,
  TError = AxiosError<unknown>,
>(
  params?: EncounterMethodListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof encounterMethodList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List encounter methods
 */

export function useEncounterMethodList<
  TData = Awaited<ReturnType<typeof encounterMethodList>>,
  TError = AxiosError<unknown>,
>(
  params?: EncounterMethodListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof encounterMethodList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getEncounterMethodListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Methods by which the player might can encounter Pok√©mon in the wild, e.g., walking in tall grass. Check out Bulbapedia for greater detail.
 * @summary Get encounter method
 */
export const encounterMethodRetrieve = (
  id: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<EncounterMethodDetail>> => {
  return axios.default.get(
    `https://pokeapi.co/api/v2/encounter-method/${id}`,
    options,
  );
};

export const getEncounterMethodRetrieveQueryKey = (id: string) => {
  return [`https://pokeapi.co/api/v2/encounter-method/${id}`] as const;
};

export const getEncounterMethodRetrieveInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof encounterMethodRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof encounterMethodRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getEncounterMethodRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof encounterMethodRetrieve>>
  > = ({ signal }) => encounterMethodRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof encounterMethodRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type EncounterMethodRetrieveInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof encounterMethodRetrieve>>
>;
export type EncounterMethodRetrieveInfiniteQueryError = AxiosError<unknown>;

export function useEncounterMethodRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof encounterMethodRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof encounterMethodRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof encounterMethodRetrieve>>,
          TError,
          Awaited<ReturnType<typeof encounterMethodRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useEncounterMethodRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof encounterMethodRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof encounterMethodRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof encounterMethodRetrieve>>,
          TError,
          Awaited<ReturnType<typeof encounterMethodRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useEncounterMethodRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof encounterMethodRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof encounterMethodRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get encounter method
 */

export function useEncounterMethodRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof encounterMethodRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof encounterMethodRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getEncounterMethodRetrieveInfiniteQueryOptions(
    id,
    options,
  );

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getEncounterMethodRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof encounterMethodRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof encounterMethodRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getEncounterMethodRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof encounterMethodRetrieve>>
  > = ({ signal }) => encounterMethodRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof encounterMethodRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type EncounterMethodRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof encounterMethodRetrieve>>
>;
export type EncounterMethodRetrieveQueryError = AxiosError<unknown>;

export function useEncounterMethodRetrieve<
  TData = Awaited<ReturnType<typeof encounterMethodRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof encounterMethodRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof encounterMethodRetrieve>>,
          TError,
          Awaited<ReturnType<typeof encounterMethodRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useEncounterMethodRetrieve<
  TData = Awaited<ReturnType<typeof encounterMethodRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof encounterMethodRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof encounterMethodRetrieve>>,
          TError,
          Awaited<ReturnType<typeof encounterMethodRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useEncounterMethodRetrieve<
  TData = Awaited<ReturnType<typeof encounterMethodRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof encounterMethodRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get encounter method
 */

export function useEncounterMethodRetrieve<
  TData = Awaited<ReturnType<typeof encounterMethodRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof encounterMethodRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getEncounterMethodRetrieveQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Conditions which affect what pokemon might appear in the wild, e.g., day or night.
 * @summary List encounter conditions
 */
export const encounterConditionList = (
  params?: EncounterConditionListParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedEncounterConditionSummaryList>> => {
  return axios.default.get(`https://pokeapi.co/api/v2/encounter-condition`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getEncounterConditionListQueryKey = (
  params?: EncounterConditionListParams,
) => {
  return [
    `https://pokeapi.co/api/v2/encounter-condition`,
    ...(params ? [params] : []),
  ] as const;
};

export const getEncounterConditionListInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof encounterConditionList>>,
    EncounterConditionListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: EncounterConditionListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof encounterConditionList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof encounterConditionList>>,
        QueryKey,
        EncounterConditionListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getEncounterConditionListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof encounterConditionList>>,
    QueryKey,
    EncounterConditionListParams["offset"]
  > = ({ signal, pageParam }) =>
    encounterConditionList(
      { ...params, offset: pageParam || params?.["offset"] },
      { signal, ...axiosOptions },
    );

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof encounterConditionList>>,
    TError,
    TData,
    Awaited<ReturnType<typeof encounterConditionList>>,
    QueryKey,
    EncounterConditionListParams["offset"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type EncounterConditionListInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof encounterConditionList>>
>;
export type EncounterConditionListInfiniteQueryError = AxiosError<unknown>;

export function useEncounterConditionListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof encounterConditionList>>,
    EncounterConditionListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params: undefined | EncounterConditionListParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof encounterConditionList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof encounterConditionList>>,
        QueryKey,
        EncounterConditionListParams["offset"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof encounterConditionList>>,
          TError,
          Awaited<ReturnType<typeof encounterConditionList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useEncounterConditionListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof encounterConditionList>>,
    EncounterConditionListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: EncounterConditionListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof encounterConditionList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof encounterConditionList>>,
        QueryKey,
        EncounterConditionListParams["offset"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof encounterConditionList>>,
          TError,
          Awaited<ReturnType<typeof encounterConditionList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useEncounterConditionListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof encounterConditionList>>,
    EncounterConditionListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: EncounterConditionListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof encounterConditionList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof encounterConditionList>>,
        QueryKey,
        EncounterConditionListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List encounter conditions
 */

export function useEncounterConditionListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof encounterConditionList>>,
    EncounterConditionListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: EncounterConditionListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof encounterConditionList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof encounterConditionList>>,
        QueryKey,
        EncounterConditionListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getEncounterConditionListInfiniteQueryOptions(
    params,
    options,
  );

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getEncounterConditionListQueryOptions = <
  TData = Awaited<ReturnType<typeof encounterConditionList>>,
  TError = AxiosError<unknown>,
>(
  params?: EncounterConditionListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof encounterConditionList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getEncounterConditionListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof encounterConditionList>>
  > = ({ signal }) =>
    encounterConditionList(params, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof encounterConditionList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type EncounterConditionListQueryResult = NonNullable<
  Awaited<ReturnType<typeof encounterConditionList>>
>;
export type EncounterConditionListQueryError = AxiosError<unknown>;

export function useEncounterConditionList<
  TData = Awaited<ReturnType<typeof encounterConditionList>>,
  TError = AxiosError<unknown>,
>(
  params: undefined | EncounterConditionListParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof encounterConditionList>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof encounterConditionList>>,
          TError,
          Awaited<ReturnType<typeof encounterConditionList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useEncounterConditionList<
  TData = Awaited<ReturnType<typeof encounterConditionList>>,
  TError = AxiosError<unknown>,
>(
  params?: EncounterConditionListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof encounterConditionList>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof encounterConditionList>>,
          TError,
          Awaited<ReturnType<typeof encounterConditionList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useEncounterConditionList<
  TData = Awaited<ReturnType<typeof encounterConditionList>>,
  TError = AxiosError<unknown>,
>(
  params?: EncounterConditionListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof encounterConditionList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List encounter conditions
 */

export function useEncounterConditionList<
  TData = Awaited<ReturnType<typeof encounterConditionList>>,
  TError = AxiosError<unknown>,
>(
  params?: EncounterConditionListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof encounterConditionList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getEncounterConditionListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Conditions which affect what pokemon might appear in the wild, e.g., day or night.
 * @summary Get encounter condition
 */
export const encounterConditionRetrieve = (
  id: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<EncounterConditionDetail>> => {
  return axios.default.get(
    `https://pokeapi.co/api/v2/encounter-condition/${id}`,
    options,
  );
};

export const getEncounterConditionRetrieveQueryKey = (id: string) => {
  return [`https://pokeapi.co/api/v2/encounter-condition/${id}`] as const;
};

export const getEncounterConditionRetrieveInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof encounterConditionRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof encounterConditionRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getEncounterConditionRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof encounterConditionRetrieve>>
  > = ({ signal }) =>
    encounterConditionRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof encounterConditionRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type EncounterConditionRetrieveInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof encounterConditionRetrieve>>
>;
export type EncounterConditionRetrieveInfiniteQueryError = AxiosError<unknown>;

export function useEncounterConditionRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof encounterConditionRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof encounterConditionRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof encounterConditionRetrieve>>,
          TError,
          Awaited<ReturnType<typeof encounterConditionRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useEncounterConditionRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof encounterConditionRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof encounterConditionRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof encounterConditionRetrieve>>,
          TError,
          Awaited<ReturnType<typeof encounterConditionRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useEncounterConditionRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof encounterConditionRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof encounterConditionRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get encounter condition
 */

export function useEncounterConditionRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof encounterConditionRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof encounterConditionRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getEncounterConditionRetrieveInfiniteQueryOptions(
    id,
    options,
  );

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getEncounterConditionRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof encounterConditionRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof encounterConditionRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getEncounterConditionRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof encounterConditionRetrieve>>
  > = ({ signal }) =>
    encounterConditionRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof encounterConditionRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type EncounterConditionRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof encounterConditionRetrieve>>
>;
export type EncounterConditionRetrieveQueryError = AxiosError<unknown>;

export function useEncounterConditionRetrieve<
  TData = Awaited<ReturnType<typeof encounterConditionRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof encounterConditionRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof encounterConditionRetrieve>>,
          TError,
          Awaited<ReturnType<typeof encounterConditionRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useEncounterConditionRetrieve<
  TData = Awaited<ReturnType<typeof encounterConditionRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof encounterConditionRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof encounterConditionRetrieve>>,
          TError,
          Awaited<ReturnType<typeof encounterConditionRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useEncounterConditionRetrieve<
  TData = Awaited<ReturnType<typeof encounterConditionRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof encounterConditionRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get encounter condition
 */

export function useEncounterConditionRetrieve<
  TData = Awaited<ReturnType<typeof encounterConditionRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof encounterConditionRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getEncounterConditionRetrieveQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Encounter condition values are the various states that an encounter condition can have, i.e., time of day can be either day or night.
 * @summary List encounter condition values
 */
export const encounterConditionValueList = (
  params?: EncounterConditionValueListParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedEncounterConditionValueSummaryList>> => {
  return axios.default.get(
    `https://pokeapi.co/api/v2/encounter-condition-value`,
    {
      ...options,
      params: { ...params, ...options?.params },
    },
  );
};

export const getEncounterConditionValueListQueryKey = (
  params?: EncounterConditionValueListParams,
) => {
  return [
    `https://pokeapi.co/api/v2/encounter-condition-value`,
    ...(params ? [params] : []),
  ] as const;
};

export const getEncounterConditionValueListInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof encounterConditionValueList>>,
    EncounterConditionValueListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: EncounterConditionValueListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof encounterConditionValueList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof encounterConditionValueList>>,
        QueryKey,
        EncounterConditionValueListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getEncounterConditionValueListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof encounterConditionValueList>>,
    QueryKey,
    EncounterConditionValueListParams["offset"]
  > = ({ signal, pageParam }) =>
    encounterConditionValueList(
      { ...params, offset: pageParam || params?.["offset"] },
      { signal, ...axiosOptions },
    );

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof encounterConditionValueList>>,
    TError,
    TData,
    Awaited<ReturnType<typeof encounterConditionValueList>>,
    QueryKey,
    EncounterConditionValueListParams["offset"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type EncounterConditionValueListInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof encounterConditionValueList>>
>;
export type EncounterConditionValueListInfiniteQueryError = AxiosError<unknown>;

export function useEncounterConditionValueListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof encounterConditionValueList>>,
    EncounterConditionValueListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params: undefined | EncounterConditionValueListParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof encounterConditionValueList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof encounterConditionValueList>>,
        QueryKey,
        EncounterConditionValueListParams["offset"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof encounterConditionValueList>>,
          TError,
          Awaited<ReturnType<typeof encounterConditionValueList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useEncounterConditionValueListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof encounterConditionValueList>>,
    EncounterConditionValueListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: EncounterConditionValueListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof encounterConditionValueList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof encounterConditionValueList>>,
        QueryKey,
        EncounterConditionValueListParams["offset"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof encounterConditionValueList>>,
          TError,
          Awaited<ReturnType<typeof encounterConditionValueList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useEncounterConditionValueListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof encounterConditionValueList>>,
    EncounterConditionValueListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: EncounterConditionValueListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof encounterConditionValueList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof encounterConditionValueList>>,
        QueryKey,
        EncounterConditionValueListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List encounter condition values
 */

export function useEncounterConditionValueListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof encounterConditionValueList>>,
    EncounterConditionValueListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: EncounterConditionValueListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof encounterConditionValueList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof encounterConditionValueList>>,
        QueryKey,
        EncounterConditionValueListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getEncounterConditionValueListInfiniteQueryOptions(
    params,
    options,
  );

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getEncounterConditionValueListQueryOptions = <
  TData = Awaited<ReturnType<typeof encounterConditionValueList>>,
  TError = AxiosError<unknown>,
>(
  params?: EncounterConditionValueListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof encounterConditionValueList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getEncounterConditionValueListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof encounterConditionValueList>>
  > = ({ signal }) =>
    encounterConditionValueList(params, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof encounterConditionValueList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type EncounterConditionValueListQueryResult = NonNullable<
  Awaited<ReturnType<typeof encounterConditionValueList>>
>;
export type EncounterConditionValueListQueryError = AxiosError<unknown>;

export function useEncounterConditionValueList<
  TData = Awaited<ReturnType<typeof encounterConditionValueList>>,
  TError = AxiosError<unknown>,
>(
  params: undefined | EncounterConditionValueListParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof encounterConditionValueList>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof encounterConditionValueList>>,
          TError,
          Awaited<ReturnType<typeof encounterConditionValueList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useEncounterConditionValueList<
  TData = Awaited<ReturnType<typeof encounterConditionValueList>>,
  TError = AxiosError<unknown>,
>(
  params?: EncounterConditionValueListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof encounterConditionValueList>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof encounterConditionValueList>>,
          TError,
          Awaited<ReturnType<typeof encounterConditionValueList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useEncounterConditionValueList<
  TData = Awaited<ReturnType<typeof encounterConditionValueList>>,
  TError = AxiosError<unknown>,
>(
  params?: EncounterConditionValueListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof encounterConditionValueList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List encounter condition values
 */

export function useEncounterConditionValueList<
  TData = Awaited<ReturnType<typeof encounterConditionValueList>>,
  TError = AxiosError<unknown>,
>(
  params?: EncounterConditionValueListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof encounterConditionValueList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getEncounterConditionValueListQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Encounter condition values are the various states that an encounter condition can have, i.e., time of day can be either day or night.
 * @summary Get encounter condition value
 */
export const encounterConditionValueRetrieve = (
  id: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<EncounterConditionValueDetail>> => {
  return axios.default.get(
    `https://pokeapi.co/api/v2/encounter-condition-value/${id}`,
    options,
  );
};

export const getEncounterConditionValueRetrieveQueryKey = (id: string) => {
  return [`https://pokeapi.co/api/v2/encounter-condition-value/${id}`] as const;
};

export const getEncounterConditionValueRetrieveInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof encounterConditionValueRetrieve>>
  >,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof encounterConditionValueRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getEncounterConditionValueRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof encounterConditionValueRetrieve>>
  > = ({ signal }) =>
    encounterConditionValueRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof encounterConditionValueRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type EncounterConditionValueRetrieveInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof encounterConditionValueRetrieve>>
>;
export type EncounterConditionValueRetrieveInfiniteQueryError =
  AxiosError<unknown>;

export function useEncounterConditionValueRetrieveInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof encounterConditionValueRetrieve>>
  >,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof encounterConditionValueRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof encounterConditionValueRetrieve>>,
          TError,
          Awaited<ReturnType<typeof encounterConditionValueRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useEncounterConditionValueRetrieveInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof encounterConditionValueRetrieve>>
  >,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof encounterConditionValueRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof encounterConditionValueRetrieve>>,
          TError,
          Awaited<ReturnType<typeof encounterConditionValueRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useEncounterConditionValueRetrieveInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof encounterConditionValueRetrieve>>
  >,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof encounterConditionValueRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get encounter condition value
 */

export function useEncounterConditionValueRetrieveInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof encounterConditionValueRetrieve>>
  >,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof encounterConditionValueRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getEncounterConditionValueRetrieveInfiniteQueryOptions(
    id,
    options,
  );

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getEncounterConditionValueRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof encounterConditionValueRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof encounterConditionValueRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getEncounterConditionValueRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof encounterConditionValueRetrieve>>
  > = ({ signal }) =>
    encounterConditionValueRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof encounterConditionValueRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type EncounterConditionValueRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof encounterConditionValueRetrieve>>
>;
export type EncounterConditionValueRetrieveQueryError = AxiosError<unknown>;

export function useEncounterConditionValueRetrieve<
  TData = Awaited<ReturnType<typeof encounterConditionValueRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof encounterConditionValueRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof encounterConditionValueRetrieve>>,
          TError,
          Awaited<ReturnType<typeof encounterConditionValueRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useEncounterConditionValueRetrieve<
  TData = Awaited<ReturnType<typeof encounterConditionValueRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof encounterConditionValueRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof encounterConditionValueRetrieve>>,
          TError,
          Awaited<ReturnType<typeof encounterConditionValueRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useEncounterConditionValueRetrieve<
  TData = Awaited<ReturnType<typeof encounterConditionValueRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof encounterConditionValueRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get encounter condition value
 */

export function useEncounterConditionValueRetrieve<
  TData = Awaited<ReturnType<typeof encounterConditionValueRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof encounterConditionValueRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getEncounterConditionValueRetrieveQueryOptions(
    id,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Evolution chains are essentially family trees. They start with the lowest stage within a family and detail evolution conditions for each as well as Pok√©mon they can evolve into up through the hierarchy.
 * @summary List evolution chains
 */
export const evolutionChainList = (
  params?: EvolutionChainListParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedEvolutionChainSummaryList>> => {
  return axios.default.get(`https://pokeapi.co/api/v2/evolution-chain`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getEvolutionChainListQueryKey = (
  params?: EvolutionChainListParams,
) => {
  return [
    `https://pokeapi.co/api/v2/evolution-chain`,
    ...(params ? [params] : []),
  ] as const;
};

export const getEvolutionChainListInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof evolutionChainList>>,
    EvolutionChainListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: EvolutionChainListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof evolutionChainList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof evolutionChainList>>,
        QueryKey,
        EvolutionChainListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getEvolutionChainListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof evolutionChainList>>,
    QueryKey,
    EvolutionChainListParams["offset"]
  > = ({ signal, pageParam }) =>
    evolutionChainList(
      { ...params, offset: pageParam || params?.["offset"] },
      { signal, ...axiosOptions },
    );

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof evolutionChainList>>,
    TError,
    TData,
    Awaited<ReturnType<typeof evolutionChainList>>,
    QueryKey,
    EvolutionChainListParams["offset"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type EvolutionChainListInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof evolutionChainList>>
>;
export type EvolutionChainListInfiniteQueryError = AxiosError<unknown>;

export function useEvolutionChainListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof evolutionChainList>>,
    EvolutionChainListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params: undefined | EvolutionChainListParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof evolutionChainList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof evolutionChainList>>,
        QueryKey,
        EvolutionChainListParams["offset"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof evolutionChainList>>,
          TError,
          Awaited<ReturnType<typeof evolutionChainList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useEvolutionChainListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof evolutionChainList>>,
    EvolutionChainListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: EvolutionChainListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof evolutionChainList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof evolutionChainList>>,
        QueryKey,
        EvolutionChainListParams["offset"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof evolutionChainList>>,
          TError,
          Awaited<ReturnType<typeof evolutionChainList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useEvolutionChainListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof evolutionChainList>>,
    EvolutionChainListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: EvolutionChainListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof evolutionChainList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof evolutionChainList>>,
        QueryKey,
        EvolutionChainListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List evolution chains
 */

export function useEvolutionChainListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof evolutionChainList>>,
    EvolutionChainListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: EvolutionChainListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof evolutionChainList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof evolutionChainList>>,
        QueryKey,
        EvolutionChainListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getEvolutionChainListInfiniteQueryOptions(
    params,
    options,
  );

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getEvolutionChainListQueryOptions = <
  TData = Awaited<ReturnType<typeof evolutionChainList>>,
  TError = AxiosError<unknown>,
>(
  params?: EvolutionChainListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof evolutionChainList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getEvolutionChainListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof evolutionChainList>>
  > = ({ signal }) => evolutionChainList(params, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof evolutionChainList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type EvolutionChainListQueryResult = NonNullable<
  Awaited<ReturnType<typeof evolutionChainList>>
>;
export type EvolutionChainListQueryError = AxiosError<unknown>;

export function useEvolutionChainList<
  TData = Awaited<ReturnType<typeof evolutionChainList>>,
  TError = AxiosError<unknown>,
>(
  params: undefined | EvolutionChainListParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof evolutionChainList>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof evolutionChainList>>,
          TError,
          Awaited<ReturnType<typeof evolutionChainList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useEvolutionChainList<
  TData = Awaited<ReturnType<typeof evolutionChainList>>,
  TError = AxiosError<unknown>,
>(
  params?: EvolutionChainListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof evolutionChainList>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof evolutionChainList>>,
          TError,
          Awaited<ReturnType<typeof evolutionChainList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useEvolutionChainList<
  TData = Awaited<ReturnType<typeof evolutionChainList>>,
  TError = AxiosError<unknown>,
>(
  params?: EvolutionChainListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof evolutionChainList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List evolution chains
 */

export function useEvolutionChainList<
  TData = Awaited<ReturnType<typeof evolutionChainList>>,
  TError = AxiosError<unknown>,
>(
  params?: EvolutionChainListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof evolutionChainList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getEvolutionChainListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Evolution chains are essentially family trees. They start with the lowest stage within a family and detail evolution conditions for each as well as Pok√©mon they can evolve into up through the hierarchy.
 * @summary Get evolution chain
 */
export const evolutionChainRetrieve = (
  id: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<EvolutionChainDetail>> => {
  return axios.default.get(
    `https://pokeapi.co/api/v2/evolution-chain/${id}`,
    options,
  );
};

export const getEvolutionChainRetrieveQueryKey = (id: string) => {
  return [`https://pokeapi.co/api/v2/evolution-chain/${id}`] as const;
};

export const getEvolutionChainRetrieveInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof evolutionChainRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof evolutionChainRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getEvolutionChainRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof evolutionChainRetrieve>>
  > = ({ signal }) => evolutionChainRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof evolutionChainRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type EvolutionChainRetrieveInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof evolutionChainRetrieve>>
>;
export type EvolutionChainRetrieveInfiniteQueryError = AxiosError<unknown>;

export function useEvolutionChainRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof evolutionChainRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof evolutionChainRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof evolutionChainRetrieve>>,
          TError,
          Awaited<ReturnType<typeof evolutionChainRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useEvolutionChainRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof evolutionChainRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof evolutionChainRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof evolutionChainRetrieve>>,
          TError,
          Awaited<ReturnType<typeof evolutionChainRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useEvolutionChainRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof evolutionChainRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof evolutionChainRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get evolution chain
 */

export function useEvolutionChainRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof evolutionChainRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof evolutionChainRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getEvolutionChainRetrieveInfiniteQueryOptions(
    id,
    options,
  );

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getEvolutionChainRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof evolutionChainRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof evolutionChainRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getEvolutionChainRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof evolutionChainRetrieve>>
  > = ({ signal }) => evolutionChainRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof evolutionChainRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type EvolutionChainRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof evolutionChainRetrieve>>
>;
export type EvolutionChainRetrieveQueryError = AxiosError<unknown>;

export function useEvolutionChainRetrieve<
  TData = Awaited<ReturnType<typeof evolutionChainRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof evolutionChainRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof evolutionChainRetrieve>>,
          TError,
          Awaited<ReturnType<typeof evolutionChainRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useEvolutionChainRetrieve<
  TData = Awaited<ReturnType<typeof evolutionChainRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof evolutionChainRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof evolutionChainRetrieve>>,
          TError,
          Awaited<ReturnType<typeof evolutionChainRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useEvolutionChainRetrieve<
  TData = Awaited<ReturnType<typeof evolutionChainRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof evolutionChainRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get evolution chain
 */

export function useEvolutionChainRetrieve<
  TData = Awaited<ReturnType<typeof evolutionChainRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof evolutionChainRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getEvolutionChainRetrieveQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Evolution triggers are the events and conditions that cause a Pok√©mon to evolve. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Methods_of_evolution) for greater detail.
 * @summary List evolution triggers
 */
export const evolutionTriggerList = (
  params?: EvolutionTriggerListParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedEvolutionTriggerSummaryList>> => {
  return axios.default.get(`https://pokeapi.co/api/v2/evolution-trigger`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getEvolutionTriggerListQueryKey = (
  params?: EvolutionTriggerListParams,
) => {
  return [
    `https://pokeapi.co/api/v2/evolution-trigger`,
    ...(params ? [params] : []),
  ] as const;
};

export const getEvolutionTriggerListInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof evolutionTriggerList>>,
    EvolutionTriggerListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: EvolutionTriggerListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof evolutionTriggerList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof evolutionTriggerList>>,
        QueryKey,
        EvolutionTriggerListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getEvolutionTriggerListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof evolutionTriggerList>>,
    QueryKey,
    EvolutionTriggerListParams["offset"]
  > = ({ signal, pageParam }) =>
    evolutionTriggerList(
      { ...params, offset: pageParam || params?.["offset"] },
      { signal, ...axiosOptions },
    );

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof evolutionTriggerList>>,
    TError,
    TData,
    Awaited<ReturnType<typeof evolutionTriggerList>>,
    QueryKey,
    EvolutionTriggerListParams["offset"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type EvolutionTriggerListInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof evolutionTriggerList>>
>;
export type EvolutionTriggerListInfiniteQueryError = AxiosError<unknown>;

export function useEvolutionTriggerListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof evolutionTriggerList>>,
    EvolutionTriggerListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params: undefined | EvolutionTriggerListParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof evolutionTriggerList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof evolutionTriggerList>>,
        QueryKey,
        EvolutionTriggerListParams["offset"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof evolutionTriggerList>>,
          TError,
          Awaited<ReturnType<typeof evolutionTriggerList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useEvolutionTriggerListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof evolutionTriggerList>>,
    EvolutionTriggerListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: EvolutionTriggerListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof evolutionTriggerList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof evolutionTriggerList>>,
        QueryKey,
        EvolutionTriggerListParams["offset"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof evolutionTriggerList>>,
          TError,
          Awaited<ReturnType<typeof evolutionTriggerList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useEvolutionTriggerListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof evolutionTriggerList>>,
    EvolutionTriggerListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: EvolutionTriggerListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof evolutionTriggerList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof evolutionTriggerList>>,
        QueryKey,
        EvolutionTriggerListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List evolution triggers
 */

export function useEvolutionTriggerListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof evolutionTriggerList>>,
    EvolutionTriggerListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: EvolutionTriggerListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof evolutionTriggerList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof evolutionTriggerList>>,
        QueryKey,
        EvolutionTriggerListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getEvolutionTriggerListInfiniteQueryOptions(
    params,
    options,
  );

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getEvolutionTriggerListQueryOptions = <
  TData = Awaited<ReturnType<typeof evolutionTriggerList>>,
  TError = AxiosError<unknown>,
>(
  params?: EvolutionTriggerListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof evolutionTriggerList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getEvolutionTriggerListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof evolutionTriggerList>>
  > = ({ signal }) => evolutionTriggerList(params, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof evolutionTriggerList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type EvolutionTriggerListQueryResult = NonNullable<
  Awaited<ReturnType<typeof evolutionTriggerList>>
>;
export type EvolutionTriggerListQueryError = AxiosError<unknown>;

export function useEvolutionTriggerList<
  TData = Awaited<ReturnType<typeof evolutionTriggerList>>,
  TError = AxiosError<unknown>,
>(
  params: undefined | EvolutionTriggerListParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof evolutionTriggerList>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof evolutionTriggerList>>,
          TError,
          Awaited<ReturnType<typeof evolutionTriggerList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useEvolutionTriggerList<
  TData = Awaited<ReturnType<typeof evolutionTriggerList>>,
  TError = AxiosError<unknown>,
>(
  params?: EvolutionTriggerListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof evolutionTriggerList>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof evolutionTriggerList>>,
          TError,
          Awaited<ReturnType<typeof evolutionTriggerList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useEvolutionTriggerList<
  TData = Awaited<ReturnType<typeof evolutionTriggerList>>,
  TError = AxiosError<unknown>,
>(
  params?: EvolutionTriggerListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof evolutionTriggerList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List evolution triggers
 */

export function useEvolutionTriggerList<
  TData = Awaited<ReturnType<typeof evolutionTriggerList>>,
  TError = AxiosError<unknown>,
>(
  params?: EvolutionTriggerListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof evolutionTriggerList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getEvolutionTriggerListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Evolution triggers are the events and conditions that cause a Pok√©mon to evolve. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Methods_of_evolution) for greater detail.
 * @summary Get evolution trigger
 */
export const evolutionTriggerRetrieve = (
  id: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<EvolutionTriggerDetail>> => {
  return axios.default.get(
    `https://pokeapi.co/api/v2/evolution-trigger/${id}`,
    options,
  );
};

export const getEvolutionTriggerRetrieveQueryKey = (id: string) => {
  return [`https://pokeapi.co/api/v2/evolution-trigger/${id}`] as const;
};

export const getEvolutionTriggerRetrieveInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof evolutionTriggerRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof evolutionTriggerRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getEvolutionTriggerRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof evolutionTriggerRetrieve>>
  > = ({ signal }) => evolutionTriggerRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof evolutionTriggerRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type EvolutionTriggerRetrieveInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof evolutionTriggerRetrieve>>
>;
export type EvolutionTriggerRetrieveInfiniteQueryError = AxiosError<unknown>;

export function useEvolutionTriggerRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof evolutionTriggerRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof evolutionTriggerRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof evolutionTriggerRetrieve>>,
          TError,
          Awaited<ReturnType<typeof evolutionTriggerRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useEvolutionTriggerRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof evolutionTriggerRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof evolutionTriggerRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof evolutionTriggerRetrieve>>,
          TError,
          Awaited<ReturnType<typeof evolutionTriggerRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useEvolutionTriggerRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof evolutionTriggerRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof evolutionTriggerRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get evolution trigger
 */

export function useEvolutionTriggerRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof evolutionTriggerRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof evolutionTriggerRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getEvolutionTriggerRetrieveInfiniteQueryOptions(
    id,
    options,
  );

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getEvolutionTriggerRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof evolutionTriggerRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof evolutionTriggerRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getEvolutionTriggerRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof evolutionTriggerRetrieve>>
  > = ({ signal }) => evolutionTriggerRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof evolutionTriggerRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type EvolutionTriggerRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof evolutionTriggerRetrieve>>
>;
export type EvolutionTriggerRetrieveQueryError = AxiosError<unknown>;

export function useEvolutionTriggerRetrieve<
  TData = Awaited<ReturnType<typeof evolutionTriggerRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof evolutionTriggerRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof evolutionTriggerRetrieve>>,
          TError,
          Awaited<ReturnType<typeof evolutionTriggerRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useEvolutionTriggerRetrieve<
  TData = Awaited<ReturnType<typeof evolutionTriggerRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof evolutionTriggerRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof evolutionTriggerRetrieve>>,
          TError,
          Awaited<ReturnType<typeof evolutionTriggerRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useEvolutionTriggerRetrieve<
  TData = Awaited<ReturnType<typeof evolutionTriggerRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof evolutionTriggerRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get evolution trigger
 */

export function useEvolutionTriggerRetrieve<
  TData = Awaited<ReturnType<typeof evolutionTriggerRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof evolutionTriggerRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getEvolutionTriggerRetrieveQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * A generation is a grouping of the Pok√©mon games that separates them based on the Pok√©mon they include. In each generation, a new set of Pok√©mon, Moves, Abilities and Types that did not exist in the previous generation are released.
 * @summary List genrations
 */
export const generationList = (
  params?: GenerationListParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedGenerationSummaryList>> => {
  return axios.default.get(`https://pokeapi.co/api/v2/generation`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getGenerationListQueryKey = (params?: GenerationListParams) => {
  return [
    `https://pokeapi.co/api/v2/generation`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGenerationListInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof generationList>>,
    GenerationListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: GenerationListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof generationList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof generationList>>,
        QueryKey,
        GenerationListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGenerationListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof generationList>>,
    QueryKey,
    GenerationListParams["offset"]
  > = ({ signal, pageParam }) =>
    generationList(
      { ...params, offset: pageParam || params?.["offset"] },
      { signal, ...axiosOptions },
    );

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof generationList>>,
    TError,
    TData,
    Awaited<ReturnType<typeof generationList>>,
    QueryKey,
    GenerationListParams["offset"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GenerationListInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof generationList>>
>;
export type GenerationListInfiniteQueryError = AxiosError<unknown>;

export function useGenerationListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof generationList>>,
    GenerationListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params: undefined | GenerationListParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof generationList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof generationList>>,
        QueryKey,
        GenerationListParams["offset"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof generationList>>,
          TError,
          Awaited<ReturnType<typeof generationList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGenerationListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof generationList>>,
    GenerationListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: GenerationListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof generationList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof generationList>>,
        QueryKey,
        GenerationListParams["offset"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof generationList>>,
          TError,
          Awaited<ReturnType<typeof generationList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGenerationListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof generationList>>,
    GenerationListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: GenerationListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof generationList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof generationList>>,
        QueryKey,
        GenerationListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List genrations
 */

export function useGenerationListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof generationList>>,
    GenerationListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: GenerationListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof generationList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof generationList>>,
        QueryKey,
        GenerationListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGenerationListInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGenerationListQueryOptions = <
  TData = Awaited<ReturnType<typeof generationList>>,
  TError = AxiosError<unknown>,
>(
  params?: GenerationListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof generationList>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGenerationListQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof generationList>>> = ({
    signal,
  }) => generationList(params, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof generationList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GenerationListQueryResult = NonNullable<
  Awaited<ReturnType<typeof generationList>>
>;
export type GenerationListQueryError = AxiosError<unknown>;

export function useGenerationList<
  TData = Awaited<ReturnType<typeof generationList>>,
  TError = AxiosError<unknown>,
>(
  params: undefined | GenerationListParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof generationList>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof generationList>>,
          TError,
          Awaited<ReturnType<typeof generationList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGenerationList<
  TData = Awaited<ReturnType<typeof generationList>>,
  TError = AxiosError<unknown>,
>(
  params?: GenerationListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof generationList>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof generationList>>,
          TError,
          Awaited<ReturnType<typeof generationList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGenerationList<
  TData = Awaited<ReturnType<typeof generationList>>,
  TError = AxiosError<unknown>,
>(
  params?: GenerationListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof generationList>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List genrations
 */

export function useGenerationList<
  TData = Awaited<ReturnType<typeof generationList>>,
  TError = AxiosError<unknown>,
>(
  params?: GenerationListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof generationList>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGenerationListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * A generation is a grouping of the Pok√©mon games that separates them based on the Pok√©mon they include. In each generation, a new set of Pok√©mon, Moves, Abilities and Types that did not exist in the previous generation are released.
 * @summary Get genration
 */
export const generationRetrieve = (
  id: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<GenerationDetail>> => {
  return axios.default.get(
    `https://pokeapi.co/api/v2/generation/${id}`,
    options,
  );
};

export const getGenerationRetrieveQueryKey = (id: string) => {
  return [`https://pokeapi.co/api/v2/generation/${id}`] as const;
};

export const getGenerationRetrieveInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof generationRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof generationRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGenerationRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof generationRetrieve>>
  > = ({ signal }) => generationRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof generationRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GenerationRetrieveInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof generationRetrieve>>
>;
export type GenerationRetrieveInfiniteQueryError = AxiosError<unknown>;

export function useGenerationRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof generationRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof generationRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof generationRetrieve>>,
          TError,
          Awaited<ReturnType<typeof generationRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGenerationRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof generationRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof generationRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof generationRetrieve>>,
          TError,
          Awaited<ReturnType<typeof generationRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGenerationRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof generationRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof generationRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get genration
 */

export function useGenerationRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof generationRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof generationRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGenerationRetrieveInfiniteQueryOptions(id, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGenerationRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof generationRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof generationRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGenerationRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof generationRetrieve>>
  > = ({ signal }) => generationRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof generationRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GenerationRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof generationRetrieve>>
>;
export type GenerationRetrieveQueryError = AxiosError<unknown>;

export function useGenerationRetrieve<
  TData = Awaited<ReturnType<typeof generationRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof generationRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof generationRetrieve>>,
          TError,
          Awaited<ReturnType<typeof generationRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGenerationRetrieve<
  TData = Awaited<ReturnType<typeof generationRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof generationRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof generationRetrieve>>,
          TError,
          Awaited<ReturnType<typeof generationRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGenerationRetrieve<
  TData = Awaited<ReturnType<typeof generationRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof generationRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get genration
 */

export function useGenerationRetrieve<
  TData = Awaited<ReturnType<typeof generationRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof generationRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGenerationRetrieveQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Genders were introduced in Generation II for the purposes of breeding Pok√©mon but can also result in visual differences or even different evolutionary lines. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Gender) for greater detail.
 * @summary List genders
 */
export const genderList = (
  params?: GenderListParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedGenderSummaryList>> => {
  return axios.default.get(`https://pokeapi.co/api/v2/gender`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getGenderListQueryKey = (params?: GenderListParams) => {
  return [
    `https://pokeapi.co/api/v2/gender`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGenderListInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof genderList>>,
    GenderListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: GenderListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof genderList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof genderList>>,
        QueryKey,
        GenderListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGenderListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof genderList>>,
    QueryKey,
    GenderListParams["offset"]
  > = ({ signal, pageParam }) =>
    genderList(
      { ...params, offset: pageParam || params?.["offset"] },
      { signal, ...axiosOptions },
    );

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof genderList>>,
    TError,
    TData,
    Awaited<ReturnType<typeof genderList>>,
    QueryKey,
    GenderListParams["offset"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GenderListInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof genderList>>
>;
export type GenderListInfiniteQueryError = AxiosError<unknown>;

export function useGenderListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof genderList>>,
    GenderListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params: undefined | GenderListParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof genderList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof genderList>>,
        QueryKey,
        GenderListParams["offset"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof genderList>>,
          TError,
          Awaited<ReturnType<typeof genderList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGenderListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof genderList>>,
    GenderListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: GenderListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof genderList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof genderList>>,
        QueryKey,
        GenderListParams["offset"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof genderList>>,
          TError,
          Awaited<ReturnType<typeof genderList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGenderListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof genderList>>,
    GenderListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: GenderListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof genderList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof genderList>>,
        QueryKey,
        GenderListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List genders
 */

export function useGenderListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof genderList>>,
    GenderListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: GenderListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof genderList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof genderList>>,
        QueryKey,
        GenderListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGenderListInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGenderListQueryOptions = <
  TData = Awaited<ReturnType<typeof genderList>>,
  TError = AxiosError<unknown>,
>(
  params?: GenderListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof genderList>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGenderListQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof genderList>>> = ({
    signal,
  }) => genderList(params, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof genderList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GenderListQueryResult = NonNullable<
  Awaited<ReturnType<typeof genderList>>
>;
export type GenderListQueryError = AxiosError<unknown>;

export function useGenderList<
  TData = Awaited<ReturnType<typeof genderList>>,
  TError = AxiosError<unknown>,
>(
  params: undefined | GenderListParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof genderList>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof genderList>>,
          TError,
          Awaited<ReturnType<typeof genderList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGenderList<
  TData = Awaited<ReturnType<typeof genderList>>,
  TError = AxiosError<unknown>,
>(
  params?: GenderListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof genderList>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof genderList>>,
          TError,
          Awaited<ReturnType<typeof genderList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGenderList<
  TData = Awaited<ReturnType<typeof genderList>>,
  TError = AxiosError<unknown>,
>(
  params?: GenderListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof genderList>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List genders
 */

export function useGenderList<
  TData = Awaited<ReturnType<typeof genderList>>,
  TError = AxiosError<unknown>,
>(
  params?: GenderListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof genderList>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGenderListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Genders were introduced in Generation II for the purposes of breeding Pok√©mon but can also result in visual differences or even different evolutionary lines. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Gender) for greater detail.
 * @summary Get gender
 */
export const genderRetrieve = (
  id: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<GenderDetail>> => {
  return axios.default.get(`https://pokeapi.co/api/v2/gender/${id}`, options);
};

export const getGenderRetrieveQueryKey = (id: string) => {
  return [`https://pokeapi.co/api/v2/gender/${id}`] as const;
};

export const getGenderRetrieveInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof genderRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof genderRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGenderRetrieveQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof genderRetrieve>>> = ({
    signal,
  }) => genderRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof genderRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GenderRetrieveInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof genderRetrieve>>
>;
export type GenderRetrieveInfiniteQueryError = AxiosError<unknown>;

export function useGenderRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof genderRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof genderRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof genderRetrieve>>,
          TError,
          Awaited<ReturnType<typeof genderRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGenderRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof genderRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof genderRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof genderRetrieve>>,
          TError,
          Awaited<ReturnType<typeof genderRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGenderRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof genderRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof genderRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get gender
 */

export function useGenderRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof genderRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof genderRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGenderRetrieveInfiniteQueryOptions(id, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGenderRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof genderRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof genderRetrieve>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGenderRetrieveQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof genderRetrieve>>> = ({
    signal,
  }) => genderRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof genderRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GenderRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof genderRetrieve>>
>;
export type GenderRetrieveQueryError = AxiosError<unknown>;

export function useGenderRetrieve<
  TData = Awaited<ReturnType<typeof genderRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof genderRetrieve>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof genderRetrieve>>,
          TError,
          Awaited<ReturnType<typeof genderRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGenderRetrieve<
  TData = Awaited<ReturnType<typeof genderRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof genderRetrieve>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof genderRetrieve>>,
          TError,
          Awaited<ReturnType<typeof genderRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGenderRetrieve<
  TData = Awaited<ReturnType<typeof genderRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof genderRetrieve>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get gender
 */

export function useGenderRetrieve<
  TData = Awaited<ReturnType<typeof genderRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof genderRetrieve>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGenderRetrieveQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Growth rates are the speed with which Pok√©mon gain levels through experience. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Experience) for greater detail.
 * @summary List growth rates
 */
export const growthRateList = (
  params?: GrowthRateListParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedGrowthRateSummaryList>> => {
  return axios.default.get(`https://pokeapi.co/api/v2/growth-rate`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getGrowthRateListQueryKey = (params?: GrowthRateListParams) => {
  return [
    `https://pokeapi.co/api/v2/growth-rate`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGrowthRateListInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof growthRateList>>,
    GrowthRateListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: GrowthRateListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof growthRateList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof growthRateList>>,
        QueryKey,
        GrowthRateListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGrowthRateListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof growthRateList>>,
    QueryKey,
    GrowthRateListParams["offset"]
  > = ({ signal, pageParam }) =>
    growthRateList(
      { ...params, offset: pageParam || params?.["offset"] },
      { signal, ...axiosOptions },
    );

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof growthRateList>>,
    TError,
    TData,
    Awaited<ReturnType<typeof growthRateList>>,
    QueryKey,
    GrowthRateListParams["offset"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GrowthRateListInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof growthRateList>>
>;
export type GrowthRateListInfiniteQueryError = AxiosError<unknown>;

export function useGrowthRateListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof growthRateList>>,
    GrowthRateListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params: undefined | GrowthRateListParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof growthRateList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof growthRateList>>,
        QueryKey,
        GrowthRateListParams["offset"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof growthRateList>>,
          TError,
          Awaited<ReturnType<typeof growthRateList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGrowthRateListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof growthRateList>>,
    GrowthRateListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: GrowthRateListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof growthRateList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof growthRateList>>,
        QueryKey,
        GrowthRateListParams["offset"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof growthRateList>>,
          TError,
          Awaited<ReturnType<typeof growthRateList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGrowthRateListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof growthRateList>>,
    GrowthRateListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: GrowthRateListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof growthRateList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof growthRateList>>,
        QueryKey,
        GrowthRateListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List growth rates
 */

export function useGrowthRateListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof growthRateList>>,
    GrowthRateListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: GrowthRateListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof growthRateList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof growthRateList>>,
        QueryKey,
        GrowthRateListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGrowthRateListInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGrowthRateListQueryOptions = <
  TData = Awaited<ReturnType<typeof growthRateList>>,
  TError = AxiosError<unknown>,
>(
  params?: GrowthRateListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof growthRateList>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGrowthRateListQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof growthRateList>>> = ({
    signal,
  }) => growthRateList(params, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof growthRateList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GrowthRateListQueryResult = NonNullable<
  Awaited<ReturnType<typeof growthRateList>>
>;
export type GrowthRateListQueryError = AxiosError<unknown>;

export function useGrowthRateList<
  TData = Awaited<ReturnType<typeof growthRateList>>,
  TError = AxiosError<unknown>,
>(
  params: undefined | GrowthRateListParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof growthRateList>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof growthRateList>>,
          TError,
          Awaited<ReturnType<typeof growthRateList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGrowthRateList<
  TData = Awaited<ReturnType<typeof growthRateList>>,
  TError = AxiosError<unknown>,
>(
  params?: GrowthRateListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof growthRateList>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof growthRateList>>,
          TError,
          Awaited<ReturnType<typeof growthRateList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGrowthRateList<
  TData = Awaited<ReturnType<typeof growthRateList>>,
  TError = AxiosError<unknown>,
>(
  params?: GrowthRateListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof growthRateList>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List growth rates
 */

export function useGrowthRateList<
  TData = Awaited<ReturnType<typeof growthRateList>>,
  TError = AxiosError<unknown>,
>(
  params?: GrowthRateListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof growthRateList>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGrowthRateListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Growth rates are the speed with which Pok√©mon gain levels through experience. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Experience) for greater detail.
 * @summary Get growth rate
 */
export const growthRateRetrieve = (
  id: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<GrowthRateDetail>> => {
  return axios.default.get(
    `https://pokeapi.co/api/v2/growth-rate/${id}`,
    options,
  );
};

export const getGrowthRateRetrieveQueryKey = (id: string) => {
  return [`https://pokeapi.co/api/v2/growth-rate/${id}`] as const;
};

export const getGrowthRateRetrieveInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof growthRateRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof growthRateRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGrowthRateRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof growthRateRetrieve>>
  > = ({ signal }) => growthRateRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof growthRateRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GrowthRateRetrieveInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof growthRateRetrieve>>
>;
export type GrowthRateRetrieveInfiniteQueryError = AxiosError<unknown>;

export function useGrowthRateRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof growthRateRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof growthRateRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof growthRateRetrieve>>,
          TError,
          Awaited<ReturnType<typeof growthRateRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGrowthRateRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof growthRateRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof growthRateRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof growthRateRetrieve>>,
          TError,
          Awaited<ReturnType<typeof growthRateRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGrowthRateRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof growthRateRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof growthRateRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get growth rate
 */

export function useGrowthRateRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof growthRateRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof growthRateRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGrowthRateRetrieveInfiniteQueryOptions(id, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGrowthRateRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof growthRateRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof growthRateRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGrowthRateRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof growthRateRetrieve>>
  > = ({ signal }) => growthRateRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof growthRateRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GrowthRateRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof growthRateRetrieve>>
>;
export type GrowthRateRetrieveQueryError = AxiosError<unknown>;

export function useGrowthRateRetrieve<
  TData = Awaited<ReturnType<typeof growthRateRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof growthRateRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof growthRateRetrieve>>,
          TError,
          Awaited<ReturnType<typeof growthRateRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGrowthRateRetrieve<
  TData = Awaited<ReturnType<typeof growthRateRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof growthRateRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof growthRateRetrieve>>,
          TError,
          Awaited<ReturnType<typeof growthRateRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGrowthRateRetrieve<
  TData = Awaited<ReturnType<typeof growthRateRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof growthRateRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get growth rate
 */

export function useGrowthRateRetrieve<
  TData = Awaited<ReturnType<typeof growthRateRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof growthRateRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGrowthRateRetrieveQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * An item is an object in the games which the player can pick up, keep in their bag, and use in some manner. They have various uses, including healing, powering up, helping catch Pok√©mon, or to access a new area.
 * @summary List items
 */
export const itemList = (
  params?: ItemListParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedItemSummaryList>> => {
  return axios.default.get(`https://pokeapi.co/api/v2/item`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getItemListQueryKey = (params?: ItemListParams) => {
  return [
    `https://pokeapi.co/api/v2/item`,
    ...(params ? [params] : []),
  ] as const;
};

export const getItemListInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof itemList>>,
    ItemListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: ItemListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof itemList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof itemList>>,
        QueryKey,
        ItemListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getItemListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof itemList>>,
    QueryKey,
    ItemListParams["offset"]
  > = ({ signal, pageParam }) =>
    itemList(
      { ...params, offset: pageParam || params?.["offset"] },
      { signal, ...axiosOptions },
    );

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof itemList>>,
    TError,
    TData,
    Awaited<ReturnType<typeof itemList>>,
    QueryKey,
    ItemListParams["offset"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ItemListInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof itemList>>
>;
export type ItemListInfiniteQueryError = AxiosError<unknown>;

export function useItemListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof itemList>>,
    ItemListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params: undefined | ItemListParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof itemList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof itemList>>,
        QueryKey,
        ItemListParams["offset"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof itemList>>,
          TError,
          Awaited<ReturnType<typeof itemList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useItemListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof itemList>>,
    ItemListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: ItemListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof itemList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof itemList>>,
        QueryKey,
        ItemListParams["offset"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof itemList>>,
          TError,
          Awaited<ReturnType<typeof itemList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useItemListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof itemList>>,
    ItemListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: ItemListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof itemList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof itemList>>,
        QueryKey,
        ItemListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List items
 */

export function useItemListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof itemList>>,
    ItemListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: ItemListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof itemList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof itemList>>,
        QueryKey,
        ItemListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getItemListInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getItemListQueryOptions = <
  TData = Awaited<ReturnType<typeof itemList>>,
  TError = AxiosError<unknown>,
>(
  params?: ItemListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof itemList>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getItemListQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof itemList>>> = ({
    signal,
  }) => itemList(params, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof itemList>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type ItemListQueryResult = NonNullable<
  Awaited<ReturnType<typeof itemList>>
>;
export type ItemListQueryError = AxiosError<unknown>;

export function useItemList<
  TData = Awaited<ReturnType<typeof itemList>>,
  TError = AxiosError<unknown>,
>(
  params: undefined | ItemListParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof itemList>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof itemList>>,
          TError,
          Awaited<ReturnType<typeof itemList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useItemList<
  TData = Awaited<ReturnType<typeof itemList>>,
  TError = AxiosError<unknown>,
>(
  params?: ItemListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof itemList>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof itemList>>,
          TError,
          Awaited<ReturnType<typeof itemList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useItemList<
  TData = Awaited<ReturnType<typeof itemList>>,
  TError = AxiosError<unknown>,
>(
  params?: ItemListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof itemList>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List items
 */

export function useItemList<
  TData = Awaited<ReturnType<typeof itemList>>,
  TError = AxiosError<unknown>,
>(
  params?: ItemListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof itemList>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getItemListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * An item is an object in the games which the player can pick up, keep in their bag, and use in some manner. They have various uses, including healing, powering up, helping catch Pok√©mon, or to access a new area.
 * @summary Get item
 */
export const itemRetrieve = (
  id: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<ItemDetail>> => {
  return axios.default.get(`https://pokeapi.co/api/v2/item/${id}`, options);
};

export const getItemRetrieveQueryKey = (id: string) => {
  return [`https://pokeapi.co/api/v2/item/${id}`] as const;
};

export const getItemRetrieveInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof itemRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof itemRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getItemRetrieveQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof itemRetrieve>>> = ({
    signal,
  }) => itemRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof itemRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ItemRetrieveInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof itemRetrieve>>
>;
export type ItemRetrieveInfiniteQueryError = AxiosError<unknown>;

export function useItemRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof itemRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof itemRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof itemRetrieve>>,
          TError,
          Awaited<ReturnType<typeof itemRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useItemRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof itemRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof itemRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof itemRetrieve>>,
          TError,
          Awaited<ReturnType<typeof itemRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useItemRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof itemRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof itemRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get item
 */

export function useItemRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof itemRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof itemRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getItemRetrieveInfiniteQueryOptions(id, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getItemRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof itemRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof itemRetrieve>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getItemRetrieveQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof itemRetrieve>>> = ({
    signal,
  }) => itemRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof itemRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ItemRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof itemRetrieve>>
>;
export type ItemRetrieveQueryError = AxiosError<unknown>;

export function useItemRetrieve<
  TData = Awaited<ReturnType<typeof itemRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof itemRetrieve>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof itemRetrieve>>,
          TError,
          Awaited<ReturnType<typeof itemRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useItemRetrieve<
  TData = Awaited<ReturnType<typeof itemRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof itemRetrieve>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof itemRetrieve>>,
          TError,
          Awaited<ReturnType<typeof itemRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useItemRetrieve<
  TData = Awaited<ReturnType<typeof itemRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof itemRetrieve>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get item
 */

export function useItemRetrieve<
  TData = Awaited<ReturnType<typeof itemRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof itemRetrieve>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getItemRetrieveQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Item categories determine where items will be placed in the players bag.
 * @summary List item categories
 */
export const itemCategoryList = (
  params?: ItemCategoryListParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedItemCategorySummaryList>> => {
  return axios.default.get(`https://pokeapi.co/api/v2/item-category`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getItemCategoryListQueryKey = (
  params?: ItemCategoryListParams,
) => {
  return [
    `https://pokeapi.co/api/v2/item-category`,
    ...(params ? [params] : []),
  ] as const;
};

export const getItemCategoryListInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof itemCategoryList>>,
    ItemCategoryListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: ItemCategoryListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof itemCategoryList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof itemCategoryList>>,
        QueryKey,
        ItemCategoryListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getItemCategoryListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof itemCategoryList>>,
    QueryKey,
    ItemCategoryListParams["offset"]
  > = ({ signal, pageParam }) =>
    itemCategoryList(
      { ...params, offset: pageParam || params?.["offset"] },
      { signal, ...axiosOptions },
    );

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof itemCategoryList>>,
    TError,
    TData,
    Awaited<ReturnType<typeof itemCategoryList>>,
    QueryKey,
    ItemCategoryListParams["offset"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ItemCategoryListInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof itemCategoryList>>
>;
export type ItemCategoryListInfiniteQueryError = AxiosError<unknown>;

export function useItemCategoryListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof itemCategoryList>>,
    ItemCategoryListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params: undefined | ItemCategoryListParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof itemCategoryList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof itemCategoryList>>,
        QueryKey,
        ItemCategoryListParams["offset"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof itemCategoryList>>,
          TError,
          Awaited<ReturnType<typeof itemCategoryList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useItemCategoryListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof itemCategoryList>>,
    ItemCategoryListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: ItemCategoryListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof itemCategoryList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof itemCategoryList>>,
        QueryKey,
        ItemCategoryListParams["offset"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof itemCategoryList>>,
          TError,
          Awaited<ReturnType<typeof itemCategoryList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useItemCategoryListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof itemCategoryList>>,
    ItemCategoryListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: ItemCategoryListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof itemCategoryList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof itemCategoryList>>,
        QueryKey,
        ItemCategoryListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List item categories
 */

export function useItemCategoryListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof itemCategoryList>>,
    ItemCategoryListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: ItemCategoryListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof itemCategoryList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof itemCategoryList>>,
        QueryKey,
        ItemCategoryListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getItemCategoryListInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getItemCategoryListQueryOptions = <
  TData = Awaited<ReturnType<typeof itemCategoryList>>,
  TError = AxiosError<unknown>,
>(
  params?: ItemCategoryListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof itemCategoryList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getItemCategoryListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof itemCategoryList>>
  > = ({ signal }) => itemCategoryList(params, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof itemCategoryList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ItemCategoryListQueryResult = NonNullable<
  Awaited<ReturnType<typeof itemCategoryList>>
>;
export type ItemCategoryListQueryError = AxiosError<unknown>;

export function useItemCategoryList<
  TData = Awaited<ReturnType<typeof itemCategoryList>>,
  TError = AxiosError<unknown>,
>(
  params: undefined | ItemCategoryListParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof itemCategoryList>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof itemCategoryList>>,
          TError,
          Awaited<ReturnType<typeof itemCategoryList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useItemCategoryList<
  TData = Awaited<ReturnType<typeof itemCategoryList>>,
  TError = AxiosError<unknown>,
>(
  params?: ItemCategoryListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof itemCategoryList>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof itemCategoryList>>,
          TError,
          Awaited<ReturnType<typeof itemCategoryList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useItemCategoryList<
  TData = Awaited<ReturnType<typeof itemCategoryList>>,
  TError = AxiosError<unknown>,
>(
  params?: ItemCategoryListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof itemCategoryList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List item categories
 */

export function useItemCategoryList<
  TData = Awaited<ReturnType<typeof itemCategoryList>>,
  TError = AxiosError<unknown>,
>(
  params?: ItemCategoryListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof itemCategoryList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getItemCategoryListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Item categories determine where items will be placed in the players bag.
 * @summary Get item category
 */
export const itemCategoryRetrieve = (
  id: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<ItemCategoryDetail>> => {
  return axios.default.get(
    `https://pokeapi.co/api/v2/item-category/${id}`,
    options,
  );
};

export const getItemCategoryRetrieveQueryKey = (id: string) => {
  return [`https://pokeapi.co/api/v2/item-category/${id}`] as const;
};

export const getItemCategoryRetrieveInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof itemCategoryRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof itemCategoryRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getItemCategoryRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof itemCategoryRetrieve>>
  > = ({ signal }) => itemCategoryRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof itemCategoryRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ItemCategoryRetrieveInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof itemCategoryRetrieve>>
>;
export type ItemCategoryRetrieveInfiniteQueryError = AxiosError<unknown>;

export function useItemCategoryRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof itemCategoryRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof itemCategoryRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof itemCategoryRetrieve>>,
          TError,
          Awaited<ReturnType<typeof itemCategoryRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useItemCategoryRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof itemCategoryRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof itemCategoryRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof itemCategoryRetrieve>>,
          TError,
          Awaited<ReturnType<typeof itemCategoryRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useItemCategoryRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof itemCategoryRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof itemCategoryRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get item category
 */

export function useItemCategoryRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof itemCategoryRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof itemCategoryRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getItemCategoryRetrieveInfiniteQueryOptions(id, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getItemCategoryRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof itemCategoryRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof itemCategoryRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getItemCategoryRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof itemCategoryRetrieve>>
  > = ({ signal }) => itemCategoryRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof itemCategoryRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ItemCategoryRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof itemCategoryRetrieve>>
>;
export type ItemCategoryRetrieveQueryError = AxiosError<unknown>;

export function useItemCategoryRetrieve<
  TData = Awaited<ReturnType<typeof itemCategoryRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof itemCategoryRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof itemCategoryRetrieve>>,
          TError,
          Awaited<ReturnType<typeof itemCategoryRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useItemCategoryRetrieve<
  TData = Awaited<ReturnType<typeof itemCategoryRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof itemCategoryRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof itemCategoryRetrieve>>,
          TError,
          Awaited<ReturnType<typeof itemCategoryRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useItemCategoryRetrieve<
  TData = Awaited<ReturnType<typeof itemCategoryRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof itemCategoryRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get item category
 */

export function useItemCategoryRetrieve<
  TData = Awaited<ReturnType<typeof itemCategoryRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof itemCategoryRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getItemCategoryRetrieveQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Item attributes define particular aspects of items, e.g."usable in battle" or "consumable".
 * @summary List item attributes
 */
export const itemAttributeList = (
  params?: ItemAttributeListParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedItemAttributeSummaryList>> => {
  return axios.default.get(`https://pokeapi.co/api/v2/item-attribute`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getItemAttributeListQueryKey = (
  params?: ItemAttributeListParams,
) => {
  return [
    `https://pokeapi.co/api/v2/item-attribute`,
    ...(params ? [params] : []),
  ] as const;
};

export const getItemAttributeListInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof itemAttributeList>>,
    ItemAttributeListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: ItemAttributeListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof itemAttributeList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof itemAttributeList>>,
        QueryKey,
        ItemAttributeListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getItemAttributeListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof itemAttributeList>>,
    QueryKey,
    ItemAttributeListParams["offset"]
  > = ({ signal, pageParam }) =>
    itemAttributeList(
      { ...params, offset: pageParam || params?.["offset"] },
      { signal, ...axiosOptions },
    );

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof itemAttributeList>>,
    TError,
    TData,
    Awaited<ReturnType<typeof itemAttributeList>>,
    QueryKey,
    ItemAttributeListParams["offset"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ItemAttributeListInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof itemAttributeList>>
>;
export type ItemAttributeListInfiniteQueryError = AxiosError<unknown>;

export function useItemAttributeListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof itemAttributeList>>,
    ItemAttributeListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params: undefined | ItemAttributeListParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof itemAttributeList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof itemAttributeList>>,
        QueryKey,
        ItemAttributeListParams["offset"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof itemAttributeList>>,
          TError,
          Awaited<ReturnType<typeof itemAttributeList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useItemAttributeListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof itemAttributeList>>,
    ItemAttributeListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: ItemAttributeListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof itemAttributeList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof itemAttributeList>>,
        QueryKey,
        ItemAttributeListParams["offset"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof itemAttributeList>>,
          TError,
          Awaited<ReturnType<typeof itemAttributeList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useItemAttributeListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof itemAttributeList>>,
    ItemAttributeListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: ItemAttributeListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof itemAttributeList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof itemAttributeList>>,
        QueryKey,
        ItemAttributeListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List item attributes
 */

export function useItemAttributeListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof itemAttributeList>>,
    ItemAttributeListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: ItemAttributeListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof itemAttributeList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof itemAttributeList>>,
        QueryKey,
        ItemAttributeListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getItemAttributeListInfiniteQueryOptions(
    params,
    options,
  );

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getItemAttributeListQueryOptions = <
  TData = Awaited<ReturnType<typeof itemAttributeList>>,
  TError = AxiosError<unknown>,
>(
  params?: ItemAttributeListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof itemAttributeList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getItemAttributeListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof itemAttributeList>>
  > = ({ signal }) => itemAttributeList(params, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof itemAttributeList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ItemAttributeListQueryResult = NonNullable<
  Awaited<ReturnType<typeof itemAttributeList>>
>;
export type ItemAttributeListQueryError = AxiosError<unknown>;

export function useItemAttributeList<
  TData = Awaited<ReturnType<typeof itemAttributeList>>,
  TError = AxiosError<unknown>,
>(
  params: undefined | ItemAttributeListParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof itemAttributeList>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof itemAttributeList>>,
          TError,
          Awaited<ReturnType<typeof itemAttributeList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useItemAttributeList<
  TData = Awaited<ReturnType<typeof itemAttributeList>>,
  TError = AxiosError<unknown>,
>(
  params?: ItemAttributeListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof itemAttributeList>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof itemAttributeList>>,
          TError,
          Awaited<ReturnType<typeof itemAttributeList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useItemAttributeList<
  TData = Awaited<ReturnType<typeof itemAttributeList>>,
  TError = AxiosError<unknown>,
>(
  params?: ItemAttributeListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof itemAttributeList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List item attributes
 */

export function useItemAttributeList<
  TData = Awaited<ReturnType<typeof itemAttributeList>>,
  TError = AxiosError<unknown>,
>(
  params?: ItemAttributeListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof itemAttributeList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getItemAttributeListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Item attributes define particular aspects of items, e.g."usable in battle" or "consumable".
 * @summary Get item attribute
 */
export const itemAttributeRetrieve = (
  id: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<ItemAttributeDetail>> => {
  return axios.default.get(
    `https://pokeapi.co/api/v2/item-attribute/${id}`,
    options,
  );
};

export const getItemAttributeRetrieveQueryKey = (id: string) => {
  return [`https://pokeapi.co/api/v2/item-attribute/${id}`] as const;
};

export const getItemAttributeRetrieveInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof itemAttributeRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof itemAttributeRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getItemAttributeRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof itemAttributeRetrieve>>
  > = ({ signal }) => itemAttributeRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof itemAttributeRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ItemAttributeRetrieveInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof itemAttributeRetrieve>>
>;
export type ItemAttributeRetrieveInfiniteQueryError = AxiosError<unknown>;

export function useItemAttributeRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof itemAttributeRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof itemAttributeRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof itemAttributeRetrieve>>,
          TError,
          Awaited<ReturnType<typeof itemAttributeRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useItemAttributeRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof itemAttributeRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof itemAttributeRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof itemAttributeRetrieve>>,
          TError,
          Awaited<ReturnType<typeof itemAttributeRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useItemAttributeRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof itemAttributeRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof itemAttributeRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get item attribute
 */

export function useItemAttributeRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof itemAttributeRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof itemAttributeRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getItemAttributeRetrieveInfiniteQueryOptions(
    id,
    options,
  );

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getItemAttributeRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof itemAttributeRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof itemAttributeRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getItemAttributeRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof itemAttributeRetrieve>>
  > = ({ signal }) => itemAttributeRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof itemAttributeRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ItemAttributeRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof itemAttributeRetrieve>>
>;
export type ItemAttributeRetrieveQueryError = AxiosError<unknown>;

export function useItemAttributeRetrieve<
  TData = Awaited<ReturnType<typeof itemAttributeRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof itemAttributeRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof itemAttributeRetrieve>>,
          TError,
          Awaited<ReturnType<typeof itemAttributeRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useItemAttributeRetrieve<
  TData = Awaited<ReturnType<typeof itemAttributeRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof itemAttributeRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof itemAttributeRetrieve>>,
          TError,
          Awaited<ReturnType<typeof itemAttributeRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useItemAttributeRetrieve<
  TData = Awaited<ReturnType<typeof itemAttributeRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof itemAttributeRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get item attribute
 */

export function useItemAttributeRetrieve<
  TData = Awaited<ReturnType<typeof itemAttributeRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof itemAttributeRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getItemAttributeRetrieveQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * The various effects of the move"Fling" when used with different items.
 * @summary List item fling effects
 */
export const itemFlingEffectList = (
  params?: ItemFlingEffectListParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedItemFlingEffectSummaryList>> => {
  return axios.default.get(`https://pokeapi.co/api/v2/item-fling-effect`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getItemFlingEffectListQueryKey = (
  params?: ItemFlingEffectListParams,
) => {
  return [
    `https://pokeapi.co/api/v2/item-fling-effect`,
    ...(params ? [params] : []),
  ] as const;
};

export const getItemFlingEffectListInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof itemFlingEffectList>>,
    ItemFlingEffectListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: ItemFlingEffectListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof itemFlingEffectList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof itemFlingEffectList>>,
        QueryKey,
        ItemFlingEffectListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getItemFlingEffectListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof itemFlingEffectList>>,
    QueryKey,
    ItemFlingEffectListParams["offset"]
  > = ({ signal, pageParam }) =>
    itemFlingEffectList(
      { ...params, offset: pageParam || params?.["offset"] },
      { signal, ...axiosOptions },
    );

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof itemFlingEffectList>>,
    TError,
    TData,
    Awaited<ReturnType<typeof itemFlingEffectList>>,
    QueryKey,
    ItemFlingEffectListParams["offset"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ItemFlingEffectListInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof itemFlingEffectList>>
>;
export type ItemFlingEffectListInfiniteQueryError = AxiosError<unknown>;

export function useItemFlingEffectListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof itemFlingEffectList>>,
    ItemFlingEffectListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params: undefined | ItemFlingEffectListParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof itemFlingEffectList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof itemFlingEffectList>>,
        QueryKey,
        ItemFlingEffectListParams["offset"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof itemFlingEffectList>>,
          TError,
          Awaited<ReturnType<typeof itemFlingEffectList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useItemFlingEffectListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof itemFlingEffectList>>,
    ItemFlingEffectListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: ItemFlingEffectListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof itemFlingEffectList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof itemFlingEffectList>>,
        QueryKey,
        ItemFlingEffectListParams["offset"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof itemFlingEffectList>>,
          TError,
          Awaited<ReturnType<typeof itemFlingEffectList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useItemFlingEffectListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof itemFlingEffectList>>,
    ItemFlingEffectListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: ItemFlingEffectListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof itemFlingEffectList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof itemFlingEffectList>>,
        QueryKey,
        ItemFlingEffectListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List item fling effects
 */

export function useItemFlingEffectListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof itemFlingEffectList>>,
    ItemFlingEffectListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: ItemFlingEffectListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof itemFlingEffectList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof itemFlingEffectList>>,
        QueryKey,
        ItemFlingEffectListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getItemFlingEffectListInfiniteQueryOptions(
    params,
    options,
  );

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getItemFlingEffectListQueryOptions = <
  TData = Awaited<ReturnType<typeof itemFlingEffectList>>,
  TError = AxiosError<unknown>,
>(
  params?: ItemFlingEffectListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof itemFlingEffectList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getItemFlingEffectListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof itemFlingEffectList>>
  > = ({ signal }) => itemFlingEffectList(params, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof itemFlingEffectList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ItemFlingEffectListQueryResult = NonNullable<
  Awaited<ReturnType<typeof itemFlingEffectList>>
>;
export type ItemFlingEffectListQueryError = AxiosError<unknown>;

export function useItemFlingEffectList<
  TData = Awaited<ReturnType<typeof itemFlingEffectList>>,
  TError = AxiosError<unknown>,
>(
  params: undefined | ItemFlingEffectListParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof itemFlingEffectList>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof itemFlingEffectList>>,
          TError,
          Awaited<ReturnType<typeof itemFlingEffectList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useItemFlingEffectList<
  TData = Awaited<ReturnType<typeof itemFlingEffectList>>,
  TError = AxiosError<unknown>,
>(
  params?: ItemFlingEffectListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof itemFlingEffectList>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof itemFlingEffectList>>,
          TError,
          Awaited<ReturnType<typeof itemFlingEffectList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useItemFlingEffectList<
  TData = Awaited<ReturnType<typeof itemFlingEffectList>>,
  TError = AxiosError<unknown>,
>(
  params?: ItemFlingEffectListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof itemFlingEffectList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List item fling effects
 */

export function useItemFlingEffectList<
  TData = Awaited<ReturnType<typeof itemFlingEffectList>>,
  TError = AxiosError<unknown>,
>(
  params?: ItemFlingEffectListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof itemFlingEffectList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getItemFlingEffectListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * The various effects of the move"Fling" when used with different items.
 * @summary Get item fling effect
 */
export const itemFlingEffectRetrieve = (
  id: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<ItemFlingEffectDetail>> => {
  return axios.default.get(
    `https://pokeapi.co/api/v2/item-fling-effect/${id}`,
    options,
  );
};

export const getItemFlingEffectRetrieveQueryKey = (id: string) => {
  return [`https://pokeapi.co/api/v2/item-fling-effect/${id}`] as const;
};

export const getItemFlingEffectRetrieveInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof itemFlingEffectRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof itemFlingEffectRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getItemFlingEffectRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof itemFlingEffectRetrieve>>
  > = ({ signal }) => itemFlingEffectRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof itemFlingEffectRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ItemFlingEffectRetrieveInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof itemFlingEffectRetrieve>>
>;
export type ItemFlingEffectRetrieveInfiniteQueryError = AxiosError<unknown>;

export function useItemFlingEffectRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof itemFlingEffectRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof itemFlingEffectRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof itemFlingEffectRetrieve>>,
          TError,
          Awaited<ReturnType<typeof itemFlingEffectRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useItemFlingEffectRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof itemFlingEffectRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof itemFlingEffectRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof itemFlingEffectRetrieve>>,
          TError,
          Awaited<ReturnType<typeof itemFlingEffectRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useItemFlingEffectRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof itemFlingEffectRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof itemFlingEffectRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get item fling effect
 */

export function useItemFlingEffectRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof itemFlingEffectRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof itemFlingEffectRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getItemFlingEffectRetrieveInfiniteQueryOptions(
    id,
    options,
  );

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getItemFlingEffectRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof itemFlingEffectRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof itemFlingEffectRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getItemFlingEffectRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof itemFlingEffectRetrieve>>
  > = ({ signal }) => itemFlingEffectRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof itemFlingEffectRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ItemFlingEffectRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof itemFlingEffectRetrieve>>
>;
export type ItemFlingEffectRetrieveQueryError = AxiosError<unknown>;

export function useItemFlingEffectRetrieve<
  TData = Awaited<ReturnType<typeof itemFlingEffectRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof itemFlingEffectRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof itemFlingEffectRetrieve>>,
          TError,
          Awaited<ReturnType<typeof itemFlingEffectRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useItemFlingEffectRetrieve<
  TData = Awaited<ReturnType<typeof itemFlingEffectRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof itemFlingEffectRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof itemFlingEffectRetrieve>>,
          TError,
          Awaited<ReturnType<typeof itemFlingEffectRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useItemFlingEffectRetrieve<
  TData = Awaited<ReturnType<typeof itemFlingEffectRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof itemFlingEffectRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get item fling effect
 */

export function useItemFlingEffectRetrieve<
  TData = Awaited<ReturnType<typeof itemFlingEffectRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof itemFlingEffectRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getItemFlingEffectRetrieveQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Pockets within the players bag used for storing items by category.
 * @summary List item pockets
 */
export const itemPocketList = (
  params?: ItemPocketListParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedItemPocketSummaryList>> => {
  return axios.default.get(`https://pokeapi.co/api/v2/item-pocket`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getItemPocketListQueryKey = (params?: ItemPocketListParams) => {
  return [
    `https://pokeapi.co/api/v2/item-pocket`,
    ...(params ? [params] : []),
  ] as const;
};

export const getItemPocketListInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof itemPocketList>>,
    ItemPocketListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: ItemPocketListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof itemPocketList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof itemPocketList>>,
        QueryKey,
        ItemPocketListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getItemPocketListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof itemPocketList>>,
    QueryKey,
    ItemPocketListParams["offset"]
  > = ({ signal, pageParam }) =>
    itemPocketList(
      { ...params, offset: pageParam || params?.["offset"] },
      { signal, ...axiosOptions },
    );

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof itemPocketList>>,
    TError,
    TData,
    Awaited<ReturnType<typeof itemPocketList>>,
    QueryKey,
    ItemPocketListParams["offset"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ItemPocketListInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof itemPocketList>>
>;
export type ItemPocketListInfiniteQueryError = AxiosError<unknown>;

export function useItemPocketListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof itemPocketList>>,
    ItemPocketListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params: undefined | ItemPocketListParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof itemPocketList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof itemPocketList>>,
        QueryKey,
        ItemPocketListParams["offset"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof itemPocketList>>,
          TError,
          Awaited<ReturnType<typeof itemPocketList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useItemPocketListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof itemPocketList>>,
    ItemPocketListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: ItemPocketListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof itemPocketList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof itemPocketList>>,
        QueryKey,
        ItemPocketListParams["offset"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof itemPocketList>>,
          TError,
          Awaited<ReturnType<typeof itemPocketList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useItemPocketListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof itemPocketList>>,
    ItemPocketListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: ItemPocketListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof itemPocketList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof itemPocketList>>,
        QueryKey,
        ItemPocketListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List item pockets
 */

export function useItemPocketListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof itemPocketList>>,
    ItemPocketListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: ItemPocketListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof itemPocketList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof itemPocketList>>,
        QueryKey,
        ItemPocketListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getItemPocketListInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getItemPocketListQueryOptions = <
  TData = Awaited<ReturnType<typeof itemPocketList>>,
  TError = AxiosError<unknown>,
>(
  params?: ItemPocketListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof itemPocketList>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getItemPocketListQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof itemPocketList>>> = ({
    signal,
  }) => itemPocketList(params, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof itemPocketList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ItemPocketListQueryResult = NonNullable<
  Awaited<ReturnType<typeof itemPocketList>>
>;
export type ItemPocketListQueryError = AxiosError<unknown>;

export function useItemPocketList<
  TData = Awaited<ReturnType<typeof itemPocketList>>,
  TError = AxiosError<unknown>,
>(
  params: undefined | ItemPocketListParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof itemPocketList>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof itemPocketList>>,
          TError,
          Awaited<ReturnType<typeof itemPocketList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useItemPocketList<
  TData = Awaited<ReturnType<typeof itemPocketList>>,
  TError = AxiosError<unknown>,
>(
  params?: ItemPocketListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof itemPocketList>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof itemPocketList>>,
          TError,
          Awaited<ReturnType<typeof itemPocketList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useItemPocketList<
  TData = Awaited<ReturnType<typeof itemPocketList>>,
  TError = AxiosError<unknown>,
>(
  params?: ItemPocketListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof itemPocketList>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List item pockets
 */

export function useItemPocketList<
  TData = Awaited<ReturnType<typeof itemPocketList>>,
  TError = AxiosError<unknown>,
>(
  params?: ItemPocketListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof itemPocketList>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getItemPocketListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Pockets within the players bag used for storing items by category.
 * @summary Get item pocket
 */
export const itemPocketRetrieve = (
  id: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<ItemPocketDetail>> => {
  return axios.default.get(
    `https://pokeapi.co/api/v2/item-pocket/${id}`,
    options,
  );
};

export const getItemPocketRetrieveQueryKey = (id: string) => {
  return [`https://pokeapi.co/api/v2/item-pocket/${id}`] as const;
};

export const getItemPocketRetrieveInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof itemPocketRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof itemPocketRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getItemPocketRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof itemPocketRetrieve>>
  > = ({ signal }) => itemPocketRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof itemPocketRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ItemPocketRetrieveInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof itemPocketRetrieve>>
>;
export type ItemPocketRetrieveInfiniteQueryError = AxiosError<unknown>;

export function useItemPocketRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof itemPocketRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof itemPocketRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof itemPocketRetrieve>>,
          TError,
          Awaited<ReturnType<typeof itemPocketRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useItemPocketRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof itemPocketRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof itemPocketRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof itemPocketRetrieve>>,
          TError,
          Awaited<ReturnType<typeof itemPocketRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useItemPocketRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof itemPocketRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof itemPocketRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get item pocket
 */

export function useItemPocketRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof itemPocketRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof itemPocketRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getItemPocketRetrieveInfiniteQueryOptions(id, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getItemPocketRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof itemPocketRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof itemPocketRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getItemPocketRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof itemPocketRetrieve>>
  > = ({ signal }) => itemPocketRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof itemPocketRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ItemPocketRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof itemPocketRetrieve>>
>;
export type ItemPocketRetrieveQueryError = AxiosError<unknown>;

export function useItemPocketRetrieve<
  TData = Awaited<ReturnType<typeof itemPocketRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof itemPocketRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof itemPocketRetrieve>>,
          TError,
          Awaited<ReturnType<typeof itemPocketRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useItemPocketRetrieve<
  TData = Awaited<ReturnType<typeof itemPocketRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof itemPocketRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof itemPocketRetrieve>>,
          TError,
          Awaited<ReturnType<typeof itemPocketRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useItemPocketRetrieve<
  TData = Awaited<ReturnType<typeof itemPocketRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof itemPocketRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get item pocket
 */

export function useItemPocketRetrieve<
  TData = Awaited<ReturnType<typeof itemPocketRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof itemPocketRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getItemPocketRetrieveQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Languages for translations of API resource information.
 * @summary List languages
 */
export const languageList = (
  params?: LanguageListParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedLanguageSummaryList>> => {
  return axios.default.get(`https://pokeapi.co/api/v2/language`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getLanguageListQueryKey = (params?: LanguageListParams) => {
  return [
    `https://pokeapi.co/api/v2/language`,
    ...(params ? [params] : []),
  ] as const;
};

export const getLanguageListInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof languageList>>,
    LanguageListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: LanguageListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof languageList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof languageList>>,
        QueryKey,
        LanguageListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLanguageListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof languageList>>,
    QueryKey,
    LanguageListParams["offset"]
  > = ({ signal, pageParam }) =>
    languageList(
      { ...params, offset: pageParam || params?.["offset"] },
      { signal, ...axiosOptions },
    );

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof languageList>>,
    TError,
    TData,
    Awaited<ReturnType<typeof languageList>>,
    QueryKey,
    LanguageListParams["offset"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LanguageListInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof languageList>>
>;
export type LanguageListInfiniteQueryError = AxiosError<unknown>;

export function useLanguageListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof languageList>>,
    LanguageListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params: undefined | LanguageListParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof languageList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof languageList>>,
        QueryKey,
        LanguageListParams["offset"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof languageList>>,
          TError,
          Awaited<ReturnType<typeof languageList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLanguageListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof languageList>>,
    LanguageListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: LanguageListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof languageList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof languageList>>,
        QueryKey,
        LanguageListParams["offset"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof languageList>>,
          TError,
          Awaited<ReturnType<typeof languageList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLanguageListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof languageList>>,
    LanguageListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: LanguageListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof languageList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof languageList>>,
        QueryKey,
        LanguageListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List languages
 */

export function useLanguageListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof languageList>>,
    LanguageListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: LanguageListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof languageList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof languageList>>,
        QueryKey,
        LanguageListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLanguageListInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLanguageListQueryOptions = <
  TData = Awaited<ReturnType<typeof languageList>>,
  TError = AxiosError<unknown>,
>(
  params?: LanguageListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof languageList>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLanguageListQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof languageList>>> = ({
    signal,
  }) => languageList(params, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof languageList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LanguageListQueryResult = NonNullable<
  Awaited<ReturnType<typeof languageList>>
>;
export type LanguageListQueryError = AxiosError<unknown>;

export function useLanguageList<
  TData = Awaited<ReturnType<typeof languageList>>,
  TError = AxiosError<unknown>,
>(
  params: undefined | LanguageListParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof languageList>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof languageList>>,
          TError,
          Awaited<ReturnType<typeof languageList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLanguageList<
  TData = Awaited<ReturnType<typeof languageList>>,
  TError = AxiosError<unknown>,
>(
  params?: LanguageListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof languageList>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof languageList>>,
          TError,
          Awaited<ReturnType<typeof languageList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLanguageList<
  TData = Awaited<ReturnType<typeof languageList>>,
  TError = AxiosError<unknown>,
>(
  params?: LanguageListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof languageList>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List languages
 */

export function useLanguageList<
  TData = Awaited<ReturnType<typeof languageList>>,
  TError = AxiosError<unknown>,
>(
  params?: LanguageListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof languageList>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLanguageListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Languages for translations of API resource information.
 * @summary Get language
 */
export const languageRetrieve = (
  id: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<LanguageDetail>> => {
  return axios.default.get(`https://pokeapi.co/api/v2/language/${id}`, options);
};

export const getLanguageRetrieveQueryKey = (id: string) => {
  return [`https://pokeapi.co/api/v2/language/${id}`] as const;
};

export const getLanguageRetrieveInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof languageRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof languageRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLanguageRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof languageRetrieve>>
  > = ({ signal }) => languageRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof languageRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LanguageRetrieveInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof languageRetrieve>>
>;
export type LanguageRetrieveInfiniteQueryError = AxiosError<unknown>;

export function useLanguageRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof languageRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof languageRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof languageRetrieve>>,
          TError,
          Awaited<ReturnType<typeof languageRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLanguageRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof languageRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof languageRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof languageRetrieve>>,
          TError,
          Awaited<ReturnType<typeof languageRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLanguageRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof languageRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof languageRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get language
 */

export function useLanguageRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof languageRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof languageRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLanguageRetrieveInfiniteQueryOptions(id, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLanguageRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof languageRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof languageRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLanguageRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof languageRetrieve>>
  > = ({ signal }) => languageRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof languageRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LanguageRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof languageRetrieve>>
>;
export type LanguageRetrieveQueryError = AxiosError<unknown>;

export function useLanguageRetrieve<
  TData = Awaited<ReturnType<typeof languageRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof languageRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof languageRetrieve>>,
          TError,
          Awaited<ReturnType<typeof languageRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLanguageRetrieve<
  TData = Awaited<ReturnType<typeof languageRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof languageRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof languageRetrieve>>,
          TError,
          Awaited<ReturnType<typeof languageRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLanguageRetrieve<
  TData = Awaited<ReturnType<typeof languageRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof languageRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get language
 */

export function useLanguageRetrieve<
  TData = Awaited<ReturnType<typeof languageRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof languageRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLanguageRetrieveQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Locations that can be visited within the games. Locations make up sizable portions of regions, like cities or routes.
 * @summary List locations
 */
export const locationList = (
  params?: LocationListParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedLocationSummaryList>> => {
  return axios.default.get(`https://pokeapi.co/api/v2/location`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getLocationListQueryKey = (params?: LocationListParams) => {
  return [
    `https://pokeapi.co/api/v2/location`,
    ...(params ? [params] : []),
  ] as const;
};

export const getLocationListInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof locationList>>,
    LocationListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: LocationListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof locationList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof locationList>>,
        QueryKey,
        LocationListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLocationListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof locationList>>,
    QueryKey,
    LocationListParams["offset"]
  > = ({ signal, pageParam }) =>
    locationList(
      { ...params, offset: pageParam || params?.["offset"] },
      { signal, ...axiosOptions },
    );

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof locationList>>,
    TError,
    TData,
    Awaited<ReturnType<typeof locationList>>,
    QueryKey,
    LocationListParams["offset"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LocationListInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof locationList>>
>;
export type LocationListInfiniteQueryError = AxiosError<unknown>;

export function useLocationListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof locationList>>,
    LocationListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params: undefined | LocationListParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof locationList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof locationList>>,
        QueryKey,
        LocationListParams["offset"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof locationList>>,
          TError,
          Awaited<ReturnType<typeof locationList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLocationListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof locationList>>,
    LocationListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: LocationListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof locationList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof locationList>>,
        QueryKey,
        LocationListParams["offset"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof locationList>>,
          TError,
          Awaited<ReturnType<typeof locationList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLocationListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof locationList>>,
    LocationListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: LocationListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof locationList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof locationList>>,
        QueryKey,
        LocationListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List locations
 */

export function useLocationListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof locationList>>,
    LocationListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: LocationListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof locationList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof locationList>>,
        QueryKey,
        LocationListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLocationListInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLocationListQueryOptions = <
  TData = Awaited<ReturnType<typeof locationList>>,
  TError = AxiosError<unknown>,
>(
  params?: LocationListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof locationList>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLocationListQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof locationList>>> = ({
    signal,
  }) => locationList(params, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof locationList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LocationListQueryResult = NonNullable<
  Awaited<ReturnType<typeof locationList>>
>;
export type LocationListQueryError = AxiosError<unknown>;

export function useLocationList<
  TData = Awaited<ReturnType<typeof locationList>>,
  TError = AxiosError<unknown>,
>(
  params: undefined | LocationListParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof locationList>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof locationList>>,
          TError,
          Awaited<ReturnType<typeof locationList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLocationList<
  TData = Awaited<ReturnType<typeof locationList>>,
  TError = AxiosError<unknown>,
>(
  params?: LocationListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof locationList>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof locationList>>,
          TError,
          Awaited<ReturnType<typeof locationList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLocationList<
  TData = Awaited<ReturnType<typeof locationList>>,
  TError = AxiosError<unknown>,
>(
  params?: LocationListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof locationList>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List locations
 */

export function useLocationList<
  TData = Awaited<ReturnType<typeof locationList>>,
  TError = AxiosError<unknown>,
>(
  params?: LocationListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof locationList>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLocationListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Locations that can be visited within the games. Locations make up sizable portions of regions, like cities or routes.
 * @summary Get location
 */
export const locationRetrieve = (
  id: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<LocationDetail>> => {
  return axios.default.get(`https://pokeapi.co/api/v2/location/${id}`, options);
};

export const getLocationRetrieveQueryKey = (id: string) => {
  return [`https://pokeapi.co/api/v2/location/${id}`] as const;
};

export const getLocationRetrieveInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof locationRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof locationRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLocationRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof locationRetrieve>>
  > = ({ signal }) => locationRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof locationRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LocationRetrieveInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof locationRetrieve>>
>;
export type LocationRetrieveInfiniteQueryError = AxiosError<unknown>;

export function useLocationRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof locationRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof locationRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof locationRetrieve>>,
          TError,
          Awaited<ReturnType<typeof locationRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLocationRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof locationRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof locationRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof locationRetrieve>>,
          TError,
          Awaited<ReturnType<typeof locationRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLocationRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof locationRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof locationRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get location
 */

export function useLocationRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof locationRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof locationRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLocationRetrieveInfiniteQueryOptions(id, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLocationRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof locationRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof locationRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLocationRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof locationRetrieve>>
  > = ({ signal }) => locationRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof locationRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LocationRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof locationRetrieve>>
>;
export type LocationRetrieveQueryError = AxiosError<unknown>;

export function useLocationRetrieve<
  TData = Awaited<ReturnType<typeof locationRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof locationRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof locationRetrieve>>,
          TError,
          Awaited<ReturnType<typeof locationRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLocationRetrieve<
  TData = Awaited<ReturnType<typeof locationRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof locationRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof locationRetrieve>>,
          TError,
          Awaited<ReturnType<typeof locationRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLocationRetrieve<
  TData = Awaited<ReturnType<typeof locationRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof locationRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get location
 */

export function useLocationRetrieve<
  TData = Awaited<ReturnType<typeof locationRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof locationRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLocationRetrieveQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Location areas are sections of areas, such as floors in a building or cave. Each area has its own set of possible Pok√©mon encounters.
 * @summary List location areas
 */
export const locationAreaList = (
  params?: LocationAreaListParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedLocationAreaSummaryList>> => {
  return axios.default.get(`https://pokeapi.co/api/v2/location-area`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getLocationAreaListQueryKey = (
  params?: LocationAreaListParams,
) => {
  return [
    `https://pokeapi.co/api/v2/location-area`,
    ...(params ? [params] : []),
  ] as const;
};

export const getLocationAreaListInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof locationAreaList>>,
    LocationAreaListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: LocationAreaListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof locationAreaList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof locationAreaList>>,
        QueryKey,
        LocationAreaListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getLocationAreaListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof locationAreaList>>,
    QueryKey,
    LocationAreaListParams["offset"]
  > = ({ signal, pageParam }) =>
    locationAreaList(
      { ...params, offset: pageParam || params?.["offset"] },
      { signal, ...axiosOptions },
    );

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof locationAreaList>>,
    TError,
    TData,
    Awaited<ReturnType<typeof locationAreaList>>,
    QueryKey,
    LocationAreaListParams["offset"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LocationAreaListInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof locationAreaList>>
>;
export type LocationAreaListInfiniteQueryError = AxiosError<unknown>;

export function useLocationAreaListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof locationAreaList>>,
    LocationAreaListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params: undefined | LocationAreaListParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof locationAreaList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof locationAreaList>>,
        QueryKey,
        LocationAreaListParams["offset"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof locationAreaList>>,
          TError,
          Awaited<ReturnType<typeof locationAreaList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLocationAreaListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof locationAreaList>>,
    LocationAreaListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: LocationAreaListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof locationAreaList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof locationAreaList>>,
        QueryKey,
        LocationAreaListParams["offset"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof locationAreaList>>,
          TError,
          Awaited<ReturnType<typeof locationAreaList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLocationAreaListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof locationAreaList>>,
    LocationAreaListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: LocationAreaListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof locationAreaList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof locationAreaList>>,
        QueryKey,
        LocationAreaListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List location areas
 */

export function useLocationAreaListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof locationAreaList>>,
    LocationAreaListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: LocationAreaListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof locationAreaList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof locationAreaList>>,
        QueryKey,
        LocationAreaListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLocationAreaListInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLocationAreaListQueryOptions = <
  TData = Awaited<ReturnType<typeof locationAreaList>>,
  TError = AxiosError<unknown>,
>(
  params?: LocationAreaListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof locationAreaList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getLocationAreaListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof locationAreaList>>
  > = ({ signal }) => locationAreaList(params, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof locationAreaList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LocationAreaListQueryResult = NonNullable<
  Awaited<ReturnType<typeof locationAreaList>>
>;
export type LocationAreaListQueryError = AxiosError<unknown>;

export function useLocationAreaList<
  TData = Awaited<ReturnType<typeof locationAreaList>>,
  TError = AxiosError<unknown>,
>(
  params: undefined | LocationAreaListParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof locationAreaList>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof locationAreaList>>,
          TError,
          Awaited<ReturnType<typeof locationAreaList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLocationAreaList<
  TData = Awaited<ReturnType<typeof locationAreaList>>,
  TError = AxiosError<unknown>,
>(
  params?: LocationAreaListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof locationAreaList>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof locationAreaList>>,
          TError,
          Awaited<ReturnType<typeof locationAreaList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLocationAreaList<
  TData = Awaited<ReturnType<typeof locationAreaList>>,
  TError = AxiosError<unknown>,
>(
  params?: LocationAreaListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof locationAreaList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List location areas
 */

export function useLocationAreaList<
  TData = Awaited<ReturnType<typeof locationAreaList>>,
  TError = AxiosError<unknown>,
>(
  params?: LocationAreaListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof locationAreaList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLocationAreaListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Location areas are sections of areas, such as floors in a building or cave. Each area has its own set of possible Pok√©mon encounters.
 * @summary Get location area
 */
export const locationAreaRetrieve = (
  id: number,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<LocationAreaDetail>> => {
  return axios.default.get(
    `https://pokeapi.co/api/v2/location-area/${id}`,
    options,
  );
};

export const getLocationAreaRetrieveQueryKey = (id: number) => {
  return [`https://pokeapi.co/api/v2/location-area/${id}`] as const;
};

export const getLocationAreaRetrieveInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof locationAreaRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: number,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof locationAreaRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getLocationAreaRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof locationAreaRetrieve>>
  > = ({ signal }) => locationAreaRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof locationAreaRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LocationAreaRetrieveInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof locationAreaRetrieve>>
>;
export type LocationAreaRetrieveInfiniteQueryError = AxiosError<unknown>;

export function useLocationAreaRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof locationAreaRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: number,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof locationAreaRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof locationAreaRetrieve>>,
          TError,
          Awaited<ReturnType<typeof locationAreaRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLocationAreaRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof locationAreaRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: number,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof locationAreaRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof locationAreaRetrieve>>,
          TError,
          Awaited<ReturnType<typeof locationAreaRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLocationAreaRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof locationAreaRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: number,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof locationAreaRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get location area
 */

export function useLocationAreaRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof locationAreaRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: number,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof locationAreaRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLocationAreaRetrieveInfiniteQueryOptions(id, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLocationAreaRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof locationAreaRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof locationAreaRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getLocationAreaRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof locationAreaRetrieve>>
  > = ({ signal }) => locationAreaRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof locationAreaRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LocationAreaRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof locationAreaRetrieve>>
>;
export type LocationAreaRetrieveQueryError = AxiosError<unknown>;

export function useLocationAreaRetrieve<
  TData = Awaited<ReturnType<typeof locationAreaRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: number,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof locationAreaRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof locationAreaRetrieve>>,
          TError,
          Awaited<ReturnType<typeof locationAreaRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLocationAreaRetrieve<
  TData = Awaited<ReturnType<typeof locationAreaRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof locationAreaRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof locationAreaRetrieve>>,
          TError,
          Awaited<ReturnType<typeof locationAreaRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLocationAreaRetrieve<
  TData = Awaited<ReturnType<typeof locationAreaRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof locationAreaRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get location area
 */

export function useLocationAreaRetrieve<
  TData = Awaited<ReturnType<typeof locationAreaRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof locationAreaRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLocationAreaRetrieveQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Machines are the representation of items that teach moves to Pok√©mon. They vary from version to version, so it is not certain that one specific TM or HM corresponds to a single Machine.
 * @summary List machines
 */
export const machineList = (
  params?: MachineListParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedMachineSummaryList>> => {
  return axios.default.get(`https://pokeapi.co/api/v2/machine`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getMachineListQueryKey = (params?: MachineListParams) => {
  return [
    `https://pokeapi.co/api/v2/machine`,
    ...(params ? [params] : []),
  ] as const;
};

export const getMachineListInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof machineList>>,
    MachineListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: MachineListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof machineList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof machineList>>,
        QueryKey,
        MachineListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getMachineListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof machineList>>,
    QueryKey,
    MachineListParams["offset"]
  > = ({ signal, pageParam }) =>
    machineList(
      { ...params, offset: pageParam || params?.["offset"] },
      { signal, ...axiosOptions },
    );

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof machineList>>,
    TError,
    TData,
    Awaited<ReturnType<typeof machineList>>,
    QueryKey,
    MachineListParams["offset"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type MachineListInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof machineList>>
>;
export type MachineListInfiniteQueryError = AxiosError<unknown>;

export function useMachineListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof machineList>>,
    MachineListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params: undefined | MachineListParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof machineList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof machineList>>,
        QueryKey,
        MachineListParams["offset"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof machineList>>,
          TError,
          Awaited<ReturnType<typeof machineList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMachineListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof machineList>>,
    MachineListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: MachineListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof machineList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof machineList>>,
        QueryKey,
        MachineListParams["offset"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof machineList>>,
          TError,
          Awaited<ReturnType<typeof machineList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMachineListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof machineList>>,
    MachineListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: MachineListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof machineList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof machineList>>,
        QueryKey,
        MachineListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List machines
 */

export function useMachineListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof machineList>>,
    MachineListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: MachineListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof machineList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof machineList>>,
        QueryKey,
        MachineListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getMachineListInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getMachineListQueryOptions = <
  TData = Awaited<ReturnType<typeof machineList>>,
  TError = AxiosError<unknown>,
>(
  params?: MachineListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof machineList>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getMachineListQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof machineList>>> = ({
    signal,
  }) => machineList(params, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof machineList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type MachineListQueryResult = NonNullable<
  Awaited<ReturnType<typeof machineList>>
>;
export type MachineListQueryError = AxiosError<unknown>;

export function useMachineList<
  TData = Awaited<ReturnType<typeof machineList>>,
  TError = AxiosError<unknown>,
>(
  params: undefined | MachineListParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof machineList>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof machineList>>,
          TError,
          Awaited<ReturnType<typeof machineList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMachineList<
  TData = Awaited<ReturnType<typeof machineList>>,
  TError = AxiosError<unknown>,
>(
  params?: MachineListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof machineList>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof machineList>>,
          TError,
          Awaited<ReturnType<typeof machineList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMachineList<
  TData = Awaited<ReturnType<typeof machineList>>,
  TError = AxiosError<unknown>,
>(
  params?: MachineListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof machineList>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List machines
 */

export function useMachineList<
  TData = Awaited<ReturnType<typeof machineList>>,
  TError = AxiosError<unknown>,
>(
  params?: MachineListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof machineList>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getMachineListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Machines are the representation of items that teach moves to Pok√©mon. They vary from version to version, so it is not certain that one specific TM or HM corresponds to a single Machine.
 * @summary Get machine
 */
export const machineRetrieve = (
  id: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<MachineDetail>> => {
  return axios.default.get(`https://pokeapi.co/api/v2/machine/${id}`, options);
};

export const getMachineRetrieveQueryKey = (id: string) => {
  return [`https://pokeapi.co/api/v2/machine/${id}`] as const;
};

export const getMachineRetrieveInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof machineRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof machineRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getMachineRetrieveQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof machineRetrieve>>> = ({
    signal,
  }) => machineRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof machineRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type MachineRetrieveInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof machineRetrieve>>
>;
export type MachineRetrieveInfiniteQueryError = AxiosError<unknown>;

export function useMachineRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof machineRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof machineRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof machineRetrieve>>,
          TError,
          Awaited<ReturnType<typeof machineRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMachineRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof machineRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof machineRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof machineRetrieve>>,
          TError,
          Awaited<ReturnType<typeof machineRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMachineRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof machineRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof machineRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get machine
 */

export function useMachineRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof machineRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof machineRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getMachineRetrieveInfiniteQueryOptions(id, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getMachineRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof machineRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof machineRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getMachineRetrieveQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof machineRetrieve>>> = ({
    signal,
  }) => machineRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof machineRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type MachineRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof machineRetrieve>>
>;
export type MachineRetrieveQueryError = AxiosError<unknown>;

export function useMachineRetrieve<
  TData = Awaited<ReturnType<typeof machineRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof machineRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof machineRetrieve>>,
          TError,
          Awaited<ReturnType<typeof machineRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMachineRetrieve<
  TData = Awaited<ReturnType<typeof machineRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof machineRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof machineRetrieve>>,
          TError,
          Awaited<ReturnType<typeof machineRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMachineRetrieve<
  TData = Awaited<ReturnType<typeof machineRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof machineRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get machine
 */

export function useMachineRetrieve<
  TData = Awaited<ReturnType<typeof machineRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof machineRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getMachineRetrieveQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Moves are the skills of Pok√©mon in battle. In battle, a Pok√©mon uses one move each turn. Some moves (including those learned by Hidden Machine) can be used outside of battle as well, usually for the purpose of removing obstacles or exploring new areas.
 * @summary List moves
 */
export const moveList = (
  params?: MoveListParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedMoveSummaryList>> => {
  return axios.default.get(`https://pokeapi.co/api/v2/move`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getMoveListQueryKey = (params?: MoveListParams) => {
  return [
    `https://pokeapi.co/api/v2/move`,
    ...(params ? [params] : []),
  ] as const;
};

export const getMoveListInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof moveList>>,
    MoveListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: MoveListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof moveList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof moveList>>,
        QueryKey,
        MoveListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getMoveListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof moveList>>,
    QueryKey,
    MoveListParams["offset"]
  > = ({ signal, pageParam }) =>
    moveList(
      { ...params, offset: pageParam || params?.["offset"] },
      { signal, ...axiosOptions },
    );

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof moveList>>,
    TError,
    TData,
    Awaited<ReturnType<typeof moveList>>,
    QueryKey,
    MoveListParams["offset"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type MoveListInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof moveList>>
>;
export type MoveListInfiniteQueryError = AxiosError<unknown>;

export function useMoveListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof moveList>>,
    MoveListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params: undefined | MoveListParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof moveList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof moveList>>,
        QueryKey,
        MoveListParams["offset"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof moveList>>,
          TError,
          Awaited<ReturnType<typeof moveList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMoveListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof moveList>>,
    MoveListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: MoveListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof moveList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof moveList>>,
        QueryKey,
        MoveListParams["offset"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof moveList>>,
          TError,
          Awaited<ReturnType<typeof moveList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMoveListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof moveList>>,
    MoveListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: MoveListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof moveList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof moveList>>,
        QueryKey,
        MoveListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List moves
 */

export function useMoveListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof moveList>>,
    MoveListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: MoveListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof moveList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof moveList>>,
        QueryKey,
        MoveListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getMoveListInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getMoveListQueryOptions = <
  TData = Awaited<ReturnType<typeof moveList>>,
  TError = AxiosError<unknown>,
>(
  params?: MoveListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof moveList>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getMoveListQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof moveList>>> = ({
    signal,
  }) => moveList(params, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof moveList>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type MoveListQueryResult = NonNullable<
  Awaited<ReturnType<typeof moveList>>
>;
export type MoveListQueryError = AxiosError<unknown>;

export function useMoveList<
  TData = Awaited<ReturnType<typeof moveList>>,
  TError = AxiosError<unknown>,
>(
  params: undefined | MoveListParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof moveList>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof moveList>>,
          TError,
          Awaited<ReturnType<typeof moveList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMoveList<
  TData = Awaited<ReturnType<typeof moveList>>,
  TError = AxiosError<unknown>,
>(
  params?: MoveListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof moveList>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof moveList>>,
          TError,
          Awaited<ReturnType<typeof moveList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMoveList<
  TData = Awaited<ReturnType<typeof moveList>>,
  TError = AxiosError<unknown>,
>(
  params?: MoveListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof moveList>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List moves
 */

export function useMoveList<
  TData = Awaited<ReturnType<typeof moveList>>,
  TError = AxiosError<unknown>,
>(
  params?: MoveListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof moveList>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getMoveListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Moves are the skills of Pok√©mon in battle. In battle, a Pok√©mon uses one move each turn. Some moves (including those learned by Hidden Machine) can be used outside of battle as well, usually for the purpose of removing obstacles or exploring new areas.
 * @summary Get move
 */
export const moveRetrieve = (
  id: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<MoveDetail>> => {
  return axios.default.get(`https://pokeapi.co/api/v2/move/${id}`, options);
};

export const getMoveRetrieveQueryKey = (id: string) => {
  return [`https://pokeapi.co/api/v2/move/${id}`] as const;
};

export const getMoveRetrieveInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof moveRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof moveRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getMoveRetrieveQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof moveRetrieve>>> = ({
    signal,
  }) => moveRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof moveRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type MoveRetrieveInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof moveRetrieve>>
>;
export type MoveRetrieveInfiniteQueryError = AxiosError<unknown>;

export function useMoveRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof moveRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof moveRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof moveRetrieve>>,
          TError,
          Awaited<ReturnType<typeof moveRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMoveRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof moveRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof moveRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof moveRetrieve>>,
          TError,
          Awaited<ReturnType<typeof moveRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMoveRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof moveRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof moveRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get move
 */

export function useMoveRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof moveRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof moveRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getMoveRetrieveInfiniteQueryOptions(id, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getMoveRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof moveRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof moveRetrieve>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getMoveRetrieveQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof moveRetrieve>>> = ({
    signal,
  }) => moveRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof moveRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type MoveRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof moveRetrieve>>
>;
export type MoveRetrieveQueryError = AxiosError<unknown>;

export function useMoveRetrieve<
  TData = Awaited<ReturnType<typeof moveRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof moveRetrieve>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof moveRetrieve>>,
          TError,
          Awaited<ReturnType<typeof moveRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMoveRetrieve<
  TData = Awaited<ReturnType<typeof moveRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof moveRetrieve>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof moveRetrieve>>,
          TError,
          Awaited<ReturnType<typeof moveRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMoveRetrieve<
  TData = Awaited<ReturnType<typeof moveRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof moveRetrieve>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get move
 */

export function useMoveRetrieve<
  TData = Awaited<ReturnType<typeof moveRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof moveRetrieve>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getMoveRetrieveQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Move Ailments are status conditions caused by moves used during battle. See [Bulbapedia](https://bulbapedia.bulbagarden.net/wiki/Status_condition) for greater detail.
 * @summary List move meta ailments
 */
export const moveAilmentList = (
  params?: MoveAilmentListParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedMoveMetaAilmentSummaryList>> => {
  return axios.default.get(`https://pokeapi.co/api/v2/move-ailment`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getMoveAilmentListQueryKey = (params?: MoveAilmentListParams) => {
  return [
    `https://pokeapi.co/api/v2/move-ailment`,
    ...(params ? [params] : []),
  ] as const;
};

export const getMoveAilmentListInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof moveAilmentList>>,
    MoveAilmentListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: MoveAilmentListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof moveAilmentList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof moveAilmentList>>,
        QueryKey,
        MoveAilmentListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getMoveAilmentListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof moveAilmentList>>,
    QueryKey,
    MoveAilmentListParams["offset"]
  > = ({ signal, pageParam }) =>
    moveAilmentList(
      { ...params, offset: pageParam || params?.["offset"] },
      { signal, ...axiosOptions },
    );

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof moveAilmentList>>,
    TError,
    TData,
    Awaited<ReturnType<typeof moveAilmentList>>,
    QueryKey,
    MoveAilmentListParams["offset"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type MoveAilmentListInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof moveAilmentList>>
>;
export type MoveAilmentListInfiniteQueryError = AxiosError<unknown>;

export function useMoveAilmentListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof moveAilmentList>>,
    MoveAilmentListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params: undefined | MoveAilmentListParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof moveAilmentList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof moveAilmentList>>,
        QueryKey,
        MoveAilmentListParams["offset"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof moveAilmentList>>,
          TError,
          Awaited<ReturnType<typeof moveAilmentList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMoveAilmentListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof moveAilmentList>>,
    MoveAilmentListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: MoveAilmentListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof moveAilmentList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof moveAilmentList>>,
        QueryKey,
        MoveAilmentListParams["offset"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof moveAilmentList>>,
          TError,
          Awaited<ReturnType<typeof moveAilmentList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMoveAilmentListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof moveAilmentList>>,
    MoveAilmentListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: MoveAilmentListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof moveAilmentList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof moveAilmentList>>,
        QueryKey,
        MoveAilmentListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List move meta ailments
 */

export function useMoveAilmentListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof moveAilmentList>>,
    MoveAilmentListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: MoveAilmentListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof moveAilmentList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof moveAilmentList>>,
        QueryKey,
        MoveAilmentListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getMoveAilmentListInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getMoveAilmentListQueryOptions = <
  TData = Awaited<ReturnType<typeof moveAilmentList>>,
  TError = AxiosError<unknown>,
>(
  params?: MoveAilmentListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof moveAilmentList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getMoveAilmentListQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof moveAilmentList>>> = ({
    signal,
  }) => moveAilmentList(params, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof moveAilmentList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type MoveAilmentListQueryResult = NonNullable<
  Awaited<ReturnType<typeof moveAilmentList>>
>;
export type MoveAilmentListQueryError = AxiosError<unknown>;

export function useMoveAilmentList<
  TData = Awaited<ReturnType<typeof moveAilmentList>>,
  TError = AxiosError<unknown>,
>(
  params: undefined | MoveAilmentListParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof moveAilmentList>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof moveAilmentList>>,
          TError,
          Awaited<ReturnType<typeof moveAilmentList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMoveAilmentList<
  TData = Awaited<ReturnType<typeof moveAilmentList>>,
  TError = AxiosError<unknown>,
>(
  params?: MoveAilmentListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof moveAilmentList>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof moveAilmentList>>,
          TError,
          Awaited<ReturnType<typeof moveAilmentList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMoveAilmentList<
  TData = Awaited<ReturnType<typeof moveAilmentList>>,
  TError = AxiosError<unknown>,
>(
  params?: MoveAilmentListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof moveAilmentList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List move meta ailments
 */

export function useMoveAilmentList<
  TData = Awaited<ReturnType<typeof moveAilmentList>>,
  TError = AxiosError<unknown>,
>(
  params?: MoveAilmentListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof moveAilmentList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getMoveAilmentListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Move Ailments are status conditions caused by moves used during battle. See [Bulbapedia](https://bulbapedia.bulbagarden.net/wiki/Status_condition) for greater detail.
 * @summary Get move meta ailment
 */
export const moveAilmentRetrieve = (
  id: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<MoveMetaAilmentDetail>> => {
  return axios.default.get(
    `https://pokeapi.co/api/v2/move-ailment/${id}`,
    options,
  );
};

export const getMoveAilmentRetrieveQueryKey = (id: string) => {
  return [`https://pokeapi.co/api/v2/move-ailment/${id}`] as const;
};

export const getMoveAilmentRetrieveInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof moveAilmentRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof moveAilmentRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getMoveAilmentRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof moveAilmentRetrieve>>
  > = ({ signal }) => moveAilmentRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof moveAilmentRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type MoveAilmentRetrieveInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof moveAilmentRetrieve>>
>;
export type MoveAilmentRetrieveInfiniteQueryError = AxiosError<unknown>;

export function useMoveAilmentRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof moveAilmentRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof moveAilmentRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof moveAilmentRetrieve>>,
          TError,
          Awaited<ReturnType<typeof moveAilmentRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMoveAilmentRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof moveAilmentRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof moveAilmentRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof moveAilmentRetrieve>>,
          TError,
          Awaited<ReturnType<typeof moveAilmentRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMoveAilmentRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof moveAilmentRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof moveAilmentRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get move meta ailment
 */

export function useMoveAilmentRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof moveAilmentRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof moveAilmentRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getMoveAilmentRetrieveInfiniteQueryOptions(id, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getMoveAilmentRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof moveAilmentRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof moveAilmentRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getMoveAilmentRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof moveAilmentRetrieve>>
  > = ({ signal }) => moveAilmentRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof moveAilmentRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type MoveAilmentRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof moveAilmentRetrieve>>
>;
export type MoveAilmentRetrieveQueryError = AxiosError<unknown>;

export function useMoveAilmentRetrieve<
  TData = Awaited<ReturnType<typeof moveAilmentRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof moveAilmentRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof moveAilmentRetrieve>>,
          TError,
          Awaited<ReturnType<typeof moveAilmentRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMoveAilmentRetrieve<
  TData = Awaited<ReturnType<typeof moveAilmentRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof moveAilmentRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof moveAilmentRetrieve>>,
          TError,
          Awaited<ReturnType<typeof moveAilmentRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMoveAilmentRetrieve<
  TData = Awaited<ReturnType<typeof moveAilmentRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof moveAilmentRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get move meta ailment
 */

export function useMoveAilmentRetrieve<
  TData = Awaited<ReturnType<typeof moveAilmentRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof moveAilmentRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getMoveAilmentRetrieveQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Styles of moves when used in the Battle Palace. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Battle_Frontier_(Generation_III)) for greater detail.
 * @summary List move battle styles
 */
export const moveBattleStyleList = (
  params?: MoveBattleStyleListParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedMoveBattleStyleSummaryList>> => {
  return axios.default.get(`https://pokeapi.co/api/v2/move-battle-style`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getMoveBattleStyleListQueryKey = (
  params?: MoveBattleStyleListParams,
) => {
  return [
    `https://pokeapi.co/api/v2/move-battle-style`,
    ...(params ? [params] : []),
  ] as const;
};

export const getMoveBattleStyleListInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof moveBattleStyleList>>,
    MoveBattleStyleListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: MoveBattleStyleListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof moveBattleStyleList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof moveBattleStyleList>>,
        QueryKey,
        MoveBattleStyleListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getMoveBattleStyleListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof moveBattleStyleList>>,
    QueryKey,
    MoveBattleStyleListParams["offset"]
  > = ({ signal, pageParam }) =>
    moveBattleStyleList(
      { ...params, offset: pageParam || params?.["offset"] },
      { signal, ...axiosOptions },
    );

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof moveBattleStyleList>>,
    TError,
    TData,
    Awaited<ReturnType<typeof moveBattleStyleList>>,
    QueryKey,
    MoveBattleStyleListParams["offset"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type MoveBattleStyleListInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof moveBattleStyleList>>
>;
export type MoveBattleStyleListInfiniteQueryError = AxiosError<unknown>;

export function useMoveBattleStyleListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof moveBattleStyleList>>,
    MoveBattleStyleListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params: undefined | MoveBattleStyleListParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof moveBattleStyleList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof moveBattleStyleList>>,
        QueryKey,
        MoveBattleStyleListParams["offset"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof moveBattleStyleList>>,
          TError,
          Awaited<ReturnType<typeof moveBattleStyleList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMoveBattleStyleListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof moveBattleStyleList>>,
    MoveBattleStyleListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: MoveBattleStyleListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof moveBattleStyleList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof moveBattleStyleList>>,
        QueryKey,
        MoveBattleStyleListParams["offset"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof moveBattleStyleList>>,
          TError,
          Awaited<ReturnType<typeof moveBattleStyleList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMoveBattleStyleListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof moveBattleStyleList>>,
    MoveBattleStyleListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: MoveBattleStyleListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof moveBattleStyleList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof moveBattleStyleList>>,
        QueryKey,
        MoveBattleStyleListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List move battle styles
 */

export function useMoveBattleStyleListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof moveBattleStyleList>>,
    MoveBattleStyleListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: MoveBattleStyleListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof moveBattleStyleList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof moveBattleStyleList>>,
        QueryKey,
        MoveBattleStyleListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getMoveBattleStyleListInfiniteQueryOptions(
    params,
    options,
  );

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getMoveBattleStyleListQueryOptions = <
  TData = Awaited<ReturnType<typeof moveBattleStyleList>>,
  TError = AxiosError<unknown>,
>(
  params?: MoveBattleStyleListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof moveBattleStyleList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getMoveBattleStyleListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof moveBattleStyleList>>
  > = ({ signal }) => moveBattleStyleList(params, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof moveBattleStyleList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type MoveBattleStyleListQueryResult = NonNullable<
  Awaited<ReturnType<typeof moveBattleStyleList>>
>;
export type MoveBattleStyleListQueryError = AxiosError<unknown>;

export function useMoveBattleStyleList<
  TData = Awaited<ReturnType<typeof moveBattleStyleList>>,
  TError = AxiosError<unknown>,
>(
  params: undefined | MoveBattleStyleListParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof moveBattleStyleList>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof moveBattleStyleList>>,
          TError,
          Awaited<ReturnType<typeof moveBattleStyleList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMoveBattleStyleList<
  TData = Awaited<ReturnType<typeof moveBattleStyleList>>,
  TError = AxiosError<unknown>,
>(
  params?: MoveBattleStyleListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof moveBattleStyleList>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof moveBattleStyleList>>,
          TError,
          Awaited<ReturnType<typeof moveBattleStyleList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMoveBattleStyleList<
  TData = Awaited<ReturnType<typeof moveBattleStyleList>>,
  TError = AxiosError<unknown>,
>(
  params?: MoveBattleStyleListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof moveBattleStyleList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List move battle styles
 */

export function useMoveBattleStyleList<
  TData = Awaited<ReturnType<typeof moveBattleStyleList>>,
  TError = AxiosError<unknown>,
>(
  params?: MoveBattleStyleListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof moveBattleStyleList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getMoveBattleStyleListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Styles of moves when used in the Battle Palace. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Battle_Frontier_(Generation_III)) for greater detail.
 * @summary Get move battle style
 */
export const moveBattleStyleRetrieve = (
  id: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<MoveBattleStyleDetail>> => {
  return axios.default.get(
    `https://pokeapi.co/api/v2/move-battle-style/${id}`,
    options,
  );
};

export const getMoveBattleStyleRetrieveQueryKey = (id: string) => {
  return [`https://pokeapi.co/api/v2/move-battle-style/${id}`] as const;
};

export const getMoveBattleStyleRetrieveInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof moveBattleStyleRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof moveBattleStyleRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getMoveBattleStyleRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof moveBattleStyleRetrieve>>
  > = ({ signal }) => moveBattleStyleRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof moveBattleStyleRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type MoveBattleStyleRetrieveInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof moveBattleStyleRetrieve>>
>;
export type MoveBattleStyleRetrieveInfiniteQueryError = AxiosError<unknown>;

export function useMoveBattleStyleRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof moveBattleStyleRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof moveBattleStyleRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof moveBattleStyleRetrieve>>,
          TError,
          Awaited<ReturnType<typeof moveBattleStyleRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMoveBattleStyleRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof moveBattleStyleRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof moveBattleStyleRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof moveBattleStyleRetrieve>>,
          TError,
          Awaited<ReturnType<typeof moveBattleStyleRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMoveBattleStyleRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof moveBattleStyleRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof moveBattleStyleRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get move battle style
 */

export function useMoveBattleStyleRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof moveBattleStyleRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof moveBattleStyleRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getMoveBattleStyleRetrieveInfiniteQueryOptions(
    id,
    options,
  );

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getMoveBattleStyleRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof moveBattleStyleRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof moveBattleStyleRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getMoveBattleStyleRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof moveBattleStyleRetrieve>>
  > = ({ signal }) => moveBattleStyleRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof moveBattleStyleRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type MoveBattleStyleRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof moveBattleStyleRetrieve>>
>;
export type MoveBattleStyleRetrieveQueryError = AxiosError<unknown>;

export function useMoveBattleStyleRetrieve<
  TData = Awaited<ReturnType<typeof moveBattleStyleRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof moveBattleStyleRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof moveBattleStyleRetrieve>>,
          TError,
          Awaited<ReturnType<typeof moveBattleStyleRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMoveBattleStyleRetrieve<
  TData = Awaited<ReturnType<typeof moveBattleStyleRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof moveBattleStyleRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof moveBattleStyleRetrieve>>,
          TError,
          Awaited<ReturnType<typeof moveBattleStyleRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMoveBattleStyleRetrieve<
  TData = Awaited<ReturnType<typeof moveBattleStyleRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof moveBattleStyleRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get move battle style
 */

export function useMoveBattleStyleRetrieve<
  TData = Awaited<ReturnType<typeof moveBattleStyleRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof moveBattleStyleRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getMoveBattleStyleRetrieveQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Very general categories that loosely group move effects.
 * @summary List move meta categories
 */
export const moveCategoryList = (
  params?: MoveCategoryListParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedMoveMetaCategorySummaryList>> => {
  return axios.default.get(`https://pokeapi.co/api/v2/move-category`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getMoveCategoryListQueryKey = (
  params?: MoveCategoryListParams,
) => {
  return [
    `https://pokeapi.co/api/v2/move-category`,
    ...(params ? [params] : []),
  ] as const;
};

export const getMoveCategoryListInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof moveCategoryList>>,
    MoveCategoryListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: MoveCategoryListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof moveCategoryList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof moveCategoryList>>,
        QueryKey,
        MoveCategoryListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getMoveCategoryListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof moveCategoryList>>,
    QueryKey,
    MoveCategoryListParams["offset"]
  > = ({ signal, pageParam }) =>
    moveCategoryList(
      { ...params, offset: pageParam || params?.["offset"] },
      { signal, ...axiosOptions },
    );

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof moveCategoryList>>,
    TError,
    TData,
    Awaited<ReturnType<typeof moveCategoryList>>,
    QueryKey,
    MoveCategoryListParams["offset"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type MoveCategoryListInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof moveCategoryList>>
>;
export type MoveCategoryListInfiniteQueryError = AxiosError<unknown>;

export function useMoveCategoryListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof moveCategoryList>>,
    MoveCategoryListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params: undefined | MoveCategoryListParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof moveCategoryList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof moveCategoryList>>,
        QueryKey,
        MoveCategoryListParams["offset"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof moveCategoryList>>,
          TError,
          Awaited<ReturnType<typeof moveCategoryList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMoveCategoryListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof moveCategoryList>>,
    MoveCategoryListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: MoveCategoryListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof moveCategoryList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof moveCategoryList>>,
        QueryKey,
        MoveCategoryListParams["offset"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof moveCategoryList>>,
          TError,
          Awaited<ReturnType<typeof moveCategoryList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMoveCategoryListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof moveCategoryList>>,
    MoveCategoryListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: MoveCategoryListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof moveCategoryList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof moveCategoryList>>,
        QueryKey,
        MoveCategoryListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List move meta categories
 */

export function useMoveCategoryListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof moveCategoryList>>,
    MoveCategoryListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: MoveCategoryListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof moveCategoryList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof moveCategoryList>>,
        QueryKey,
        MoveCategoryListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getMoveCategoryListInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getMoveCategoryListQueryOptions = <
  TData = Awaited<ReturnType<typeof moveCategoryList>>,
  TError = AxiosError<unknown>,
>(
  params?: MoveCategoryListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof moveCategoryList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getMoveCategoryListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof moveCategoryList>>
  > = ({ signal }) => moveCategoryList(params, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof moveCategoryList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type MoveCategoryListQueryResult = NonNullable<
  Awaited<ReturnType<typeof moveCategoryList>>
>;
export type MoveCategoryListQueryError = AxiosError<unknown>;

export function useMoveCategoryList<
  TData = Awaited<ReturnType<typeof moveCategoryList>>,
  TError = AxiosError<unknown>,
>(
  params: undefined | MoveCategoryListParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof moveCategoryList>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof moveCategoryList>>,
          TError,
          Awaited<ReturnType<typeof moveCategoryList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMoveCategoryList<
  TData = Awaited<ReturnType<typeof moveCategoryList>>,
  TError = AxiosError<unknown>,
>(
  params?: MoveCategoryListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof moveCategoryList>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof moveCategoryList>>,
          TError,
          Awaited<ReturnType<typeof moveCategoryList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMoveCategoryList<
  TData = Awaited<ReturnType<typeof moveCategoryList>>,
  TError = AxiosError<unknown>,
>(
  params?: MoveCategoryListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof moveCategoryList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List move meta categories
 */

export function useMoveCategoryList<
  TData = Awaited<ReturnType<typeof moveCategoryList>>,
  TError = AxiosError<unknown>,
>(
  params?: MoveCategoryListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof moveCategoryList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getMoveCategoryListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Very general categories that loosely group move effects.
 * @summary Get move meta category
 */
export const moveCategoryRetrieve = (
  id: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<MoveMetaCategoryDetail>> => {
  return axios.default.get(
    `https://pokeapi.co/api/v2/move-category/${id}`,
    options,
  );
};

export const getMoveCategoryRetrieveQueryKey = (id: string) => {
  return [`https://pokeapi.co/api/v2/move-category/${id}`] as const;
};

export const getMoveCategoryRetrieveInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof moveCategoryRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof moveCategoryRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getMoveCategoryRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof moveCategoryRetrieve>>
  > = ({ signal }) => moveCategoryRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof moveCategoryRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type MoveCategoryRetrieveInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof moveCategoryRetrieve>>
>;
export type MoveCategoryRetrieveInfiniteQueryError = AxiosError<unknown>;

export function useMoveCategoryRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof moveCategoryRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof moveCategoryRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof moveCategoryRetrieve>>,
          TError,
          Awaited<ReturnType<typeof moveCategoryRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMoveCategoryRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof moveCategoryRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof moveCategoryRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof moveCategoryRetrieve>>,
          TError,
          Awaited<ReturnType<typeof moveCategoryRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMoveCategoryRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof moveCategoryRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof moveCategoryRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get move meta category
 */

export function useMoveCategoryRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof moveCategoryRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof moveCategoryRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getMoveCategoryRetrieveInfiniteQueryOptions(id, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getMoveCategoryRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof moveCategoryRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof moveCategoryRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getMoveCategoryRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof moveCategoryRetrieve>>
  > = ({ signal }) => moveCategoryRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof moveCategoryRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type MoveCategoryRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof moveCategoryRetrieve>>
>;
export type MoveCategoryRetrieveQueryError = AxiosError<unknown>;

export function useMoveCategoryRetrieve<
  TData = Awaited<ReturnType<typeof moveCategoryRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof moveCategoryRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof moveCategoryRetrieve>>,
          TError,
          Awaited<ReturnType<typeof moveCategoryRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMoveCategoryRetrieve<
  TData = Awaited<ReturnType<typeof moveCategoryRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof moveCategoryRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof moveCategoryRetrieve>>,
          TError,
          Awaited<ReturnType<typeof moveCategoryRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMoveCategoryRetrieve<
  TData = Awaited<ReturnType<typeof moveCategoryRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof moveCategoryRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get move meta category
 */

export function useMoveCategoryRetrieve<
  TData = Awaited<ReturnType<typeof moveCategoryRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof moveCategoryRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getMoveCategoryRetrieveQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Damage classes moves can have, e.g. physical, special, or non-damaging.
 * @summary List move damage classes
 */
export const moveDamageClassList = (
  params?: MoveDamageClassListParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedMoveDamageClassSummaryList>> => {
  return axios.default.get(`https://pokeapi.co/api/v2/move-damage-class`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getMoveDamageClassListQueryKey = (
  params?: MoveDamageClassListParams,
) => {
  return [
    `https://pokeapi.co/api/v2/move-damage-class`,
    ...(params ? [params] : []),
  ] as const;
};

export const getMoveDamageClassListInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof moveDamageClassList>>,
    MoveDamageClassListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: MoveDamageClassListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof moveDamageClassList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof moveDamageClassList>>,
        QueryKey,
        MoveDamageClassListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getMoveDamageClassListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof moveDamageClassList>>,
    QueryKey,
    MoveDamageClassListParams["offset"]
  > = ({ signal, pageParam }) =>
    moveDamageClassList(
      { ...params, offset: pageParam || params?.["offset"] },
      { signal, ...axiosOptions },
    );

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof moveDamageClassList>>,
    TError,
    TData,
    Awaited<ReturnType<typeof moveDamageClassList>>,
    QueryKey,
    MoveDamageClassListParams["offset"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type MoveDamageClassListInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof moveDamageClassList>>
>;
export type MoveDamageClassListInfiniteQueryError = AxiosError<unknown>;

export function useMoveDamageClassListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof moveDamageClassList>>,
    MoveDamageClassListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params: undefined | MoveDamageClassListParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof moveDamageClassList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof moveDamageClassList>>,
        QueryKey,
        MoveDamageClassListParams["offset"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof moveDamageClassList>>,
          TError,
          Awaited<ReturnType<typeof moveDamageClassList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMoveDamageClassListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof moveDamageClassList>>,
    MoveDamageClassListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: MoveDamageClassListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof moveDamageClassList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof moveDamageClassList>>,
        QueryKey,
        MoveDamageClassListParams["offset"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof moveDamageClassList>>,
          TError,
          Awaited<ReturnType<typeof moveDamageClassList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMoveDamageClassListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof moveDamageClassList>>,
    MoveDamageClassListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: MoveDamageClassListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof moveDamageClassList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof moveDamageClassList>>,
        QueryKey,
        MoveDamageClassListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List move damage classes
 */

export function useMoveDamageClassListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof moveDamageClassList>>,
    MoveDamageClassListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: MoveDamageClassListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof moveDamageClassList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof moveDamageClassList>>,
        QueryKey,
        MoveDamageClassListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getMoveDamageClassListInfiniteQueryOptions(
    params,
    options,
  );

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getMoveDamageClassListQueryOptions = <
  TData = Awaited<ReturnType<typeof moveDamageClassList>>,
  TError = AxiosError<unknown>,
>(
  params?: MoveDamageClassListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof moveDamageClassList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getMoveDamageClassListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof moveDamageClassList>>
  > = ({ signal }) => moveDamageClassList(params, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof moveDamageClassList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type MoveDamageClassListQueryResult = NonNullable<
  Awaited<ReturnType<typeof moveDamageClassList>>
>;
export type MoveDamageClassListQueryError = AxiosError<unknown>;

export function useMoveDamageClassList<
  TData = Awaited<ReturnType<typeof moveDamageClassList>>,
  TError = AxiosError<unknown>,
>(
  params: undefined | MoveDamageClassListParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof moveDamageClassList>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof moveDamageClassList>>,
          TError,
          Awaited<ReturnType<typeof moveDamageClassList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMoveDamageClassList<
  TData = Awaited<ReturnType<typeof moveDamageClassList>>,
  TError = AxiosError<unknown>,
>(
  params?: MoveDamageClassListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof moveDamageClassList>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof moveDamageClassList>>,
          TError,
          Awaited<ReturnType<typeof moveDamageClassList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMoveDamageClassList<
  TData = Awaited<ReturnType<typeof moveDamageClassList>>,
  TError = AxiosError<unknown>,
>(
  params?: MoveDamageClassListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof moveDamageClassList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List move damage classes
 */

export function useMoveDamageClassList<
  TData = Awaited<ReturnType<typeof moveDamageClassList>>,
  TError = AxiosError<unknown>,
>(
  params?: MoveDamageClassListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof moveDamageClassList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getMoveDamageClassListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Damage classes moves can have, e.g. physical, special, or non-damaging.
 * @summary Get move damage class
 */
export const moveDamageClassRetrieve = (
  id: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<MoveDamageClassDetail>> => {
  return axios.default.get(
    `https://pokeapi.co/api/v2/move-damage-class/${id}`,
    options,
  );
};

export const getMoveDamageClassRetrieveQueryKey = (id: string) => {
  return [`https://pokeapi.co/api/v2/move-damage-class/${id}`] as const;
};

export const getMoveDamageClassRetrieveInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof moveDamageClassRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof moveDamageClassRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getMoveDamageClassRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof moveDamageClassRetrieve>>
  > = ({ signal }) => moveDamageClassRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof moveDamageClassRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type MoveDamageClassRetrieveInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof moveDamageClassRetrieve>>
>;
export type MoveDamageClassRetrieveInfiniteQueryError = AxiosError<unknown>;

export function useMoveDamageClassRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof moveDamageClassRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof moveDamageClassRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof moveDamageClassRetrieve>>,
          TError,
          Awaited<ReturnType<typeof moveDamageClassRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMoveDamageClassRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof moveDamageClassRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof moveDamageClassRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof moveDamageClassRetrieve>>,
          TError,
          Awaited<ReturnType<typeof moveDamageClassRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMoveDamageClassRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof moveDamageClassRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof moveDamageClassRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get move damage class
 */

export function useMoveDamageClassRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof moveDamageClassRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof moveDamageClassRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getMoveDamageClassRetrieveInfiniteQueryOptions(
    id,
    options,
  );

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getMoveDamageClassRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof moveDamageClassRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof moveDamageClassRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getMoveDamageClassRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof moveDamageClassRetrieve>>
  > = ({ signal }) => moveDamageClassRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof moveDamageClassRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type MoveDamageClassRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof moveDamageClassRetrieve>>
>;
export type MoveDamageClassRetrieveQueryError = AxiosError<unknown>;

export function useMoveDamageClassRetrieve<
  TData = Awaited<ReturnType<typeof moveDamageClassRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof moveDamageClassRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof moveDamageClassRetrieve>>,
          TError,
          Awaited<ReturnType<typeof moveDamageClassRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMoveDamageClassRetrieve<
  TData = Awaited<ReturnType<typeof moveDamageClassRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof moveDamageClassRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof moveDamageClassRetrieve>>,
          TError,
          Awaited<ReturnType<typeof moveDamageClassRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMoveDamageClassRetrieve<
  TData = Awaited<ReturnType<typeof moveDamageClassRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof moveDamageClassRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get move damage class
 */

export function useMoveDamageClassRetrieve<
  TData = Awaited<ReturnType<typeof moveDamageClassRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof moveDamageClassRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getMoveDamageClassRetrieveQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Methods by which Pok√©mon can learn moves.
 * @summary List move learn methods
 */
export const moveLearnMethodList = (
  params?: MoveLearnMethodListParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedMoveLearnMethodSummaryList>> => {
  return axios.default.get(`https://pokeapi.co/api/v2/move-learn-method`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getMoveLearnMethodListQueryKey = (
  params?: MoveLearnMethodListParams,
) => {
  return [
    `https://pokeapi.co/api/v2/move-learn-method`,
    ...(params ? [params] : []),
  ] as const;
};

export const getMoveLearnMethodListInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof moveLearnMethodList>>,
    MoveLearnMethodListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: MoveLearnMethodListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof moveLearnMethodList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof moveLearnMethodList>>,
        QueryKey,
        MoveLearnMethodListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getMoveLearnMethodListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof moveLearnMethodList>>,
    QueryKey,
    MoveLearnMethodListParams["offset"]
  > = ({ signal, pageParam }) =>
    moveLearnMethodList(
      { ...params, offset: pageParam || params?.["offset"] },
      { signal, ...axiosOptions },
    );

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof moveLearnMethodList>>,
    TError,
    TData,
    Awaited<ReturnType<typeof moveLearnMethodList>>,
    QueryKey,
    MoveLearnMethodListParams["offset"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type MoveLearnMethodListInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof moveLearnMethodList>>
>;
export type MoveLearnMethodListInfiniteQueryError = AxiosError<unknown>;

export function useMoveLearnMethodListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof moveLearnMethodList>>,
    MoveLearnMethodListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params: undefined | MoveLearnMethodListParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof moveLearnMethodList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof moveLearnMethodList>>,
        QueryKey,
        MoveLearnMethodListParams["offset"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof moveLearnMethodList>>,
          TError,
          Awaited<ReturnType<typeof moveLearnMethodList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMoveLearnMethodListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof moveLearnMethodList>>,
    MoveLearnMethodListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: MoveLearnMethodListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof moveLearnMethodList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof moveLearnMethodList>>,
        QueryKey,
        MoveLearnMethodListParams["offset"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof moveLearnMethodList>>,
          TError,
          Awaited<ReturnType<typeof moveLearnMethodList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMoveLearnMethodListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof moveLearnMethodList>>,
    MoveLearnMethodListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: MoveLearnMethodListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof moveLearnMethodList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof moveLearnMethodList>>,
        QueryKey,
        MoveLearnMethodListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List move learn methods
 */

export function useMoveLearnMethodListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof moveLearnMethodList>>,
    MoveLearnMethodListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: MoveLearnMethodListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof moveLearnMethodList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof moveLearnMethodList>>,
        QueryKey,
        MoveLearnMethodListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getMoveLearnMethodListInfiniteQueryOptions(
    params,
    options,
  );

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getMoveLearnMethodListQueryOptions = <
  TData = Awaited<ReturnType<typeof moveLearnMethodList>>,
  TError = AxiosError<unknown>,
>(
  params?: MoveLearnMethodListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof moveLearnMethodList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getMoveLearnMethodListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof moveLearnMethodList>>
  > = ({ signal }) => moveLearnMethodList(params, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof moveLearnMethodList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type MoveLearnMethodListQueryResult = NonNullable<
  Awaited<ReturnType<typeof moveLearnMethodList>>
>;
export type MoveLearnMethodListQueryError = AxiosError<unknown>;

export function useMoveLearnMethodList<
  TData = Awaited<ReturnType<typeof moveLearnMethodList>>,
  TError = AxiosError<unknown>,
>(
  params: undefined | MoveLearnMethodListParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof moveLearnMethodList>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof moveLearnMethodList>>,
          TError,
          Awaited<ReturnType<typeof moveLearnMethodList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMoveLearnMethodList<
  TData = Awaited<ReturnType<typeof moveLearnMethodList>>,
  TError = AxiosError<unknown>,
>(
  params?: MoveLearnMethodListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof moveLearnMethodList>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof moveLearnMethodList>>,
          TError,
          Awaited<ReturnType<typeof moveLearnMethodList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMoveLearnMethodList<
  TData = Awaited<ReturnType<typeof moveLearnMethodList>>,
  TError = AxiosError<unknown>,
>(
  params?: MoveLearnMethodListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof moveLearnMethodList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List move learn methods
 */

export function useMoveLearnMethodList<
  TData = Awaited<ReturnType<typeof moveLearnMethodList>>,
  TError = AxiosError<unknown>,
>(
  params?: MoveLearnMethodListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof moveLearnMethodList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getMoveLearnMethodListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Methods by which Pok√©mon can learn moves.
 * @summary Get move learn method
 */
export const moveLearnMethodRetrieve = (
  id: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<MoveLearnMethodDetail>> => {
  return axios.default.get(
    `https://pokeapi.co/api/v2/move-learn-method/${id}`,
    options,
  );
};

export const getMoveLearnMethodRetrieveQueryKey = (id: string) => {
  return [`https://pokeapi.co/api/v2/move-learn-method/${id}`] as const;
};

export const getMoveLearnMethodRetrieveInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof moveLearnMethodRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof moveLearnMethodRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getMoveLearnMethodRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof moveLearnMethodRetrieve>>
  > = ({ signal }) => moveLearnMethodRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof moveLearnMethodRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type MoveLearnMethodRetrieveInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof moveLearnMethodRetrieve>>
>;
export type MoveLearnMethodRetrieveInfiniteQueryError = AxiosError<unknown>;

export function useMoveLearnMethodRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof moveLearnMethodRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof moveLearnMethodRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof moveLearnMethodRetrieve>>,
          TError,
          Awaited<ReturnType<typeof moveLearnMethodRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMoveLearnMethodRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof moveLearnMethodRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof moveLearnMethodRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof moveLearnMethodRetrieve>>,
          TError,
          Awaited<ReturnType<typeof moveLearnMethodRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMoveLearnMethodRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof moveLearnMethodRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof moveLearnMethodRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get move learn method
 */

export function useMoveLearnMethodRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof moveLearnMethodRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof moveLearnMethodRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getMoveLearnMethodRetrieveInfiniteQueryOptions(
    id,
    options,
  );

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getMoveLearnMethodRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof moveLearnMethodRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof moveLearnMethodRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getMoveLearnMethodRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof moveLearnMethodRetrieve>>
  > = ({ signal }) => moveLearnMethodRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof moveLearnMethodRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type MoveLearnMethodRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof moveLearnMethodRetrieve>>
>;
export type MoveLearnMethodRetrieveQueryError = AxiosError<unknown>;

export function useMoveLearnMethodRetrieve<
  TData = Awaited<ReturnType<typeof moveLearnMethodRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof moveLearnMethodRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof moveLearnMethodRetrieve>>,
          TError,
          Awaited<ReturnType<typeof moveLearnMethodRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMoveLearnMethodRetrieve<
  TData = Awaited<ReturnType<typeof moveLearnMethodRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof moveLearnMethodRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof moveLearnMethodRetrieve>>,
          TError,
          Awaited<ReturnType<typeof moveLearnMethodRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMoveLearnMethodRetrieve<
  TData = Awaited<ReturnType<typeof moveLearnMethodRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof moveLearnMethodRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get move learn method
 */

export function useMoveLearnMethodRetrieve<
  TData = Awaited<ReturnType<typeof moveLearnMethodRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof moveLearnMethodRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getMoveLearnMethodRetrieveQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Targets moves can be directed at during battle. Targets can be Pok√©mon, environments or even other moves.
 * @summary List move targets
 */
export const moveTargetList = (
  params?: MoveTargetListParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedMoveTargetSummaryList>> => {
  return axios.default.get(`https://pokeapi.co/api/v2/move-target`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getMoveTargetListQueryKey = (params?: MoveTargetListParams) => {
  return [
    `https://pokeapi.co/api/v2/move-target`,
    ...(params ? [params] : []),
  ] as const;
};

export const getMoveTargetListInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof moveTargetList>>,
    MoveTargetListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: MoveTargetListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof moveTargetList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof moveTargetList>>,
        QueryKey,
        MoveTargetListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getMoveTargetListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof moveTargetList>>,
    QueryKey,
    MoveTargetListParams["offset"]
  > = ({ signal, pageParam }) =>
    moveTargetList(
      { ...params, offset: pageParam || params?.["offset"] },
      { signal, ...axiosOptions },
    );

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof moveTargetList>>,
    TError,
    TData,
    Awaited<ReturnType<typeof moveTargetList>>,
    QueryKey,
    MoveTargetListParams["offset"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type MoveTargetListInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof moveTargetList>>
>;
export type MoveTargetListInfiniteQueryError = AxiosError<unknown>;

export function useMoveTargetListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof moveTargetList>>,
    MoveTargetListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params: undefined | MoveTargetListParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof moveTargetList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof moveTargetList>>,
        QueryKey,
        MoveTargetListParams["offset"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof moveTargetList>>,
          TError,
          Awaited<ReturnType<typeof moveTargetList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMoveTargetListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof moveTargetList>>,
    MoveTargetListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: MoveTargetListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof moveTargetList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof moveTargetList>>,
        QueryKey,
        MoveTargetListParams["offset"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof moveTargetList>>,
          TError,
          Awaited<ReturnType<typeof moveTargetList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMoveTargetListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof moveTargetList>>,
    MoveTargetListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: MoveTargetListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof moveTargetList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof moveTargetList>>,
        QueryKey,
        MoveTargetListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List move targets
 */

export function useMoveTargetListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof moveTargetList>>,
    MoveTargetListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: MoveTargetListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof moveTargetList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof moveTargetList>>,
        QueryKey,
        MoveTargetListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getMoveTargetListInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getMoveTargetListQueryOptions = <
  TData = Awaited<ReturnType<typeof moveTargetList>>,
  TError = AxiosError<unknown>,
>(
  params?: MoveTargetListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof moveTargetList>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getMoveTargetListQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof moveTargetList>>> = ({
    signal,
  }) => moveTargetList(params, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof moveTargetList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type MoveTargetListQueryResult = NonNullable<
  Awaited<ReturnType<typeof moveTargetList>>
>;
export type MoveTargetListQueryError = AxiosError<unknown>;

export function useMoveTargetList<
  TData = Awaited<ReturnType<typeof moveTargetList>>,
  TError = AxiosError<unknown>,
>(
  params: undefined | MoveTargetListParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof moveTargetList>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof moveTargetList>>,
          TError,
          Awaited<ReturnType<typeof moveTargetList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMoveTargetList<
  TData = Awaited<ReturnType<typeof moveTargetList>>,
  TError = AxiosError<unknown>,
>(
  params?: MoveTargetListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof moveTargetList>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof moveTargetList>>,
          TError,
          Awaited<ReturnType<typeof moveTargetList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMoveTargetList<
  TData = Awaited<ReturnType<typeof moveTargetList>>,
  TError = AxiosError<unknown>,
>(
  params?: MoveTargetListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof moveTargetList>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List move targets
 */

export function useMoveTargetList<
  TData = Awaited<ReturnType<typeof moveTargetList>>,
  TError = AxiosError<unknown>,
>(
  params?: MoveTargetListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof moveTargetList>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getMoveTargetListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Targets moves can be directed at during battle. Targets can be Pok√©mon, environments or even other moves.
 * @summary Get move target
 */
export const moveTargetRetrieve = (
  id: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<MoveTargetDetail>> => {
  return axios.default.get(
    `https://pokeapi.co/api/v2/move-target/${id}`,
    options,
  );
};

export const getMoveTargetRetrieveQueryKey = (id: string) => {
  return [`https://pokeapi.co/api/v2/move-target/${id}`] as const;
};

export const getMoveTargetRetrieveInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof moveTargetRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof moveTargetRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getMoveTargetRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof moveTargetRetrieve>>
  > = ({ signal }) => moveTargetRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof moveTargetRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type MoveTargetRetrieveInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof moveTargetRetrieve>>
>;
export type MoveTargetRetrieveInfiniteQueryError = AxiosError<unknown>;

export function useMoveTargetRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof moveTargetRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof moveTargetRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof moveTargetRetrieve>>,
          TError,
          Awaited<ReturnType<typeof moveTargetRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMoveTargetRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof moveTargetRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof moveTargetRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof moveTargetRetrieve>>,
          TError,
          Awaited<ReturnType<typeof moveTargetRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMoveTargetRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof moveTargetRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof moveTargetRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get move target
 */

export function useMoveTargetRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof moveTargetRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof moveTargetRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getMoveTargetRetrieveInfiniteQueryOptions(id, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getMoveTargetRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof moveTargetRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof moveTargetRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getMoveTargetRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof moveTargetRetrieve>>
  > = ({ signal }) => moveTargetRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof moveTargetRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type MoveTargetRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof moveTargetRetrieve>>
>;
export type MoveTargetRetrieveQueryError = AxiosError<unknown>;

export function useMoveTargetRetrieve<
  TData = Awaited<ReturnType<typeof moveTargetRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof moveTargetRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof moveTargetRetrieve>>,
          TError,
          Awaited<ReturnType<typeof moveTargetRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMoveTargetRetrieve<
  TData = Awaited<ReturnType<typeof moveTargetRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof moveTargetRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof moveTargetRetrieve>>,
          TError,
          Awaited<ReturnType<typeof moveTargetRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMoveTargetRetrieve<
  TData = Awaited<ReturnType<typeof moveTargetRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof moveTargetRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get move target
 */

export function useMoveTargetRetrieve<
  TData = Awaited<ReturnType<typeof moveTargetRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof moveTargetRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getMoveTargetRetrieveQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Natures influence how a Pok√©mon's stats grow. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Nature) for greater detail.
 * @summary List natures
 */
export const natureList = (
  params?: NatureListParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedNatureSummaryList>> => {
  return axios.default.get(`https://pokeapi.co/api/v2/nature`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getNatureListQueryKey = (params?: NatureListParams) => {
  return [
    `https://pokeapi.co/api/v2/nature`,
    ...(params ? [params] : []),
  ] as const;
};

export const getNatureListInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof natureList>>,
    NatureListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: NatureListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof natureList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof natureList>>,
        QueryKey,
        NatureListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getNatureListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof natureList>>,
    QueryKey,
    NatureListParams["offset"]
  > = ({ signal, pageParam }) =>
    natureList(
      { ...params, offset: pageParam || params?.["offset"] },
      { signal, ...axiosOptions },
    );

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof natureList>>,
    TError,
    TData,
    Awaited<ReturnType<typeof natureList>>,
    QueryKey,
    NatureListParams["offset"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type NatureListInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof natureList>>
>;
export type NatureListInfiniteQueryError = AxiosError<unknown>;

export function useNatureListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof natureList>>,
    NatureListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params: undefined | NatureListParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof natureList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof natureList>>,
        QueryKey,
        NatureListParams["offset"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof natureList>>,
          TError,
          Awaited<ReturnType<typeof natureList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useNatureListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof natureList>>,
    NatureListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: NatureListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof natureList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof natureList>>,
        QueryKey,
        NatureListParams["offset"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof natureList>>,
          TError,
          Awaited<ReturnType<typeof natureList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useNatureListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof natureList>>,
    NatureListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: NatureListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof natureList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof natureList>>,
        QueryKey,
        NatureListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List natures
 */

export function useNatureListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof natureList>>,
    NatureListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: NatureListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof natureList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof natureList>>,
        QueryKey,
        NatureListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getNatureListInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getNatureListQueryOptions = <
  TData = Awaited<ReturnType<typeof natureList>>,
  TError = AxiosError<unknown>,
>(
  params?: NatureListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof natureList>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getNatureListQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof natureList>>> = ({
    signal,
  }) => natureList(params, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof natureList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type NatureListQueryResult = NonNullable<
  Awaited<ReturnType<typeof natureList>>
>;
export type NatureListQueryError = AxiosError<unknown>;

export function useNatureList<
  TData = Awaited<ReturnType<typeof natureList>>,
  TError = AxiosError<unknown>,
>(
  params: undefined | NatureListParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof natureList>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof natureList>>,
          TError,
          Awaited<ReturnType<typeof natureList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useNatureList<
  TData = Awaited<ReturnType<typeof natureList>>,
  TError = AxiosError<unknown>,
>(
  params?: NatureListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof natureList>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof natureList>>,
          TError,
          Awaited<ReturnType<typeof natureList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useNatureList<
  TData = Awaited<ReturnType<typeof natureList>>,
  TError = AxiosError<unknown>,
>(
  params?: NatureListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof natureList>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List natures
 */

export function useNatureList<
  TData = Awaited<ReturnType<typeof natureList>>,
  TError = AxiosError<unknown>,
>(
  params?: NatureListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof natureList>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getNatureListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Natures influence how a Pok√©mon's stats grow. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Nature) for greater detail.
 * @summary Get nature
 */
export const natureRetrieve = (
  id: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<NatureDetail>> => {
  return axios.default.get(`https://pokeapi.co/api/v2/nature/${id}`, options);
};

export const getNatureRetrieveQueryKey = (id: string) => {
  return [`https://pokeapi.co/api/v2/nature/${id}`] as const;
};

export const getNatureRetrieveInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof natureRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof natureRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getNatureRetrieveQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof natureRetrieve>>> = ({
    signal,
  }) => natureRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof natureRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type NatureRetrieveInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof natureRetrieve>>
>;
export type NatureRetrieveInfiniteQueryError = AxiosError<unknown>;

export function useNatureRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof natureRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof natureRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof natureRetrieve>>,
          TError,
          Awaited<ReturnType<typeof natureRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useNatureRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof natureRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof natureRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof natureRetrieve>>,
          TError,
          Awaited<ReturnType<typeof natureRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useNatureRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof natureRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof natureRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get nature
 */

export function useNatureRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof natureRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof natureRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getNatureRetrieveInfiniteQueryOptions(id, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getNatureRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof natureRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof natureRetrieve>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getNatureRetrieveQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof natureRetrieve>>> = ({
    signal,
  }) => natureRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof natureRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type NatureRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof natureRetrieve>>
>;
export type NatureRetrieveQueryError = AxiosError<unknown>;

export function useNatureRetrieve<
  TData = Awaited<ReturnType<typeof natureRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof natureRetrieve>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof natureRetrieve>>,
          TError,
          Awaited<ReturnType<typeof natureRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useNatureRetrieve<
  TData = Awaited<ReturnType<typeof natureRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof natureRetrieve>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof natureRetrieve>>,
          TError,
          Awaited<ReturnType<typeof natureRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useNatureRetrieve<
  TData = Awaited<ReturnType<typeof natureRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof natureRetrieve>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get nature
 */

export function useNatureRetrieve<
  TData = Awaited<ReturnType<typeof natureRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof natureRetrieve>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getNatureRetrieveQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Areas used for grouping Pok√©mon encounters in Pal Park. They're like habitats that are specific to Pal Park.
 * @summary List pal park areas
 */
export const palParkAreaList = (
  params?: PalParkAreaListParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedPalParkAreaSummaryList>> => {
  return axios.default.get(`https://pokeapi.co/api/v2/pal-park-area`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getPalParkAreaListQueryKey = (params?: PalParkAreaListParams) => {
  return [
    `https://pokeapi.co/api/v2/pal-park-area`,
    ...(params ? [params] : []),
  ] as const;
};

export const getPalParkAreaListInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof palParkAreaList>>,
    PalParkAreaListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: PalParkAreaListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof palParkAreaList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof palParkAreaList>>,
        QueryKey,
        PalParkAreaListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getPalParkAreaListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof palParkAreaList>>,
    QueryKey,
    PalParkAreaListParams["offset"]
  > = ({ signal, pageParam }) =>
    palParkAreaList(
      { ...params, offset: pageParam || params?.["offset"] },
      { signal, ...axiosOptions },
    );

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof palParkAreaList>>,
    TError,
    TData,
    Awaited<ReturnType<typeof palParkAreaList>>,
    QueryKey,
    PalParkAreaListParams["offset"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PalParkAreaListInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof palParkAreaList>>
>;
export type PalParkAreaListInfiniteQueryError = AxiosError<unknown>;

export function usePalParkAreaListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof palParkAreaList>>,
    PalParkAreaListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params: undefined | PalParkAreaListParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof palParkAreaList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof palParkAreaList>>,
        QueryKey,
        PalParkAreaListParams["offset"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof palParkAreaList>>,
          TError,
          Awaited<ReturnType<typeof palParkAreaList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePalParkAreaListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof palParkAreaList>>,
    PalParkAreaListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: PalParkAreaListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof palParkAreaList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof palParkAreaList>>,
        QueryKey,
        PalParkAreaListParams["offset"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof palParkAreaList>>,
          TError,
          Awaited<ReturnType<typeof palParkAreaList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePalParkAreaListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof palParkAreaList>>,
    PalParkAreaListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: PalParkAreaListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof palParkAreaList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof palParkAreaList>>,
        QueryKey,
        PalParkAreaListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List pal park areas
 */

export function usePalParkAreaListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof palParkAreaList>>,
    PalParkAreaListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: PalParkAreaListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof palParkAreaList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof palParkAreaList>>,
        QueryKey,
        PalParkAreaListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getPalParkAreaListInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getPalParkAreaListQueryOptions = <
  TData = Awaited<ReturnType<typeof palParkAreaList>>,
  TError = AxiosError<unknown>,
>(
  params?: PalParkAreaListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof palParkAreaList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getPalParkAreaListQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof palParkAreaList>>> = ({
    signal,
  }) => palParkAreaList(params, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof palParkAreaList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PalParkAreaListQueryResult = NonNullable<
  Awaited<ReturnType<typeof palParkAreaList>>
>;
export type PalParkAreaListQueryError = AxiosError<unknown>;

export function usePalParkAreaList<
  TData = Awaited<ReturnType<typeof palParkAreaList>>,
  TError = AxiosError<unknown>,
>(
  params: undefined | PalParkAreaListParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof palParkAreaList>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof palParkAreaList>>,
          TError,
          Awaited<ReturnType<typeof palParkAreaList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePalParkAreaList<
  TData = Awaited<ReturnType<typeof palParkAreaList>>,
  TError = AxiosError<unknown>,
>(
  params?: PalParkAreaListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof palParkAreaList>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof palParkAreaList>>,
          TError,
          Awaited<ReturnType<typeof palParkAreaList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePalParkAreaList<
  TData = Awaited<ReturnType<typeof palParkAreaList>>,
  TError = AxiosError<unknown>,
>(
  params?: PalParkAreaListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof palParkAreaList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List pal park areas
 */

export function usePalParkAreaList<
  TData = Awaited<ReturnType<typeof palParkAreaList>>,
  TError = AxiosError<unknown>,
>(
  params?: PalParkAreaListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof palParkAreaList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getPalParkAreaListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Areas used for grouping Pok√©mon encounters in Pal Park. They're like habitats that are specific to Pal Park.
 * @summary Get pal park area
 */
export const palParkAreaRetrieve = (
  id: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PalParkAreaDetail>> => {
  return axios.default.get(
    `https://pokeapi.co/api/v2/pal-park-area/${id}`,
    options,
  );
};

export const getPalParkAreaRetrieveQueryKey = (id: string) => {
  return [`https://pokeapi.co/api/v2/pal-park-area/${id}`] as const;
};

export const getPalParkAreaRetrieveInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof palParkAreaRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof palParkAreaRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getPalParkAreaRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof palParkAreaRetrieve>>
  > = ({ signal }) => palParkAreaRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof palParkAreaRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PalParkAreaRetrieveInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof palParkAreaRetrieve>>
>;
export type PalParkAreaRetrieveInfiniteQueryError = AxiosError<unknown>;

export function usePalParkAreaRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof palParkAreaRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof palParkAreaRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof palParkAreaRetrieve>>,
          TError,
          Awaited<ReturnType<typeof palParkAreaRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePalParkAreaRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof palParkAreaRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof palParkAreaRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof palParkAreaRetrieve>>,
          TError,
          Awaited<ReturnType<typeof palParkAreaRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePalParkAreaRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof palParkAreaRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof palParkAreaRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get pal park area
 */

export function usePalParkAreaRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof palParkAreaRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof palParkAreaRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getPalParkAreaRetrieveInfiniteQueryOptions(id, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getPalParkAreaRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof palParkAreaRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof palParkAreaRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getPalParkAreaRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof palParkAreaRetrieve>>
  > = ({ signal }) => palParkAreaRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof palParkAreaRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PalParkAreaRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof palParkAreaRetrieve>>
>;
export type PalParkAreaRetrieveQueryError = AxiosError<unknown>;

export function usePalParkAreaRetrieve<
  TData = Awaited<ReturnType<typeof palParkAreaRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof palParkAreaRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof palParkAreaRetrieve>>,
          TError,
          Awaited<ReturnType<typeof palParkAreaRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePalParkAreaRetrieve<
  TData = Awaited<ReturnType<typeof palParkAreaRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof palParkAreaRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof palParkAreaRetrieve>>,
          TError,
          Awaited<ReturnType<typeof palParkAreaRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePalParkAreaRetrieve<
  TData = Awaited<ReturnType<typeof palParkAreaRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof palParkAreaRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get pal park area
 */

export function usePalParkAreaRetrieve<
  TData = Awaited<ReturnType<typeof palParkAreaRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof palParkAreaRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getPalParkAreaRetrieveQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * A Pok√©dex is a handheld electronic encyclopedia device; one which is capable of recording and retaining information of the various Pok√©mon in a given region with the exception of the national dex and some smaller dexes related to portions of a region. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Pokedex) for greater detail.
 * @summary List pokedex
 */
export const pokedexList = (
  params?: PokedexListParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedPokedexSummaryList>> => {
  return axios.default.get(`https://pokeapi.co/api/v2/pokedex`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getPokedexListQueryKey = (params?: PokedexListParams) => {
  return [
    `https://pokeapi.co/api/v2/pokedex`,
    ...(params ? [params] : []),
  ] as const;
};

export const getPokedexListInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof pokedexList>>,
    PokedexListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: PokedexListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokedexList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof pokedexList>>,
        QueryKey,
        PokedexListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getPokedexListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof pokedexList>>,
    QueryKey,
    PokedexListParams["offset"]
  > = ({ signal, pageParam }) =>
    pokedexList(
      { ...params, offset: pageParam || params?.["offset"] },
      { signal, ...axiosOptions },
    );

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof pokedexList>>,
    TError,
    TData,
    Awaited<ReturnType<typeof pokedexList>>,
    QueryKey,
    PokedexListParams["offset"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PokedexListInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof pokedexList>>
>;
export type PokedexListInfiniteQueryError = AxiosError<unknown>;

export function usePokedexListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof pokedexList>>,
    PokedexListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params: undefined | PokedexListParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokedexList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof pokedexList>>,
        QueryKey,
        PokedexListParams["offset"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokedexList>>,
          TError,
          Awaited<ReturnType<typeof pokedexList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePokedexListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof pokedexList>>,
    PokedexListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: PokedexListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokedexList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof pokedexList>>,
        QueryKey,
        PokedexListParams["offset"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokedexList>>,
          TError,
          Awaited<ReturnType<typeof pokedexList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePokedexListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof pokedexList>>,
    PokedexListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: PokedexListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokedexList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof pokedexList>>,
        QueryKey,
        PokedexListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List pokedex
 */

export function usePokedexListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof pokedexList>>,
    PokedexListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: PokedexListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokedexList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof pokedexList>>,
        QueryKey,
        PokedexListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getPokedexListInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getPokedexListQueryOptions = <
  TData = Awaited<ReturnType<typeof pokedexList>>,
  TError = AxiosError<unknown>,
>(
  params?: PokedexListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof pokedexList>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getPokedexListQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof pokedexList>>> = ({
    signal,
  }) => pokedexList(params, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof pokedexList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PokedexListQueryResult = NonNullable<
  Awaited<ReturnType<typeof pokedexList>>
>;
export type PokedexListQueryError = AxiosError<unknown>;

export function usePokedexList<
  TData = Awaited<ReturnType<typeof pokedexList>>,
  TError = AxiosError<unknown>,
>(
  params: undefined | PokedexListParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof pokedexList>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokedexList>>,
          TError,
          Awaited<ReturnType<typeof pokedexList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePokedexList<
  TData = Awaited<ReturnType<typeof pokedexList>>,
  TError = AxiosError<unknown>,
>(
  params?: PokedexListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof pokedexList>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokedexList>>,
          TError,
          Awaited<ReturnType<typeof pokedexList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePokedexList<
  TData = Awaited<ReturnType<typeof pokedexList>>,
  TError = AxiosError<unknown>,
>(
  params?: PokedexListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof pokedexList>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List pokedex
 */

export function usePokedexList<
  TData = Awaited<ReturnType<typeof pokedexList>>,
  TError = AxiosError<unknown>,
>(
  params?: PokedexListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof pokedexList>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getPokedexListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * A Pok√©dex is a handheld electronic encyclopedia device; one which is capable of recording and retaining information of the various Pok√©mon in a given region with the exception of the national dex and some smaller dexes related to portions of a region. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Pokedex) for greater detail.
 * @summary Get pokedex
 */
export const pokedexRetrieve = (
  id: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PokedexDetail>> => {
  return axios.default.get(`https://pokeapi.co/api/v2/pokedex/${id}`, options);
};

export const getPokedexRetrieveQueryKey = (id: string) => {
  return [`https://pokeapi.co/api/v2/pokedex/${id}`] as const;
};

export const getPokedexRetrieveInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof pokedexRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokedexRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getPokedexRetrieveQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof pokedexRetrieve>>> = ({
    signal,
  }) => pokedexRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof pokedexRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PokedexRetrieveInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof pokedexRetrieve>>
>;
export type PokedexRetrieveInfiniteQueryError = AxiosError<unknown>;

export function usePokedexRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof pokedexRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokedexRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokedexRetrieve>>,
          TError,
          Awaited<ReturnType<typeof pokedexRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePokedexRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof pokedexRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokedexRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokedexRetrieve>>,
          TError,
          Awaited<ReturnType<typeof pokedexRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePokedexRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof pokedexRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokedexRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get pokedex
 */

export function usePokedexRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof pokedexRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokedexRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getPokedexRetrieveInfiniteQueryOptions(id, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getPokedexRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof pokedexRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokedexRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getPokedexRetrieveQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof pokedexRetrieve>>> = ({
    signal,
  }) => pokedexRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof pokedexRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PokedexRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof pokedexRetrieve>>
>;
export type PokedexRetrieveQueryError = AxiosError<unknown>;

export function usePokedexRetrieve<
  TData = Awaited<ReturnType<typeof pokedexRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokedexRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokedexRetrieve>>,
          TError,
          Awaited<ReturnType<typeof pokedexRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePokedexRetrieve<
  TData = Awaited<ReturnType<typeof pokedexRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokedexRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokedexRetrieve>>,
          TError,
          Awaited<ReturnType<typeof pokedexRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePokedexRetrieve<
  TData = Awaited<ReturnType<typeof pokedexRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokedexRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get pokedex
 */

export function usePokedexRetrieve<
  TData = Awaited<ReturnType<typeof pokedexRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokedexRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getPokedexRetrieveQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Pok√©mon are the creatures that inhabit the world of the Pok√©mon games. They can be caught using Pok√©balls and trained by battling with other Pok√©mon. Each Pok√©mon belongs to a specific species but may take on a variant which makes it differ from other Pok√©mon of the same species, such as base stats, available abilities and typings. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Pok%C3%A9mon_(species)) for greater detail.
 * @summary List pokemon
 */
export const pokemonList = (
  params?: PokemonListParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedPokemonSummaryList>> => {
  return axios.default.get(`https://pokeapi.co/api/v2/pokemon`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getPokemonListQueryKey = (params?: PokemonListParams) => {
  return [
    `https://pokeapi.co/api/v2/pokemon`,
    ...(params ? [params] : []),
  ] as const;
};

export const getPokemonListInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof pokemonList>>,
    PokemonListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: PokemonListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokemonList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof pokemonList>>,
        QueryKey,
        PokemonListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getPokemonListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof pokemonList>>,
    QueryKey,
    PokemonListParams["offset"]
  > = ({ signal, pageParam }) =>
    pokemonList(
      { ...params, offset: pageParam || params?.["offset"] },
      { signal, ...axiosOptions },
    );

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof pokemonList>>,
    TError,
    TData,
    Awaited<ReturnType<typeof pokemonList>>,
    QueryKey,
    PokemonListParams["offset"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PokemonListInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof pokemonList>>
>;
export type PokemonListInfiniteQueryError = AxiosError<unknown>;

export function usePokemonListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof pokemonList>>,
    PokemonListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params: undefined | PokemonListParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokemonList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof pokemonList>>,
        QueryKey,
        PokemonListParams["offset"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonList>>,
          TError,
          Awaited<ReturnType<typeof pokemonList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePokemonListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof pokemonList>>,
    PokemonListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: PokemonListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokemonList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof pokemonList>>,
        QueryKey,
        PokemonListParams["offset"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonList>>,
          TError,
          Awaited<ReturnType<typeof pokemonList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePokemonListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof pokemonList>>,
    PokemonListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: PokemonListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokemonList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof pokemonList>>,
        QueryKey,
        PokemonListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List pokemon
 */

export function usePokemonListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof pokemonList>>,
    PokemonListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: PokemonListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokemonList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof pokemonList>>,
        QueryKey,
        PokemonListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getPokemonListInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getPokemonListQueryOptions = <
  TData = Awaited<ReturnType<typeof pokemonList>>,
  TError = AxiosError<unknown>,
>(
  params?: PokemonListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof pokemonList>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getPokemonListQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof pokemonList>>> = ({
    signal,
  }) => pokemonList(params, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof pokemonList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PokemonListQueryResult = NonNullable<
  Awaited<ReturnType<typeof pokemonList>>
>;
export type PokemonListQueryError = AxiosError<unknown>;

export function usePokemonList<
  TData = Awaited<ReturnType<typeof pokemonList>>,
  TError = AxiosError<unknown>,
>(
  params: undefined | PokemonListParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof pokemonList>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonList>>,
          TError,
          Awaited<ReturnType<typeof pokemonList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePokemonList<
  TData = Awaited<ReturnType<typeof pokemonList>>,
  TError = AxiosError<unknown>,
>(
  params?: PokemonListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof pokemonList>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonList>>,
          TError,
          Awaited<ReturnType<typeof pokemonList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePokemonList<
  TData = Awaited<ReturnType<typeof pokemonList>>,
  TError = AxiosError<unknown>,
>(
  params?: PokemonListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof pokemonList>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List pokemon
 */

export function usePokemonList<
  TData = Awaited<ReturnType<typeof pokemonList>>,
  TError = AxiosError<unknown>,
>(
  params?: PokemonListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof pokemonList>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getPokemonListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Pok√©mon are the creatures that inhabit the world of the Pok√©mon games. They can be caught using Pok√©balls and trained by battling with other Pok√©mon. Each Pok√©mon belongs to a specific species but may take on a variant which makes it differ from other Pok√©mon of the same species, such as base stats, available abilities and typings. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Pok%C3%A9mon_(species)) for greater detail.
 * @summary Get pokemon
 */
export const pokemonRetrieve = (
  id: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PokemonDetail>> => {
  return axios.default.get(`https://pokeapi.co/api/v2/pokemon/${id}`, options);
};

export const getPokemonRetrieveQueryKey = (id: string) => {
  return [`https://pokeapi.co/api/v2/pokemon/${id}`] as const;
};

export const getPokemonRetrieveInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof pokemonRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokemonRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getPokemonRetrieveQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof pokemonRetrieve>>> = ({
    signal,
  }) => pokemonRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof pokemonRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PokemonRetrieveInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof pokemonRetrieve>>
>;
export type PokemonRetrieveInfiniteQueryError = AxiosError<unknown>;

export function usePokemonRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof pokemonRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokemonRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonRetrieve>>,
          TError,
          Awaited<ReturnType<typeof pokemonRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePokemonRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof pokemonRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokemonRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonRetrieve>>,
          TError,
          Awaited<ReturnType<typeof pokemonRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePokemonRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof pokemonRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokemonRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get pokemon
 */

export function usePokemonRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof pokemonRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokemonRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getPokemonRetrieveInfiniteQueryOptions(id, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getPokemonRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof pokemonRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokemonRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getPokemonRetrieveQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof pokemonRetrieve>>> = ({
    signal,
  }) => pokemonRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof pokemonRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PokemonRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof pokemonRetrieve>>
>;
export type PokemonRetrieveQueryError = AxiosError<unknown>;

export function usePokemonRetrieve<
  TData = Awaited<ReturnType<typeof pokemonRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokemonRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonRetrieve>>,
          TError,
          Awaited<ReturnType<typeof pokemonRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePokemonRetrieve<
  TData = Awaited<ReturnType<typeof pokemonRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokemonRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonRetrieve>>,
          TError,
          Awaited<ReturnType<typeof pokemonRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePokemonRetrieve<
  TData = Awaited<ReturnType<typeof pokemonRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokemonRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get pokemon
 */

export function usePokemonRetrieve<
  TData = Awaited<ReturnType<typeof pokemonRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokemonRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getPokemonRetrieveQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Colors used for sorting Pok√©mon in a Pok√©dex. The color listed in the Pok√©dex is usually the color most apparent or covering each Pok√©mon's body. No orange category exists; Pok√©mon that are primarily orange are listed as red or brown.
 * @summary List pokemon colors
 */
export const pokemonColorList = (
  params?: PokemonColorListParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedPokemonColorSummaryList>> => {
  return axios.default.get(`https://pokeapi.co/api/v2/pokemon-color`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getPokemonColorListQueryKey = (
  params?: PokemonColorListParams,
) => {
  return [
    `https://pokeapi.co/api/v2/pokemon-color`,
    ...(params ? [params] : []),
  ] as const;
};

export const getPokemonColorListInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof pokemonColorList>>,
    PokemonColorListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: PokemonColorListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokemonColorList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof pokemonColorList>>,
        QueryKey,
        PokemonColorListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getPokemonColorListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof pokemonColorList>>,
    QueryKey,
    PokemonColorListParams["offset"]
  > = ({ signal, pageParam }) =>
    pokemonColorList(
      { ...params, offset: pageParam || params?.["offset"] },
      { signal, ...axiosOptions },
    );

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof pokemonColorList>>,
    TError,
    TData,
    Awaited<ReturnType<typeof pokemonColorList>>,
    QueryKey,
    PokemonColorListParams["offset"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PokemonColorListInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof pokemonColorList>>
>;
export type PokemonColorListInfiniteQueryError = AxiosError<unknown>;

export function usePokemonColorListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof pokemonColorList>>,
    PokemonColorListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params: undefined | PokemonColorListParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokemonColorList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof pokemonColorList>>,
        QueryKey,
        PokemonColorListParams["offset"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonColorList>>,
          TError,
          Awaited<ReturnType<typeof pokemonColorList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePokemonColorListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof pokemonColorList>>,
    PokemonColorListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: PokemonColorListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokemonColorList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof pokemonColorList>>,
        QueryKey,
        PokemonColorListParams["offset"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonColorList>>,
          TError,
          Awaited<ReturnType<typeof pokemonColorList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePokemonColorListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof pokemonColorList>>,
    PokemonColorListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: PokemonColorListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokemonColorList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof pokemonColorList>>,
        QueryKey,
        PokemonColorListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List pokemon colors
 */

export function usePokemonColorListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof pokemonColorList>>,
    PokemonColorListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: PokemonColorListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokemonColorList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof pokemonColorList>>,
        QueryKey,
        PokemonColorListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getPokemonColorListInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getPokemonColorListQueryOptions = <
  TData = Awaited<ReturnType<typeof pokemonColorList>>,
  TError = AxiosError<unknown>,
>(
  params?: PokemonColorListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokemonColorList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getPokemonColorListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof pokemonColorList>>
  > = ({ signal }) => pokemonColorList(params, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof pokemonColorList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PokemonColorListQueryResult = NonNullable<
  Awaited<ReturnType<typeof pokemonColorList>>
>;
export type PokemonColorListQueryError = AxiosError<unknown>;

export function usePokemonColorList<
  TData = Awaited<ReturnType<typeof pokemonColorList>>,
  TError = AxiosError<unknown>,
>(
  params: undefined | PokemonColorListParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokemonColorList>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonColorList>>,
          TError,
          Awaited<ReturnType<typeof pokemonColorList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePokemonColorList<
  TData = Awaited<ReturnType<typeof pokemonColorList>>,
  TError = AxiosError<unknown>,
>(
  params?: PokemonColorListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokemonColorList>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonColorList>>,
          TError,
          Awaited<ReturnType<typeof pokemonColorList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePokemonColorList<
  TData = Awaited<ReturnType<typeof pokemonColorList>>,
  TError = AxiosError<unknown>,
>(
  params?: PokemonColorListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokemonColorList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List pokemon colors
 */

export function usePokemonColorList<
  TData = Awaited<ReturnType<typeof pokemonColorList>>,
  TError = AxiosError<unknown>,
>(
  params?: PokemonColorListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokemonColorList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getPokemonColorListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Colors used for sorting Pok√©mon in a Pok√©dex. The color listed in the Pok√©dex is usually the color most apparent or covering each Pok√©mon's body. No orange category exists; Pok√©mon that are primarily orange are listed as red or brown.
 * @summary Get pokemon color
 */
export const pokemonColorRetrieve = (
  id: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PokemonColorDetail>> => {
  return axios.default.get(
    `https://pokeapi.co/api/v2/pokemon-color/${id}`,
    options,
  );
};

export const getPokemonColorRetrieveQueryKey = (id: string) => {
  return [`https://pokeapi.co/api/v2/pokemon-color/${id}`] as const;
};

export const getPokemonColorRetrieveInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof pokemonColorRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokemonColorRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getPokemonColorRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof pokemonColorRetrieve>>
  > = ({ signal }) => pokemonColorRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof pokemonColorRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PokemonColorRetrieveInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof pokemonColorRetrieve>>
>;
export type PokemonColorRetrieveInfiniteQueryError = AxiosError<unknown>;

export function usePokemonColorRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof pokemonColorRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokemonColorRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonColorRetrieve>>,
          TError,
          Awaited<ReturnType<typeof pokemonColorRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePokemonColorRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof pokemonColorRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokemonColorRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonColorRetrieve>>,
          TError,
          Awaited<ReturnType<typeof pokemonColorRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePokemonColorRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof pokemonColorRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokemonColorRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get pokemon color
 */

export function usePokemonColorRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof pokemonColorRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokemonColorRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getPokemonColorRetrieveInfiniteQueryOptions(id, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getPokemonColorRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof pokemonColorRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokemonColorRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getPokemonColorRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof pokemonColorRetrieve>>
  > = ({ signal }) => pokemonColorRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof pokemonColorRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PokemonColorRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof pokemonColorRetrieve>>
>;
export type PokemonColorRetrieveQueryError = AxiosError<unknown>;

export function usePokemonColorRetrieve<
  TData = Awaited<ReturnType<typeof pokemonColorRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokemonColorRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonColorRetrieve>>,
          TError,
          Awaited<ReturnType<typeof pokemonColorRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePokemonColorRetrieve<
  TData = Awaited<ReturnType<typeof pokemonColorRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokemonColorRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonColorRetrieve>>,
          TError,
          Awaited<ReturnType<typeof pokemonColorRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePokemonColorRetrieve<
  TData = Awaited<ReturnType<typeof pokemonColorRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokemonColorRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get pokemon color
 */

export function usePokemonColorRetrieve<
  TData = Awaited<ReturnType<typeof pokemonColorRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokemonColorRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getPokemonColorRetrieveQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Some Pok√©mon may appear in one of multiple, visually different forms. These differences are purely cosmetic. For variations within a Pok√©mon species, which do differ in more than just visuals, the 'Pok√©mon' entity is used to represent such a variety.
 * @summary List pokemon forms
 */
export const pokemonFormList = (
  params?: PokemonFormListParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedPokemonFormSummaryList>> => {
  return axios.default.get(`https://pokeapi.co/api/v2/pokemon-form`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getPokemonFormListQueryKey = (params?: PokemonFormListParams) => {
  return [
    `https://pokeapi.co/api/v2/pokemon-form`,
    ...(params ? [params] : []),
  ] as const;
};

export const getPokemonFormListInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof pokemonFormList>>,
    PokemonFormListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: PokemonFormListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokemonFormList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof pokemonFormList>>,
        QueryKey,
        PokemonFormListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getPokemonFormListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof pokemonFormList>>,
    QueryKey,
    PokemonFormListParams["offset"]
  > = ({ signal, pageParam }) =>
    pokemonFormList(
      { ...params, offset: pageParam || params?.["offset"] },
      { signal, ...axiosOptions },
    );

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof pokemonFormList>>,
    TError,
    TData,
    Awaited<ReturnType<typeof pokemonFormList>>,
    QueryKey,
    PokemonFormListParams["offset"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PokemonFormListInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof pokemonFormList>>
>;
export type PokemonFormListInfiniteQueryError = AxiosError<unknown>;

export function usePokemonFormListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof pokemonFormList>>,
    PokemonFormListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params: undefined | PokemonFormListParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokemonFormList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof pokemonFormList>>,
        QueryKey,
        PokemonFormListParams["offset"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonFormList>>,
          TError,
          Awaited<ReturnType<typeof pokemonFormList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePokemonFormListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof pokemonFormList>>,
    PokemonFormListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: PokemonFormListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokemonFormList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof pokemonFormList>>,
        QueryKey,
        PokemonFormListParams["offset"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonFormList>>,
          TError,
          Awaited<ReturnType<typeof pokemonFormList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePokemonFormListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof pokemonFormList>>,
    PokemonFormListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: PokemonFormListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokemonFormList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof pokemonFormList>>,
        QueryKey,
        PokemonFormListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List pokemon forms
 */

export function usePokemonFormListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof pokemonFormList>>,
    PokemonFormListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: PokemonFormListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokemonFormList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof pokemonFormList>>,
        QueryKey,
        PokemonFormListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getPokemonFormListInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getPokemonFormListQueryOptions = <
  TData = Awaited<ReturnType<typeof pokemonFormList>>,
  TError = AxiosError<unknown>,
>(
  params?: PokemonFormListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokemonFormList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getPokemonFormListQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof pokemonFormList>>> = ({
    signal,
  }) => pokemonFormList(params, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof pokemonFormList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PokemonFormListQueryResult = NonNullable<
  Awaited<ReturnType<typeof pokemonFormList>>
>;
export type PokemonFormListQueryError = AxiosError<unknown>;

export function usePokemonFormList<
  TData = Awaited<ReturnType<typeof pokemonFormList>>,
  TError = AxiosError<unknown>,
>(
  params: undefined | PokemonFormListParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokemonFormList>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonFormList>>,
          TError,
          Awaited<ReturnType<typeof pokemonFormList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePokemonFormList<
  TData = Awaited<ReturnType<typeof pokemonFormList>>,
  TError = AxiosError<unknown>,
>(
  params?: PokemonFormListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokemonFormList>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonFormList>>,
          TError,
          Awaited<ReturnType<typeof pokemonFormList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePokemonFormList<
  TData = Awaited<ReturnType<typeof pokemonFormList>>,
  TError = AxiosError<unknown>,
>(
  params?: PokemonFormListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokemonFormList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List pokemon forms
 */

export function usePokemonFormList<
  TData = Awaited<ReturnType<typeof pokemonFormList>>,
  TError = AxiosError<unknown>,
>(
  params?: PokemonFormListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokemonFormList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getPokemonFormListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Some Pok√©mon may appear in one of multiple, visually different forms. These differences are purely cosmetic. For variations within a Pok√©mon species, which do differ in more than just visuals, the 'Pok√©mon' entity is used to represent such a variety.
 * @summary Get pokemon form
 */
export const pokemonFormRetrieve = (
  id: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PokemonFormDetail>> => {
  return axios.default.get(
    `https://pokeapi.co/api/v2/pokemon-form/${id}`,
    options,
  );
};

export const getPokemonFormRetrieveQueryKey = (id: string) => {
  return [`https://pokeapi.co/api/v2/pokemon-form/${id}`] as const;
};

export const getPokemonFormRetrieveInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof pokemonFormRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokemonFormRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getPokemonFormRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof pokemonFormRetrieve>>
  > = ({ signal }) => pokemonFormRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof pokemonFormRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PokemonFormRetrieveInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof pokemonFormRetrieve>>
>;
export type PokemonFormRetrieveInfiniteQueryError = AxiosError<unknown>;

export function usePokemonFormRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof pokemonFormRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokemonFormRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonFormRetrieve>>,
          TError,
          Awaited<ReturnType<typeof pokemonFormRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePokemonFormRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof pokemonFormRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokemonFormRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonFormRetrieve>>,
          TError,
          Awaited<ReturnType<typeof pokemonFormRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePokemonFormRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof pokemonFormRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokemonFormRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get pokemon form
 */

export function usePokemonFormRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof pokemonFormRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokemonFormRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getPokemonFormRetrieveInfiniteQueryOptions(id, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getPokemonFormRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof pokemonFormRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokemonFormRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getPokemonFormRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof pokemonFormRetrieve>>
  > = ({ signal }) => pokemonFormRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof pokemonFormRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PokemonFormRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof pokemonFormRetrieve>>
>;
export type PokemonFormRetrieveQueryError = AxiosError<unknown>;

export function usePokemonFormRetrieve<
  TData = Awaited<ReturnType<typeof pokemonFormRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokemonFormRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonFormRetrieve>>,
          TError,
          Awaited<ReturnType<typeof pokemonFormRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePokemonFormRetrieve<
  TData = Awaited<ReturnType<typeof pokemonFormRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokemonFormRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonFormRetrieve>>,
          TError,
          Awaited<ReturnType<typeof pokemonFormRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePokemonFormRetrieve<
  TData = Awaited<ReturnType<typeof pokemonFormRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokemonFormRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get pokemon form
 */

export function usePokemonFormRetrieve<
  TData = Awaited<ReturnType<typeof pokemonFormRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokemonFormRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getPokemonFormRetrieveQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Habitats are generally different terrain Pok√©mon can be found in but can also be areas designated for rare or legendary Pok√©mon.
 * @summary List pokemom habitas
 */
export const pokemonHabitatList = (
  params?: PokemonHabitatListParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedPokemonHabitatSummaryList>> => {
  return axios.default.get(`https://pokeapi.co/api/v2/pokemon-habitat`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getPokemonHabitatListQueryKey = (
  params?: PokemonHabitatListParams,
) => {
  return [
    `https://pokeapi.co/api/v2/pokemon-habitat`,
    ...(params ? [params] : []),
  ] as const;
};

export const getPokemonHabitatListInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof pokemonHabitatList>>,
    PokemonHabitatListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: PokemonHabitatListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokemonHabitatList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof pokemonHabitatList>>,
        QueryKey,
        PokemonHabitatListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getPokemonHabitatListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof pokemonHabitatList>>,
    QueryKey,
    PokemonHabitatListParams["offset"]
  > = ({ signal, pageParam }) =>
    pokemonHabitatList(
      { ...params, offset: pageParam || params?.["offset"] },
      { signal, ...axiosOptions },
    );

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof pokemonHabitatList>>,
    TError,
    TData,
    Awaited<ReturnType<typeof pokemonHabitatList>>,
    QueryKey,
    PokemonHabitatListParams["offset"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PokemonHabitatListInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof pokemonHabitatList>>
>;
export type PokemonHabitatListInfiniteQueryError = AxiosError<unknown>;

export function usePokemonHabitatListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof pokemonHabitatList>>,
    PokemonHabitatListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params: undefined | PokemonHabitatListParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokemonHabitatList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof pokemonHabitatList>>,
        QueryKey,
        PokemonHabitatListParams["offset"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonHabitatList>>,
          TError,
          Awaited<ReturnType<typeof pokemonHabitatList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePokemonHabitatListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof pokemonHabitatList>>,
    PokemonHabitatListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: PokemonHabitatListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokemonHabitatList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof pokemonHabitatList>>,
        QueryKey,
        PokemonHabitatListParams["offset"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonHabitatList>>,
          TError,
          Awaited<ReturnType<typeof pokemonHabitatList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePokemonHabitatListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof pokemonHabitatList>>,
    PokemonHabitatListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: PokemonHabitatListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokemonHabitatList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof pokemonHabitatList>>,
        QueryKey,
        PokemonHabitatListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List pokemom habitas
 */

export function usePokemonHabitatListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof pokemonHabitatList>>,
    PokemonHabitatListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: PokemonHabitatListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokemonHabitatList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof pokemonHabitatList>>,
        QueryKey,
        PokemonHabitatListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getPokemonHabitatListInfiniteQueryOptions(
    params,
    options,
  );

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getPokemonHabitatListQueryOptions = <
  TData = Awaited<ReturnType<typeof pokemonHabitatList>>,
  TError = AxiosError<unknown>,
>(
  params?: PokemonHabitatListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokemonHabitatList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getPokemonHabitatListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof pokemonHabitatList>>
  > = ({ signal }) => pokemonHabitatList(params, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof pokemonHabitatList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PokemonHabitatListQueryResult = NonNullable<
  Awaited<ReturnType<typeof pokemonHabitatList>>
>;
export type PokemonHabitatListQueryError = AxiosError<unknown>;

export function usePokemonHabitatList<
  TData = Awaited<ReturnType<typeof pokemonHabitatList>>,
  TError = AxiosError<unknown>,
>(
  params: undefined | PokemonHabitatListParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokemonHabitatList>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonHabitatList>>,
          TError,
          Awaited<ReturnType<typeof pokemonHabitatList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePokemonHabitatList<
  TData = Awaited<ReturnType<typeof pokemonHabitatList>>,
  TError = AxiosError<unknown>,
>(
  params?: PokemonHabitatListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokemonHabitatList>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonHabitatList>>,
          TError,
          Awaited<ReturnType<typeof pokemonHabitatList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePokemonHabitatList<
  TData = Awaited<ReturnType<typeof pokemonHabitatList>>,
  TError = AxiosError<unknown>,
>(
  params?: PokemonHabitatListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokemonHabitatList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List pokemom habitas
 */

export function usePokemonHabitatList<
  TData = Awaited<ReturnType<typeof pokemonHabitatList>>,
  TError = AxiosError<unknown>,
>(
  params?: PokemonHabitatListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokemonHabitatList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getPokemonHabitatListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Habitats are generally different terrain Pok√©mon can be found in but can also be areas designated for rare or legendary Pok√©mon.
 * @summary Get pokemom habita
 */
export const pokemonHabitatRetrieve = (
  id: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PokemonHabitatDetail>> => {
  return axios.default.get(
    `https://pokeapi.co/api/v2/pokemon-habitat/${id}`,
    options,
  );
};

export const getPokemonHabitatRetrieveQueryKey = (id: string) => {
  return [`https://pokeapi.co/api/v2/pokemon-habitat/${id}`] as const;
};

export const getPokemonHabitatRetrieveInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof pokemonHabitatRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokemonHabitatRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getPokemonHabitatRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof pokemonHabitatRetrieve>>
  > = ({ signal }) => pokemonHabitatRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof pokemonHabitatRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PokemonHabitatRetrieveInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof pokemonHabitatRetrieve>>
>;
export type PokemonHabitatRetrieveInfiniteQueryError = AxiosError<unknown>;

export function usePokemonHabitatRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof pokemonHabitatRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokemonHabitatRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonHabitatRetrieve>>,
          TError,
          Awaited<ReturnType<typeof pokemonHabitatRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePokemonHabitatRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof pokemonHabitatRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokemonHabitatRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonHabitatRetrieve>>,
          TError,
          Awaited<ReturnType<typeof pokemonHabitatRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePokemonHabitatRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof pokemonHabitatRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokemonHabitatRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get pokemom habita
 */

export function usePokemonHabitatRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof pokemonHabitatRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokemonHabitatRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getPokemonHabitatRetrieveInfiniteQueryOptions(
    id,
    options,
  );

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getPokemonHabitatRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof pokemonHabitatRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokemonHabitatRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getPokemonHabitatRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof pokemonHabitatRetrieve>>
  > = ({ signal }) => pokemonHabitatRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof pokemonHabitatRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PokemonHabitatRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof pokemonHabitatRetrieve>>
>;
export type PokemonHabitatRetrieveQueryError = AxiosError<unknown>;

export function usePokemonHabitatRetrieve<
  TData = Awaited<ReturnType<typeof pokemonHabitatRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokemonHabitatRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonHabitatRetrieve>>,
          TError,
          Awaited<ReturnType<typeof pokemonHabitatRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePokemonHabitatRetrieve<
  TData = Awaited<ReturnType<typeof pokemonHabitatRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokemonHabitatRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonHabitatRetrieve>>,
          TError,
          Awaited<ReturnType<typeof pokemonHabitatRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePokemonHabitatRetrieve<
  TData = Awaited<ReturnType<typeof pokemonHabitatRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokemonHabitatRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get pokemom habita
 */

export function usePokemonHabitatRetrieve<
  TData = Awaited<ReturnType<typeof pokemonHabitatRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokemonHabitatRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getPokemonHabitatRetrieveQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Shapes used for sorting Pok√©mon in a Pok√©dex.
 * @summary List pokemon shapes
 */
export const pokemonShapeList = (
  params?: PokemonShapeListParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedPokemonShapeSummaryList>> => {
  return axios.default.get(`https://pokeapi.co/api/v2/pokemon-shape`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getPokemonShapeListQueryKey = (
  params?: PokemonShapeListParams,
) => {
  return [
    `https://pokeapi.co/api/v2/pokemon-shape`,
    ...(params ? [params] : []),
  ] as const;
};

export const getPokemonShapeListInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof pokemonShapeList>>,
    PokemonShapeListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: PokemonShapeListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokemonShapeList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof pokemonShapeList>>,
        QueryKey,
        PokemonShapeListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getPokemonShapeListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof pokemonShapeList>>,
    QueryKey,
    PokemonShapeListParams["offset"]
  > = ({ signal, pageParam }) =>
    pokemonShapeList(
      { ...params, offset: pageParam || params?.["offset"] },
      { signal, ...axiosOptions },
    );

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof pokemonShapeList>>,
    TError,
    TData,
    Awaited<ReturnType<typeof pokemonShapeList>>,
    QueryKey,
    PokemonShapeListParams["offset"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PokemonShapeListInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof pokemonShapeList>>
>;
export type PokemonShapeListInfiniteQueryError = AxiosError<unknown>;

export function usePokemonShapeListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof pokemonShapeList>>,
    PokemonShapeListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params: undefined | PokemonShapeListParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokemonShapeList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof pokemonShapeList>>,
        QueryKey,
        PokemonShapeListParams["offset"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonShapeList>>,
          TError,
          Awaited<ReturnType<typeof pokemonShapeList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePokemonShapeListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof pokemonShapeList>>,
    PokemonShapeListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: PokemonShapeListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokemonShapeList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof pokemonShapeList>>,
        QueryKey,
        PokemonShapeListParams["offset"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonShapeList>>,
          TError,
          Awaited<ReturnType<typeof pokemonShapeList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePokemonShapeListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof pokemonShapeList>>,
    PokemonShapeListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: PokemonShapeListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokemonShapeList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof pokemonShapeList>>,
        QueryKey,
        PokemonShapeListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List pokemon shapes
 */

export function usePokemonShapeListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof pokemonShapeList>>,
    PokemonShapeListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: PokemonShapeListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokemonShapeList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof pokemonShapeList>>,
        QueryKey,
        PokemonShapeListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getPokemonShapeListInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getPokemonShapeListQueryOptions = <
  TData = Awaited<ReturnType<typeof pokemonShapeList>>,
  TError = AxiosError<unknown>,
>(
  params?: PokemonShapeListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokemonShapeList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getPokemonShapeListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof pokemonShapeList>>
  > = ({ signal }) => pokemonShapeList(params, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof pokemonShapeList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PokemonShapeListQueryResult = NonNullable<
  Awaited<ReturnType<typeof pokemonShapeList>>
>;
export type PokemonShapeListQueryError = AxiosError<unknown>;

export function usePokemonShapeList<
  TData = Awaited<ReturnType<typeof pokemonShapeList>>,
  TError = AxiosError<unknown>,
>(
  params: undefined | PokemonShapeListParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokemonShapeList>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonShapeList>>,
          TError,
          Awaited<ReturnType<typeof pokemonShapeList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePokemonShapeList<
  TData = Awaited<ReturnType<typeof pokemonShapeList>>,
  TError = AxiosError<unknown>,
>(
  params?: PokemonShapeListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokemonShapeList>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonShapeList>>,
          TError,
          Awaited<ReturnType<typeof pokemonShapeList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePokemonShapeList<
  TData = Awaited<ReturnType<typeof pokemonShapeList>>,
  TError = AxiosError<unknown>,
>(
  params?: PokemonShapeListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokemonShapeList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List pokemon shapes
 */

export function usePokemonShapeList<
  TData = Awaited<ReturnType<typeof pokemonShapeList>>,
  TError = AxiosError<unknown>,
>(
  params?: PokemonShapeListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokemonShapeList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getPokemonShapeListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Shapes used for sorting Pok√©mon in a Pok√©dex.
 * @summary Get pokemon shape
 */
export const pokemonShapeRetrieve = (
  id: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PokemonShapeDetail>> => {
  return axios.default.get(
    `https://pokeapi.co/api/v2/pokemon-shape/${id}`,
    options,
  );
};

export const getPokemonShapeRetrieveQueryKey = (id: string) => {
  return [`https://pokeapi.co/api/v2/pokemon-shape/${id}`] as const;
};

export const getPokemonShapeRetrieveInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof pokemonShapeRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokemonShapeRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getPokemonShapeRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof pokemonShapeRetrieve>>
  > = ({ signal }) => pokemonShapeRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof pokemonShapeRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PokemonShapeRetrieveInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof pokemonShapeRetrieve>>
>;
export type PokemonShapeRetrieveInfiniteQueryError = AxiosError<unknown>;

export function usePokemonShapeRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof pokemonShapeRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokemonShapeRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonShapeRetrieve>>,
          TError,
          Awaited<ReturnType<typeof pokemonShapeRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePokemonShapeRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof pokemonShapeRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokemonShapeRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonShapeRetrieve>>,
          TError,
          Awaited<ReturnType<typeof pokemonShapeRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePokemonShapeRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof pokemonShapeRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokemonShapeRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get pokemon shape
 */

export function usePokemonShapeRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof pokemonShapeRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokemonShapeRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getPokemonShapeRetrieveInfiniteQueryOptions(id, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getPokemonShapeRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof pokemonShapeRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokemonShapeRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getPokemonShapeRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof pokemonShapeRetrieve>>
  > = ({ signal }) => pokemonShapeRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof pokemonShapeRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PokemonShapeRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof pokemonShapeRetrieve>>
>;
export type PokemonShapeRetrieveQueryError = AxiosError<unknown>;

export function usePokemonShapeRetrieve<
  TData = Awaited<ReturnType<typeof pokemonShapeRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokemonShapeRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonShapeRetrieve>>,
          TError,
          Awaited<ReturnType<typeof pokemonShapeRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePokemonShapeRetrieve<
  TData = Awaited<ReturnType<typeof pokemonShapeRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokemonShapeRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonShapeRetrieve>>,
          TError,
          Awaited<ReturnType<typeof pokemonShapeRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePokemonShapeRetrieve<
  TData = Awaited<ReturnType<typeof pokemonShapeRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokemonShapeRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get pokemon shape
 */

export function usePokemonShapeRetrieve<
  TData = Awaited<ReturnType<typeof pokemonShapeRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokemonShapeRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getPokemonShapeRetrieveQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * A Pok√©mon Species forms the basis for at least one Pok√©mon. Attributes of a Pok√©mon species are shared across all varieties of Pok√©mon within the species. A good example is Wormadam; Wormadam is the species which can be found in three different varieties, Wormadam-Trash, Wormadam-Sandy and Wormadam-Plant.
 * @summary List pokemon species
 */
export const pokemonSpeciesList = (
  params?: PokemonSpeciesListParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedPokemonSpeciesSummaryList>> => {
  return axios.default.get(`https://pokeapi.co/api/v2/pokemon-species`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getPokemonSpeciesListQueryKey = (
  params?: PokemonSpeciesListParams,
) => {
  return [
    `https://pokeapi.co/api/v2/pokemon-species`,
    ...(params ? [params] : []),
  ] as const;
};

export const getPokemonSpeciesListInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof pokemonSpeciesList>>,
    PokemonSpeciesListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: PokemonSpeciesListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokemonSpeciesList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof pokemonSpeciesList>>,
        QueryKey,
        PokemonSpeciesListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getPokemonSpeciesListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof pokemonSpeciesList>>,
    QueryKey,
    PokemonSpeciesListParams["offset"]
  > = ({ signal, pageParam }) =>
    pokemonSpeciesList(
      { ...params, offset: pageParam || params?.["offset"] },
      { signal, ...axiosOptions },
    );

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof pokemonSpeciesList>>,
    TError,
    TData,
    Awaited<ReturnType<typeof pokemonSpeciesList>>,
    QueryKey,
    PokemonSpeciesListParams["offset"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PokemonSpeciesListInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof pokemonSpeciesList>>
>;
export type PokemonSpeciesListInfiniteQueryError = AxiosError<unknown>;

export function usePokemonSpeciesListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof pokemonSpeciesList>>,
    PokemonSpeciesListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params: undefined | PokemonSpeciesListParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokemonSpeciesList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof pokemonSpeciesList>>,
        QueryKey,
        PokemonSpeciesListParams["offset"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonSpeciesList>>,
          TError,
          Awaited<ReturnType<typeof pokemonSpeciesList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePokemonSpeciesListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof pokemonSpeciesList>>,
    PokemonSpeciesListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: PokemonSpeciesListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokemonSpeciesList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof pokemonSpeciesList>>,
        QueryKey,
        PokemonSpeciesListParams["offset"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonSpeciesList>>,
          TError,
          Awaited<ReturnType<typeof pokemonSpeciesList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePokemonSpeciesListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof pokemonSpeciesList>>,
    PokemonSpeciesListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: PokemonSpeciesListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokemonSpeciesList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof pokemonSpeciesList>>,
        QueryKey,
        PokemonSpeciesListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List pokemon species
 */

export function usePokemonSpeciesListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof pokemonSpeciesList>>,
    PokemonSpeciesListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: PokemonSpeciesListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokemonSpeciesList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof pokemonSpeciesList>>,
        QueryKey,
        PokemonSpeciesListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getPokemonSpeciesListInfiniteQueryOptions(
    params,
    options,
  );

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getPokemonSpeciesListQueryOptions = <
  TData = Awaited<ReturnType<typeof pokemonSpeciesList>>,
  TError = AxiosError<unknown>,
>(
  params?: PokemonSpeciesListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokemonSpeciesList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getPokemonSpeciesListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof pokemonSpeciesList>>
  > = ({ signal }) => pokemonSpeciesList(params, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof pokemonSpeciesList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PokemonSpeciesListQueryResult = NonNullable<
  Awaited<ReturnType<typeof pokemonSpeciesList>>
>;
export type PokemonSpeciesListQueryError = AxiosError<unknown>;

export function usePokemonSpeciesList<
  TData = Awaited<ReturnType<typeof pokemonSpeciesList>>,
  TError = AxiosError<unknown>,
>(
  params: undefined | PokemonSpeciesListParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokemonSpeciesList>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonSpeciesList>>,
          TError,
          Awaited<ReturnType<typeof pokemonSpeciesList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePokemonSpeciesList<
  TData = Awaited<ReturnType<typeof pokemonSpeciesList>>,
  TError = AxiosError<unknown>,
>(
  params?: PokemonSpeciesListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokemonSpeciesList>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonSpeciesList>>,
          TError,
          Awaited<ReturnType<typeof pokemonSpeciesList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePokemonSpeciesList<
  TData = Awaited<ReturnType<typeof pokemonSpeciesList>>,
  TError = AxiosError<unknown>,
>(
  params?: PokemonSpeciesListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokemonSpeciesList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List pokemon species
 */

export function usePokemonSpeciesList<
  TData = Awaited<ReturnType<typeof pokemonSpeciesList>>,
  TError = AxiosError<unknown>,
>(
  params?: PokemonSpeciesListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokemonSpeciesList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getPokemonSpeciesListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * A Pok√©mon Species forms the basis for at least one Pok√©mon. Attributes of a Pok√©mon species are shared across all varieties of Pok√©mon within the species. A good example is Wormadam; Wormadam is the species which can be found in three different varieties, Wormadam-Trash, Wormadam-Sandy and Wormadam-Plant.
 * @summary Get pokemon species
 */
export const pokemonSpeciesRetrieve = (
  id: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PokemonSpeciesDetail>> => {
  return axios.default.get(
    `https://pokeapi.co/api/v2/pokemon-species/${id}`,
    options,
  );
};

export const getPokemonSpeciesRetrieveQueryKey = (id: string) => {
  return [`https://pokeapi.co/api/v2/pokemon-species/${id}`] as const;
};

export const getPokemonSpeciesRetrieveInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof pokemonSpeciesRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokemonSpeciesRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getPokemonSpeciesRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof pokemonSpeciesRetrieve>>
  > = ({ signal }) => pokemonSpeciesRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof pokemonSpeciesRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PokemonSpeciesRetrieveInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof pokemonSpeciesRetrieve>>
>;
export type PokemonSpeciesRetrieveInfiniteQueryError = AxiosError<unknown>;

export function usePokemonSpeciesRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof pokemonSpeciesRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokemonSpeciesRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonSpeciesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof pokemonSpeciesRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePokemonSpeciesRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof pokemonSpeciesRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokemonSpeciesRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonSpeciesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof pokemonSpeciesRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePokemonSpeciesRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof pokemonSpeciesRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokemonSpeciesRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get pokemon species
 */

export function usePokemonSpeciesRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof pokemonSpeciesRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokemonSpeciesRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getPokemonSpeciesRetrieveInfiniteQueryOptions(
    id,
    options,
  );

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getPokemonSpeciesRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof pokemonSpeciesRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokemonSpeciesRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getPokemonSpeciesRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof pokemonSpeciesRetrieve>>
  > = ({ signal }) => pokemonSpeciesRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof pokemonSpeciesRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PokemonSpeciesRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof pokemonSpeciesRetrieve>>
>;
export type PokemonSpeciesRetrieveQueryError = AxiosError<unknown>;

export function usePokemonSpeciesRetrieve<
  TData = Awaited<ReturnType<typeof pokemonSpeciesRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokemonSpeciesRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonSpeciesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof pokemonSpeciesRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePokemonSpeciesRetrieve<
  TData = Awaited<ReturnType<typeof pokemonSpeciesRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokemonSpeciesRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonSpeciesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof pokemonSpeciesRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePokemonSpeciesRetrieve<
  TData = Awaited<ReturnType<typeof pokemonSpeciesRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokemonSpeciesRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get pokemon species
 */

export function usePokemonSpeciesRetrieve<
  TData = Awaited<ReturnType<typeof pokemonSpeciesRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokemonSpeciesRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getPokemonSpeciesRetrieveQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Pokeathlon Stats are different attributes of a Pok√©mon's performance in Pok√©athlons. In Pok√©athlons, competitions happen on different courses; one for each of the different Pok√©athlon stats. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Pok%C3%A9athlon) for greater detail.
 * @summary List pokeathlon stats
 */
export const pokeathlonStatList = (
  params?: PokeathlonStatListParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedPokeathlonStatSummaryList>> => {
  return axios.default.get(`https://pokeapi.co/api/v2/pokeathlon-stat`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getPokeathlonStatListQueryKey = (
  params?: PokeathlonStatListParams,
) => {
  return [
    `https://pokeapi.co/api/v2/pokeathlon-stat`,
    ...(params ? [params] : []),
  ] as const;
};

export const getPokeathlonStatListInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof pokeathlonStatList>>,
    PokeathlonStatListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: PokeathlonStatListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokeathlonStatList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof pokeathlonStatList>>,
        QueryKey,
        PokeathlonStatListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getPokeathlonStatListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof pokeathlonStatList>>,
    QueryKey,
    PokeathlonStatListParams["offset"]
  > = ({ signal, pageParam }) =>
    pokeathlonStatList(
      { ...params, offset: pageParam || params?.["offset"] },
      { signal, ...axiosOptions },
    );

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof pokeathlonStatList>>,
    TError,
    TData,
    Awaited<ReturnType<typeof pokeathlonStatList>>,
    QueryKey,
    PokeathlonStatListParams["offset"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PokeathlonStatListInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof pokeathlonStatList>>
>;
export type PokeathlonStatListInfiniteQueryError = AxiosError<unknown>;

export function usePokeathlonStatListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof pokeathlonStatList>>,
    PokeathlonStatListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params: undefined | PokeathlonStatListParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokeathlonStatList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof pokeathlonStatList>>,
        QueryKey,
        PokeathlonStatListParams["offset"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokeathlonStatList>>,
          TError,
          Awaited<ReturnType<typeof pokeathlonStatList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePokeathlonStatListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof pokeathlonStatList>>,
    PokeathlonStatListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: PokeathlonStatListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokeathlonStatList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof pokeathlonStatList>>,
        QueryKey,
        PokeathlonStatListParams["offset"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokeathlonStatList>>,
          TError,
          Awaited<ReturnType<typeof pokeathlonStatList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePokeathlonStatListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof pokeathlonStatList>>,
    PokeathlonStatListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: PokeathlonStatListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokeathlonStatList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof pokeathlonStatList>>,
        QueryKey,
        PokeathlonStatListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List pokeathlon stats
 */

export function usePokeathlonStatListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof pokeathlonStatList>>,
    PokeathlonStatListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: PokeathlonStatListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokeathlonStatList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof pokeathlonStatList>>,
        QueryKey,
        PokeathlonStatListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getPokeathlonStatListInfiniteQueryOptions(
    params,
    options,
  );

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getPokeathlonStatListQueryOptions = <
  TData = Awaited<ReturnType<typeof pokeathlonStatList>>,
  TError = AxiosError<unknown>,
>(
  params?: PokeathlonStatListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokeathlonStatList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getPokeathlonStatListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof pokeathlonStatList>>
  > = ({ signal }) => pokeathlonStatList(params, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof pokeathlonStatList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PokeathlonStatListQueryResult = NonNullable<
  Awaited<ReturnType<typeof pokeathlonStatList>>
>;
export type PokeathlonStatListQueryError = AxiosError<unknown>;

export function usePokeathlonStatList<
  TData = Awaited<ReturnType<typeof pokeathlonStatList>>,
  TError = AxiosError<unknown>,
>(
  params: undefined | PokeathlonStatListParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokeathlonStatList>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokeathlonStatList>>,
          TError,
          Awaited<ReturnType<typeof pokeathlonStatList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePokeathlonStatList<
  TData = Awaited<ReturnType<typeof pokeathlonStatList>>,
  TError = AxiosError<unknown>,
>(
  params?: PokeathlonStatListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokeathlonStatList>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokeathlonStatList>>,
          TError,
          Awaited<ReturnType<typeof pokeathlonStatList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePokeathlonStatList<
  TData = Awaited<ReturnType<typeof pokeathlonStatList>>,
  TError = AxiosError<unknown>,
>(
  params?: PokeathlonStatListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokeathlonStatList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List pokeathlon stats
 */

export function usePokeathlonStatList<
  TData = Awaited<ReturnType<typeof pokeathlonStatList>>,
  TError = AxiosError<unknown>,
>(
  params?: PokeathlonStatListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokeathlonStatList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getPokeathlonStatListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Pokeathlon Stats are different attributes of a Pok√©mon's performance in Pok√©athlons. In Pok√©athlons, competitions happen on different courses; one for each of the different Pok√©athlon stats. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Pok%C3%A9athlon) for greater detail.
 * @summary Get pokeathlon stat
 */
export const pokeathlonStatRetrieve = (
  id: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PokeathlonStatDetail>> => {
  return axios.default.get(
    `https://pokeapi.co/api/v2/pokeathlon-stat/${id}`,
    options,
  );
};

export const getPokeathlonStatRetrieveQueryKey = (id: string) => {
  return [`https://pokeapi.co/api/v2/pokeathlon-stat/${id}`] as const;
};

export const getPokeathlonStatRetrieveInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof pokeathlonStatRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokeathlonStatRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getPokeathlonStatRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof pokeathlonStatRetrieve>>
  > = ({ signal }) => pokeathlonStatRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof pokeathlonStatRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PokeathlonStatRetrieveInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof pokeathlonStatRetrieve>>
>;
export type PokeathlonStatRetrieveInfiniteQueryError = AxiosError<unknown>;

export function usePokeathlonStatRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof pokeathlonStatRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokeathlonStatRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokeathlonStatRetrieve>>,
          TError,
          Awaited<ReturnType<typeof pokeathlonStatRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePokeathlonStatRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof pokeathlonStatRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokeathlonStatRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokeathlonStatRetrieve>>,
          TError,
          Awaited<ReturnType<typeof pokeathlonStatRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePokeathlonStatRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof pokeathlonStatRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokeathlonStatRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get pokeathlon stat
 */

export function usePokeathlonStatRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof pokeathlonStatRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokeathlonStatRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getPokeathlonStatRetrieveInfiniteQueryOptions(
    id,
    options,
  );

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getPokeathlonStatRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof pokeathlonStatRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokeathlonStatRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getPokeathlonStatRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof pokeathlonStatRetrieve>>
  > = ({ signal }) => pokeathlonStatRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof pokeathlonStatRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PokeathlonStatRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof pokeathlonStatRetrieve>>
>;
export type PokeathlonStatRetrieveQueryError = AxiosError<unknown>;

export function usePokeathlonStatRetrieve<
  TData = Awaited<ReturnType<typeof pokeathlonStatRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokeathlonStatRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokeathlonStatRetrieve>>,
          TError,
          Awaited<ReturnType<typeof pokeathlonStatRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePokeathlonStatRetrieve<
  TData = Awaited<ReturnType<typeof pokeathlonStatRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokeathlonStatRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokeathlonStatRetrieve>>,
          TError,
          Awaited<ReturnType<typeof pokeathlonStatRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePokeathlonStatRetrieve<
  TData = Awaited<ReturnType<typeof pokeathlonStatRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokeathlonStatRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get pokeathlon stat
 */

export function usePokeathlonStatRetrieve<
  TData = Awaited<ReturnType<typeof pokeathlonStatRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokeathlonStatRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getPokeathlonStatRetrieveQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * A region is an organized area of the Pok√©mon world. Most often, the main difference between regions is the species of Pok√©mon that can be encountered within them.
 * @summary List regions
 */
export const regionList = (
  params?: RegionListParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedRegionSummaryList>> => {
  return axios.default.get(`https://pokeapi.co/api/v2/region`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getRegionListQueryKey = (params?: RegionListParams) => {
  return [
    `https://pokeapi.co/api/v2/region`,
    ...(params ? [params] : []),
  ] as const;
};

export const getRegionListInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof regionList>>,
    RegionListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: RegionListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof regionList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof regionList>>,
        QueryKey,
        RegionListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getRegionListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof regionList>>,
    QueryKey,
    RegionListParams["offset"]
  > = ({ signal, pageParam }) =>
    regionList(
      { ...params, offset: pageParam || params?.["offset"] },
      { signal, ...axiosOptions },
    );

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof regionList>>,
    TError,
    TData,
    Awaited<ReturnType<typeof regionList>>,
    QueryKey,
    RegionListParams["offset"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RegionListInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof regionList>>
>;
export type RegionListInfiniteQueryError = AxiosError<unknown>;

export function useRegionListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof regionList>>,
    RegionListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params: undefined | RegionListParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof regionList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof regionList>>,
        QueryKey,
        RegionListParams["offset"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof regionList>>,
          TError,
          Awaited<ReturnType<typeof regionList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useRegionListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof regionList>>,
    RegionListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: RegionListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof regionList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof regionList>>,
        QueryKey,
        RegionListParams["offset"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof regionList>>,
          TError,
          Awaited<ReturnType<typeof regionList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useRegionListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof regionList>>,
    RegionListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: RegionListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof regionList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof regionList>>,
        QueryKey,
        RegionListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List regions
 */

export function useRegionListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof regionList>>,
    RegionListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: RegionListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof regionList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof regionList>>,
        QueryKey,
        RegionListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getRegionListInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getRegionListQueryOptions = <
  TData = Awaited<ReturnType<typeof regionList>>,
  TError = AxiosError<unknown>,
>(
  params?: RegionListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof regionList>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getRegionListQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof regionList>>> = ({
    signal,
  }) => regionList(params, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof regionList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RegionListQueryResult = NonNullable<
  Awaited<ReturnType<typeof regionList>>
>;
export type RegionListQueryError = AxiosError<unknown>;

export function useRegionList<
  TData = Awaited<ReturnType<typeof regionList>>,
  TError = AxiosError<unknown>,
>(
  params: undefined | RegionListParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof regionList>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof regionList>>,
          TError,
          Awaited<ReturnType<typeof regionList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useRegionList<
  TData = Awaited<ReturnType<typeof regionList>>,
  TError = AxiosError<unknown>,
>(
  params?: RegionListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof regionList>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof regionList>>,
          TError,
          Awaited<ReturnType<typeof regionList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useRegionList<
  TData = Awaited<ReturnType<typeof regionList>>,
  TError = AxiosError<unknown>,
>(
  params?: RegionListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof regionList>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List regions
 */

export function useRegionList<
  TData = Awaited<ReturnType<typeof regionList>>,
  TError = AxiosError<unknown>,
>(
  params?: RegionListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof regionList>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getRegionListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * A region is an organized area of the Pok√©mon world. Most often, the main difference between regions is the species of Pok√©mon that can be encountered within them.
 * @summary Get region
 */
export const regionRetrieve = (
  id: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<RegionDetail>> => {
  return axios.default.get(`https://pokeapi.co/api/v2/region/${id}`, options);
};

export const getRegionRetrieveQueryKey = (id: string) => {
  return [`https://pokeapi.co/api/v2/region/${id}`] as const;
};

export const getRegionRetrieveInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof regionRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof regionRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getRegionRetrieveQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof regionRetrieve>>> = ({
    signal,
  }) => regionRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof regionRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RegionRetrieveInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof regionRetrieve>>
>;
export type RegionRetrieveInfiniteQueryError = AxiosError<unknown>;

export function useRegionRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof regionRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof regionRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof regionRetrieve>>,
          TError,
          Awaited<ReturnType<typeof regionRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useRegionRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof regionRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof regionRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof regionRetrieve>>,
          TError,
          Awaited<ReturnType<typeof regionRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useRegionRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof regionRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof regionRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get region
 */

export function useRegionRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof regionRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof regionRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getRegionRetrieveInfiniteQueryOptions(id, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getRegionRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof regionRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof regionRetrieve>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getRegionRetrieveQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof regionRetrieve>>> = ({
    signal,
  }) => regionRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof regionRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RegionRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof regionRetrieve>>
>;
export type RegionRetrieveQueryError = AxiosError<unknown>;

export function useRegionRetrieve<
  TData = Awaited<ReturnType<typeof regionRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof regionRetrieve>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof regionRetrieve>>,
          TError,
          Awaited<ReturnType<typeof regionRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useRegionRetrieve<
  TData = Awaited<ReturnType<typeof regionRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof regionRetrieve>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof regionRetrieve>>,
          TError,
          Awaited<ReturnType<typeof regionRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useRegionRetrieve<
  TData = Awaited<ReturnType<typeof regionRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof regionRetrieve>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get region
 */

export function useRegionRetrieve<
  TData = Awaited<ReturnType<typeof regionRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof regionRetrieve>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getRegionRetrieveQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Stats determine certain aspects of battles. Each Pok√©mon has a value for each stat which grows as they gain levels and can be altered momentarily by effects in battles.
 * @summary List stats
 */
export const statList = (
  params?: StatListParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedStatSummaryList>> => {
  return axios.default.get(`https://pokeapi.co/api/v2/stat`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getStatListQueryKey = (params?: StatListParams) => {
  return [
    `https://pokeapi.co/api/v2/stat`,
    ...(params ? [params] : []),
  ] as const;
};

export const getStatListInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof statList>>,
    StatListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: StatListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof statList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof statList>>,
        QueryKey,
        StatListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getStatListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof statList>>,
    QueryKey,
    StatListParams["offset"]
  > = ({ signal, pageParam }) =>
    statList(
      { ...params, offset: pageParam || params?.["offset"] },
      { signal, ...axiosOptions },
    );

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof statList>>,
    TError,
    TData,
    Awaited<ReturnType<typeof statList>>,
    QueryKey,
    StatListParams["offset"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type StatListInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof statList>>
>;
export type StatListInfiniteQueryError = AxiosError<unknown>;

export function useStatListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof statList>>,
    StatListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params: undefined | StatListParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof statList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof statList>>,
        QueryKey,
        StatListParams["offset"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof statList>>,
          TError,
          Awaited<ReturnType<typeof statList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useStatListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof statList>>,
    StatListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: StatListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof statList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof statList>>,
        QueryKey,
        StatListParams["offset"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof statList>>,
          TError,
          Awaited<ReturnType<typeof statList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useStatListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof statList>>,
    StatListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: StatListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof statList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof statList>>,
        QueryKey,
        StatListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List stats
 */

export function useStatListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof statList>>,
    StatListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: StatListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof statList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof statList>>,
        QueryKey,
        StatListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getStatListInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getStatListQueryOptions = <
  TData = Awaited<ReturnType<typeof statList>>,
  TError = AxiosError<unknown>,
>(
  params?: StatListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof statList>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getStatListQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof statList>>> = ({
    signal,
  }) => statList(params, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof statList>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type StatListQueryResult = NonNullable<
  Awaited<ReturnType<typeof statList>>
>;
export type StatListQueryError = AxiosError<unknown>;

export function useStatList<
  TData = Awaited<ReturnType<typeof statList>>,
  TError = AxiosError<unknown>,
>(
  params: undefined | StatListParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof statList>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof statList>>,
          TError,
          Awaited<ReturnType<typeof statList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useStatList<
  TData = Awaited<ReturnType<typeof statList>>,
  TError = AxiosError<unknown>,
>(
  params?: StatListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof statList>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof statList>>,
          TError,
          Awaited<ReturnType<typeof statList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useStatList<
  TData = Awaited<ReturnType<typeof statList>>,
  TError = AxiosError<unknown>,
>(
  params?: StatListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof statList>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List stats
 */

export function useStatList<
  TData = Awaited<ReturnType<typeof statList>>,
  TError = AxiosError<unknown>,
>(
  params?: StatListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof statList>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getStatListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Stats determine certain aspects of battles. Each Pok√©mon has a value for each stat which grows as they gain levels and can be altered momentarily by effects in battles.
 * @summary Get stat
 */
export const statRetrieve = (
  id: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<StatDetail>> => {
  return axios.default.get(`https://pokeapi.co/api/v2/stat/${id}`, options);
};

export const getStatRetrieveQueryKey = (id: string) => {
  return [`https://pokeapi.co/api/v2/stat/${id}`] as const;
};

export const getStatRetrieveInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof statRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof statRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getStatRetrieveQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof statRetrieve>>> = ({
    signal,
  }) => statRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof statRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type StatRetrieveInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof statRetrieve>>
>;
export type StatRetrieveInfiniteQueryError = AxiosError<unknown>;

export function useStatRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof statRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof statRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof statRetrieve>>,
          TError,
          Awaited<ReturnType<typeof statRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useStatRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof statRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof statRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof statRetrieve>>,
          TError,
          Awaited<ReturnType<typeof statRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useStatRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof statRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof statRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get stat
 */

export function useStatRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof statRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof statRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getStatRetrieveInfiniteQueryOptions(id, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getStatRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof statRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof statRetrieve>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getStatRetrieveQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof statRetrieve>>> = ({
    signal,
  }) => statRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof statRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type StatRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof statRetrieve>>
>;
export type StatRetrieveQueryError = AxiosError<unknown>;

export function useStatRetrieve<
  TData = Awaited<ReturnType<typeof statRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof statRetrieve>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof statRetrieve>>,
          TError,
          Awaited<ReturnType<typeof statRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useStatRetrieve<
  TData = Awaited<ReturnType<typeof statRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof statRetrieve>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof statRetrieve>>,
          TError,
          Awaited<ReturnType<typeof statRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useStatRetrieve<
  TData = Awaited<ReturnType<typeof statRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof statRetrieve>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get stat
 */

export function useStatRetrieve<
  TData = Awaited<ReturnType<typeof statRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof statRetrieve>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getStatRetrieveQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Super contest effects refer to the effects of moves when used in super contests.
 * @summary List super contest effects
 */
export const superContestEffectList = (
  params?: SuperContestEffectListParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedSuperContestEffectSummaryList>> => {
  return axios.default.get(`https://pokeapi.co/api/v2/super-contest-effect`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getSuperContestEffectListQueryKey = (
  params?: SuperContestEffectListParams,
) => {
  return [
    `https://pokeapi.co/api/v2/super-contest-effect`,
    ...(params ? [params] : []),
  ] as const;
};

export const getSuperContestEffectListInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof superContestEffectList>>,
    SuperContestEffectListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: SuperContestEffectListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof superContestEffectList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof superContestEffectList>>,
        QueryKey,
        SuperContestEffectListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getSuperContestEffectListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof superContestEffectList>>,
    QueryKey,
    SuperContestEffectListParams["offset"]
  > = ({ signal, pageParam }) =>
    superContestEffectList(
      { ...params, offset: pageParam || params?.["offset"] },
      { signal, ...axiosOptions },
    );

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof superContestEffectList>>,
    TError,
    TData,
    Awaited<ReturnType<typeof superContestEffectList>>,
    QueryKey,
    SuperContestEffectListParams["offset"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SuperContestEffectListInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof superContestEffectList>>
>;
export type SuperContestEffectListInfiniteQueryError = AxiosError<unknown>;

export function useSuperContestEffectListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof superContestEffectList>>,
    SuperContestEffectListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params: undefined | SuperContestEffectListParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof superContestEffectList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof superContestEffectList>>,
        QueryKey,
        SuperContestEffectListParams["offset"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof superContestEffectList>>,
          TError,
          Awaited<ReturnType<typeof superContestEffectList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSuperContestEffectListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof superContestEffectList>>,
    SuperContestEffectListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: SuperContestEffectListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof superContestEffectList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof superContestEffectList>>,
        QueryKey,
        SuperContestEffectListParams["offset"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof superContestEffectList>>,
          TError,
          Awaited<ReturnType<typeof superContestEffectList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSuperContestEffectListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof superContestEffectList>>,
    SuperContestEffectListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: SuperContestEffectListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof superContestEffectList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof superContestEffectList>>,
        QueryKey,
        SuperContestEffectListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List super contest effects
 */

export function useSuperContestEffectListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof superContestEffectList>>,
    SuperContestEffectListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: SuperContestEffectListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof superContestEffectList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof superContestEffectList>>,
        QueryKey,
        SuperContestEffectListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getSuperContestEffectListInfiniteQueryOptions(
    params,
    options,
  );

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getSuperContestEffectListQueryOptions = <
  TData = Awaited<ReturnType<typeof superContestEffectList>>,
  TError = AxiosError<unknown>,
>(
  params?: SuperContestEffectListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof superContestEffectList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getSuperContestEffectListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof superContestEffectList>>
  > = ({ signal }) =>
    superContestEffectList(params, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof superContestEffectList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SuperContestEffectListQueryResult = NonNullable<
  Awaited<ReturnType<typeof superContestEffectList>>
>;
export type SuperContestEffectListQueryError = AxiosError<unknown>;

export function useSuperContestEffectList<
  TData = Awaited<ReturnType<typeof superContestEffectList>>,
  TError = AxiosError<unknown>,
>(
  params: undefined | SuperContestEffectListParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof superContestEffectList>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof superContestEffectList>>,
          TError,
          Awaited<ReturnType<typeof superContestEffectList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSuperContestEffectList<
  TData = Awaited<ReturnType<typeof superContestEffectList>>,
  TError = AxiosError<unknown>,
>(
  params?: SuperContestEffectListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof superContestEffectList>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof superContestEffectList>>,
          TError,
          Awaited<ReturnType<typeof superContestEffectList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSuperContestEffectList<
  TData = Awaited<ReturnType<typeof superContestEffectList>>,
  TError = AxiosError<unknown>,
>(
  params?: SuperContestEffectListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof superContestEffectList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List super contest effects
 */

export function useSuperContestEffectList<
  TData = Awaited<ReturnType<typeof superContestEffectList>>,
  TError = AxiosError<unknown>,
>(
  params?: SuperContestEffectListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof superContestEffectList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getSuperContestEffectListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Super contest effects refer to the effects of moves when used in super contests.
 * @summary Get super contest effect
 */
export const superContestEffectRetrieve = (
  id: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<SuperContestEffectDetail>> => {
  return axios.default.get(
    `https://pokeapi.co/api/v2/super-contest-effect/${id}`,
    options,
  );
};

export const getSuperContestEffectRetrieveQueryKey = (id: string) => {
  return [`https://pokeapi.co/api/v2/super-contest-effect/${id}`] as const;
};

export const getSuperContestEffectRetrieveInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof superContestEffectRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof superContestEffectRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getSuperContestEffectRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof superContestEffectRetrieve>>
  > = ({ signal }) =>
    superContestEffectRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof superContestEffectRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SuperContestEffectRetrieveInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof superContestEffectRetrieve>>
>;
export type SuperContestEffectRetrieveInfiniteQueryError = AxiosError<unknown>;

export function useSuperContestEffectRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof superContestEffectRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof superContestEffectRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof superContestEffectRetrieve>>,
          TError,
          Awaited<ReturnType<typeof superContestEffectRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSuperContestEffectRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof superContestEffectRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof superContestEffectRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof superContestEffectRetrieve>>,
          TError,
          Awaited<ReturnType<typeof superContestEffectRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSuperContestEffectRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof superContestEffectRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof superContestEffectRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get super contest effect
 */

export function useSuperContestEffectRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof superContestEffectRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof superContestEffectRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getSuperContestEffectRetrieveInfiniteQueryOptions(
    id,
    options,
  );

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getSuperContestEffectRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof superContestEffectRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof superContestEffectRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getSuperContestEffectRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof superContestEffectRetrieve>>
  > = ({ signal }) =>
    superContestEffectRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof superContestEffectRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SuperContestEffectRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof superContestEffectRetrieve>>
>;
export type SuperContestEffectRetrieveQueryError = AxiosError<unknown>;

export function useSuperContestEffectRetrieve<
  TData = Awaited<ReturnType<typeof superContestEffectRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof superContestEffectRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof superContestEffectRetrieve>>,
          TError,
          Awaited<ReturnType<typeof superContestEffectRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSuperContestEffectRetrieve<
  TData = Awaited<ReturnType<typeof superContestEffectRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof superContestEffectRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof superContestEffectRetrieve>>,
          TError,
          Awaited<ReturnType<typeof superContestEffectRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSuperContestEffectRetrieve<
  TData = Awaited<ReturnType<typeof superContestEffectRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof superContestEffectRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get super contest effect
 */

export function useSuperContestEffectRetrieve<
  TData = Awaited<ReturnType<typeof superContestEffectRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof superContestEffectRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getSuperContestEffectRetrieveQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Types are properties for Pok√©mon and their moves. Each type has three properties: which types of Pok√©mon it is super effective against, which types of Pok√©mon it is not very effective against, and which types of Pok√©mon it is completely ineffective against.
 * @summary List types
 */
export const typeList = (
  params?: TypeListParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedTypeSummaryList>> => {
  return axios.default.get(`https://pokeapi.co/api/v2/type`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getTypeListQueryKey = (params?: TypeListParams) => {
  return [
    `https://pokeapi.co/api/v2/type`,
    ...(params ? [params] : []),
  ] as const;
};

export const getTypeListInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof typeList>>,
    TypeListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: TypeListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof typeList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof typeList>>,
        QueryKey,
        TypeListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getTypeListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof typeList>>,
    QueryKey,
    TypeListParams["offset"]
  > = ({ signal, pageParam }) =>
    typeList(
      { ...params, offset: pageParam || params?.["offset"] },
      { signal, ...axiosOptions },
    );

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof typeList>>,
    TError,
    TData,
    Awaited<ReturnType<typeof typeList>>,
    QueryKey,
    TypeListParams["offset"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type TypeListInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof typeList>>
>;
export type TypeListInfiniteQueryError = AxiosError<unknown>;

export function useTypeListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof typeList>>,
    TypeListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params: undefined | TypeListParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof typeList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof typeList>>,
        QueryKey,
        TypeListParams["offset"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof typeList>>,
          TError,
          Awaited<ReturnType<typeof typeList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useTypeListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof typeList>>,
    TypeListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: TypeListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof typeList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof typeList>>,
        QueryKey,
        TypeListParams["offset"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof typeList>>,
          TError,
          Awaited<ReturnType<typeof typeList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useTypeListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof typeList>>,
    TypeListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: TypeListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof typeList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof typeList>>,
        QueryKey,
        TypeListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List types
 */

export function useTypeListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof typeList>>,
    TypeListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: TypeListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof typeList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof typeList>>,
        QueryKey,
        TypeListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getTypeListInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getTypeListQueryOptions = <
  TData = Awaited<ReturnType<typeof typeList>>,
  TError = AxiosError<unknown>,
>(
  params?: TypeListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof typeList>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getTypeListQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof typeList>>> = ({
    signal,
  }) => typeList(params, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof typeList>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type TypeListQueryResult = NonNullable<
  Awaited<ReturnType<typeof typeList>>
>;
export type TypeListQueryError = AxiosError<unknown>;

export function useTypeList<
  TData = Awaited<ReturnType<typeof typeList>>,
  TError = AxiosError<unknown>,
>(
  params: undefined | TypeListParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof typeList>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof typeList>>,
          TError,
          Awaited<ReturnType<typeof typeList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useTypeList<
  TData = Awaited<ReturnType<typeof typeList>>,
  TError = AxiosError<unknown>,
>(
  params?: TypeListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof typeList>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof typeList>>,
          TError,
          Awaited<ReturnType<typeof typeList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useTypeList<
  TData = Awaited<ReturnType<typeof typeList>>,
  TError = AxiosError<unknown>,
>(
  params?: TypeListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof typeList>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List types
 */

export function useTypeList<
  TData = Awaited<ReturnType<typeof typeList>>,
  TError = AxiosError<unknown>,
>(
  params?: TypeListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof typeList>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getTypeListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Types are properties for Pok√©mon and their moves. Each type has three properties: which types of Pok√©mon it is super effective against, which types of Pok√©mon it is not very effective against, and which types of Pok√©mon it is completely ineffective against.
 * @summary Get types
 */
export const typeRetrieve = (
  id: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<TypeDetail>> => {
  return axios.default.get(`https://pokeapi.co/api/v2/type/${id}`, options);
};

export const getTypeRetrieveQueryKey = (id: string) => {
  return [`https://pokeapi.co/api/v2/type/${id}`] as const;
};

export const getTypeRetrieveInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof typeRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof typeRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getTypeRetrieveQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof typeRetrieve>>> = ({
    signal,
  }) => typeRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof typeRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type TypeRetrieveInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof typeRetrieve>>
>;
export type TypeRetrieveInfiniteQueryError = AxiosError<unknown>;

export function useTypeRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof typeRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof typeRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof typeRetrieve>>,
          TError,
          Awaited<ReturnType<typeof typeRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useTypeRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof typeRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof typeRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof typeRetrieve>>,
          TError,
          Awaited<ReturnType<typeof typeRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useTypeRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof typeRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof typeRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get types
 */

export function useTypeRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof typeRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof typeRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getTypeRetrieveInfiniteQueryOptions(id, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getTypeRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof typeRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof typeRetrieve>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getTypeRetrieveQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof typeRetrieve>>> = ({
    signal,
  }) => typeRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof typeRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type TypeRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof typeRetrieve>>
>;
export type TypeRetrieveQueryError = AxiosError<unknown>;

export function useTypeRetrieve<
  TData = Awaited<ReturnType<typeof typeRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof typeRetrieve>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof typeRetrieve>>,
          TError,
          Awaited<ReturnType<typeof typeRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useTypeRetrieve<
  TData = Awaited<ReturnType<typeof typeRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof typeRetrieve>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof typeRetrieve>>,
          TError,
          Awaited<ReturnType<typeof typeRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useTypeRetrieve<
  TData = Awaited<ReturnType<typeof typeRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof typeRetrieve>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get types
 */

export function useTypeRetrieve<
  TData = Awaited<ReturnType<typeof typeRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof typeRetrieve>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getTypeRetrieveQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Versions of the games, e.g., Red, Blue or Yellow.
 * @summary List versions
 */
export const versionList = (
  params?: VersionListParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedVersionSummaryList>> => {
  return axios.default.get(`https://pokeapi.co/api/v2/version`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getVersionListQueryKey = (params?: VersionListParams) => {
  return [
    `https://pokeapi.co/api/v2/version`,
    ...(params ? [params] : []),
  ] as const;
};

export const getVersionListInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof versionList>>,
    VersionListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: VersionListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof versionList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof versionList>>,
        QueryKey,
        VersionListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getVersionListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof versionList>>,
    QueryKey,
    VersionListParams["offset"]
  > = ({ signal, pageParam }) =>
    versionList(
      { ...params, offset: pageParam || params?.["offset"] },
      { signal, ...axiosOptions },
    );

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof versionList>>,
    TError,
    TData,
    Awaited<ReturnType<typeof versionList>>,
    QueryKey,
    VersionListParams["offset"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type VersionListInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof versionList>>
>;
export type VersionListInfiniteQueryError = AxiosError<unknown>;

export function useVersionListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof versionList>>,
    VersionListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params: undefined | VersionListParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof versionList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof versionList>>,
        QueryKey,
        VersionListParams["offset"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof versionList>>,
          TError,
          Awaited<ReturnType<typeof versionList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useVersionListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof versionList>>,
    VersionListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: VersionListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof versionList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof versionList>>,
        QueryKey,
        VersionListParams["offset"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof versionList>>,
          TError,
          Awaited<ReturnType<typeof versionList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useVersionListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof versionList>>,
    VersionListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: VersionListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof versionList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof versionList>>,
        QueryKey,
        VersionListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List versions
 */

export function useVersionListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof versionList>>,
    VersionListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: VersionListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof versionList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof versionList>>,
        QueryKey,
        VersionListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getVersionListInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getVersionListQueryOptions = <
  TData = Awaited<ReturnType<typeof versionList>>,
  TError = AxiosError<unknown>,
>(
  params?: VersionListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof versionList>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getVersionListQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof versionList>>> = ({
    signal,
  }) => versionList(params, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof versionList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type VersionListQueryResult = NonNullable<
  Awaited<ReturnType<typeof versionList>>
>;
export type VersionListQueryError = AxiosError<unknown>;

export function useVersionList<
  TData = Awaited<ReturnType<typeof versionList>>,
  TError = AxiosError<unknown>,
>(
  params: undefined | VersionListParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof versionList>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof versionList>>,
          TError,
          Awaited<ReturnType<typeof versionList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useVersionList<
  TData = Awaited<ReturnType<typeof versionList>>,
  TError = AxiosError<unknown>,
>(
  params?: VersionListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof versionList>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof versionList>>,
          TError,
          Awaited<ReturnType<typeof versionList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useVersionList<
  TData = Awaited<ReturnType<typeof versionList>>,
  TError = AxiosError<unknown>,
>(
  params?: VersionListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof versionList>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List versions
 */

export function useVersionList<
  TData = Awaited<ReturnType<typeof versionList>>,
  TError = AxiosError<unknown>,
>(
  params?: VersionListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof versionList>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getVersionListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Versions of the games, e.g., Red, Blue or Yellow.
 * @summary Get version
 */
export const versionRetrieve = (
  id: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<VersionDetail>> => {
  return axios.default.get(`https://pokeapi.co/api/v2/version/${id}`, options);
};

export const getVersionRetrieveQueryKey = (id: string) => {
  return [`https://pokeapi.co/api/v2/version/${id}`] as const;
};

export const getVersionRetrieveInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof versionRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof versionRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getVersionRetrieveQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof versionRetrieve>>> = ({
    signal,
  }) => versionRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof versionRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type VersionRetrieveInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof versionRetrieve>>
>;
export type VersionRetrieveInfiniteQueryError = AxiosError<unknown>;

export function useVersionRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof versionRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof versionRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof versionRetrieve>>,
          TError,
          Awaited<ReturnType<typeof versionRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useVersionRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof versionRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof versionRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof versionRetrieve>>,
          TError,
          Awaited<ReturnType<typeof versionRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useVersionRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof versionRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof versionRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get version
 */

export function useVersionRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof versionRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof versionRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getVersionRetrieveInfiniteQueryOptions(id, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getVersionRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof versionRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof versionRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getVersionRetrieveQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof versionRetrieve>>> = ({
    signal,
  }) => versionRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof versionRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type VersionRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof versionRetrieve>>
>;
export type VersionRetrieveQueryError = AxiosError<unknown>;

export function useVersionRetrieve<
  TData = Awaited<ReturnType<typeof versionRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof versionRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof versionRetrieve>>,
          TError,
          Awaited<ReturnType<typeof versionRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useVersionRetrieve<
  TData = Awaited<ReturnType<typeof versionRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof versionRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof versionRetrieve>>,
          TError,
          Awaited<ReturnType<typeof versionRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useVersionRetrieve<
  TData = Awaited<ReturnType<typeof versionRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof versionRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get version
 */

export function useVersionRetrieve<
  TData = Awaited<ReturnType<typeof versionRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof versionRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getVersionRetrieveQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Version groups categorize highly similar versions of the games.
 * @summary List version groups
 */
export const versionGroupList = (
  params?: VersionGroupListParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaginatedVersionGroupSummaryList>> => {
  return axios.default.get(`https://pokeapi.co/api/v2/version-group`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getVersionGroupListQueryKey = (
  params?: VersionGroupListParams,
) => {
  return [
    `https://pokeapi.co/api/v2/version-group`,
    ...(params ? [params] : []),
  ] as const;
};

export const getVersionGroupListInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof versionGroupList>>,
    VersionGroupListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: VersionGroupListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof versionGroupList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof versionGroupList>>,
        QueryKey,
        VersionGroupListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getVersionGroupListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof versionGroupList>>,
    QueryKey,
    VersionGroupListParams["offset"]
  > = ({ signal, pageParam }) =>
    versionGroupList(
      { ...params, offset: pageParam || params?.["offset"] },
      { signal, ...axiosOptions },
    );

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof versionGroupList>>,
    TError,
    TData,
    Awaited<ReturnType<typeof versionGroupList>>,
    QueryKey,
    VersionGroupListParams["offset"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type VersionGroupListInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof versionGroupList>>
>;
export type VersionGroupListInfiniteQueryError = AxiosError<unknown>;

export function useVersionGroupListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof versionGroupList>>,
    VersionGroupListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params: undefined | VersionGroupListParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof versionGroupList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof versionGroupList>>,
        QueryKey,
        VersionGroupListParams["offset"]
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof versionGroupList>>,
          TError,
          Awaited<ReturnType<typeof versionGroupList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useVersionGroupListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof versionGroupList>>,
    VersionGroupListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: VersionGroupListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof versionGroupList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof versionGroupList>>,
        QueryKey,
        VersionGroupListParams["offset"]
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof versionGroupList>>,
          TError,
          Awaited<ReturnType<typeof versionGroupList>>,
          QueryKey
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useVersionGroupListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof versionGroupList>>,
    VersionGroupListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: VersionGroupListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof versionGroupList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof versionGroupList>>,
        QueryKey,
        VersionGroupListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List version groups
 */

export function useVersionGroupListInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof versionGroupList>>,
    VersionGroupListParams["offset"]
  >,
  TError = AxiosError<unknown>,
>(
  params?: VersionGroupListParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof versionGroupList>>,
        TError,
        TData,
        Awaited<ReturnType<typeof versionGroupList>>,
        QueryKey,
        VersionGroupListParams["offset"]
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getVersionGroupListInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getVersionGroupListQueryOptions = <
  TData = Awaited<ReturnType<typeof versionGroupList>>,
  TError = AxiosError<unknown>,
>(
  params?: VersionGroupListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof versionGroupList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getVersionGroupListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof versionGroupList>>
  > = ({ signal }) => versionGroupList(params, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof versionGroupList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type VersionGroupListQueryResult = NonNullable<
  Awaited<ReturnType<typeof versionGroupList>>
>;
export type VersionGroupListQueryError = AxiosError<unknown>;

export function useVersionGroupList<
  TData = Awaited<ReturnType<typeof versionGroupList>>,
  TError = AxiosError<unknown>,
>(
  params: undefined | VersionGroupListParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof versionGroupList>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof versionGroupList>>,
          TError,
          Awaited<ReturnType<typeof versionGroupList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useVersionGroupList<
  TData = Awaited<ReturnType<typeof versionGroupList>>,
  TError = AxiosError<unknown>,
>(
  params?: VersionGroupListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof versionGroupList>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof versionGroupList>>,
          TError,
          Awaited<ReturnType<typeof versionGroupList>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useVersionGroupList<
  TData = Awaited<ReturnType<typeof versionGroupList>>,
  TError = AxiosError<unknown>,
>(
  params?: VersionGroupListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof versionGroupList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List version groups
 */

export function useVersionGroupList<
  TData = Awaited<ReturnType<typeof versionGroupList>>,
  TError = AxiosError<unknown>,
>(
  params?: VersionGroupListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof versionGroupList>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getVersionGroupListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Version groups categorize highly similar versions of the games.
 * @summary Get version group
 */
export const versionGroupRetrieve = (
  id: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<VersionGroupDetail>> => {
  return axios.default.get(
    `https://pokeapi.co/api/v2/version-group/${id}`,
    options,
  );
};

export const getVersionGroupRetrieveQueryKey = (id: string) => {
  return [`https://pokeapi.co/api/v2/version-group/${id}`] as const;
};

export const getVersionGroupRetrieveInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof versionGroupRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof versionGroupRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getVersionGroupRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof versionGroupRetrieve>>
  > = ({ signal }) => versionGroupRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof versionGroupRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type VersionGroupRetrieveInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof versionGroupRetrieve>>
>;
export type VersionGroupRetrieveInfiniteQueryError = AxiosError<unknown>;

export function useVersionGroupRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof versionGroupRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof versionGroupRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof versionGroupRetrieve>>,
          TError,
          Awaited<ReturnType<typeof versionGroupRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useVersionGroupRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof versionGroupRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof versionGroupRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof versionGroupRetrieve>>,
          TError,
          Awaited<ReturnType<typeof versionGroupRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useVersionGroupRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof versionGroupRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof versionGroupRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get version group
 */

export function useVersionGroupRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof versionGroupRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof versionGroupRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getVersionGroupRetrieveInfiniteQueryOptions(id, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getVersionGroupRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof versionGroupRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof versionGroupRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getVersionGroupRetrieveQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof versionGroupRetrieve>>
  > = ({ signal }) => versionGroupRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof versionGroupRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type VersionGroupRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof versionGroupRetrieve>>
>;
export type VersionGroupRetrieveQueryError = AxiosError<unknown>;

export function useVersionGroupRetrieve<
  TData = Awaited<ReturnType<typeof versionGroupRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof versionGroupRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof versionGroupRetrieve>>,
          TError,
          Awaited<ReturnType<typeof versionGroupRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useVersionGroupRetrieve<
  TData = Awaited<ReturnType<typeof versionGroupRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof versionGroupRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof versionGroupRetrieve>>,
          TError,
          Awaited<ReturnType<typeof versionGroupRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useVersionGroupRetrieve<
  TData = Awaited<ReturnType<typeof versionGroupRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof versionGroupRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get version group
 */

export function useVersionGroupRetrieve<
  TData = Awaited<ReturnType<typeof versionGroupRetrieve>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof versionGroupRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getVersionGroupRetrieveQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Handles Pokemon Encounters as a sub-resource.
 * @summary Get pokemon encounter
 */
export const pokemonEncountersRetrieve = (
  pokemonId: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PokemonEncountersRetrieve200Item[]>> => {
  return axios.default.get(
    `https://pokeapi.co/api/v2/pokemon/${pokemonId}/encounters`,
    options,
  );
};

export const getPokemonEncountersRetrieveQueryKey = (pokemonId: string) => {
  return [`https://pokeapi.co/api/v2/pokemon/${pokemonId}/encounters`] as const;
};

export const getPokemonEncountersRetrieveInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof pokemonEncountersRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  pokemonId: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokemonEncountersRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getPokemonEncountersRetrieveQueryKey(pokemonId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof pokemonEncountersRetrieve>>
  > = ({ signal }) =>
    pokemonEncountersRetrieve(pokemonId, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!pokemonId,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof pokemonEncountersRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PokemonEncountersRetrieveInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof pokemonEncountersRetrieve>>
>;
export type PokemonEncountersRetrieveInfiniteQueryError = AxiosError<unknown>;

export function usePokemonEncountersRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof pokemonEncountersRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  pokemonId: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokemonEncountersRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonEncountersRetrieve>>,
          TError,
          Awaited<ReturnType<typeof pokemonEncountersRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePokemonEncountersRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof pokemonEncountersRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  pokemonId: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokemonEncountersRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonEncountersRetrieve>>,
          TError,
          Awaited<ReturnType<typeof pokemonEncountersRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePokemonEncountersRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof pokemonEncountersRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  pokemonId: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokemonEncountersRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get pokemon encounter
 */

export function usePokemonEncountersRetrieveInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof pokemonEncountersRetrieve>>>,
  TError = AxiosError<unknown>,
>(
  pokemonId: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof pokemonEncountersRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getPokemonEncountersRetrieveInfiniteQueryOptions(
    pokemonId,
    options,
  );

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getPokemonEncountersRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof pokemonEncountersRetrieve>>,
  TError = AxiosError<unknown>,
>(
  pokemonId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokemonEncountersRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getPokemonEncountersRetrieveQueryKey(pokemonId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof pokemonEncountersRetrieve>>
  > = ({ signal }) =>
    pokemonEncountersRetrieve(pokemonId, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!pokemonId,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof pokemonEncountersRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PokemonEncountersRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof pokemonEncountersRetrieve>>
>;
export type PokemonEncountersRetrieveQueryError = AxiosError<unknown>;

export function usePokemonEncountersRetrieve<
  TData = Awaited<ReturnType<typeof pokemonEncountersRetrieve>>,
  TError = AxiosError<unknown>,
>(
  pokemonId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokemonEncountersRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonEncountersRetrieve>>,
          TError,
          Awaited<ReturnType<typeof pokemonEncountersRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePokemonEncountersRetrieve<
  TData = Awaited<ReturnType<typeof pokemonEncountersRetrieve>>,
  TError = AxiosError<unknown>,
>(
  pokemonId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokemonEncountersRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof pokemonEncountersRetrieve>>,
          TError,
          Awaited<ReturnType<typeof pokemonEncountersRetrieve>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePokemonEncountersRetrieve<
  TData = Awaited<ReturnType<typeof pokemonEncountersRetrieve>>,
  TError = AxiosError<unknown>,
>(
  pokemonId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokemonEncountersRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get pokemon encounter
 */

export function usePokemonEncountersRetrieve<
  TData = Awaited<ReturnType<typeof pokemonEncountersRetrieve>>,
  TError = AxiosError<unknown>,
>(
  pokemonId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pokemonEncountersRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getPokemonEncountersRetrieveQueryOptions(
    pokemonId,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}
